<!DOCTYPE html>
<html lang="zh-Hans">
  <head><meta name="generator" content="Hexo 3.9.0"><link rel="manifest" href="/manifest.json"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="React传-3"><meta name="keywords" content="Seven YuanZiWen"><link rel="alternate" href="/atom.xml" title="Seven Blog"><link rel="shortcut icon" type="image/x-icon" href="https://static.yuanziwen.cn/blog/favicon.ico?v=2.11.0">
<link rel="canonical" href="blog.yuanziwen.cn/2019/11/17/React传-3/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1e4ffaffd9b2bc832b39e2b866a92c7b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>React传-3 - Seven Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Seven Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Record
          </li>
      </a><a href="/music/">
        <li class="mobile-menu-item">Music(NoAuto)
          </li>
      </a><a href="/photo/">
        <li class="mobile-menu-item">Album
          </li>
      </a><a href="/book/">
        <li class="mobile-menu-item">Book
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Seven Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Record
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/music/">
            Music(NoAuto)
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/photo/">
            Album
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/book/">
            Book
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">React传-3
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-11-17
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hooks"><span class="toc-text">Hooks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原理探究"><span class="toc-text">原理探究</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#useState-与-useReducer"><span class="toc-text">useState 与 useReducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useEffect-与-useLayoutEffect"><span class="toc-text">useEffect 与 useLayoutEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useImperativeHandle"><span class="toc-text">useImperativeHandle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useMemo-与-useCallback"><span class="toc-text">useMemo 与 useCallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useRef"><span class="toc-text">useRef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createContext"><span class="toc-text">createContext</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后话"><span class="toc-text">后话</span></a></li></ol>
    </div>
  </div><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.2.1/css/hint.min.css"><p><img src="https://static.yuanziwen.cn/blog/react-source-code/6.png_plain" alt="alt=poster"></p>
<p>本节是Hook专题，将从 preact 借鉴 Hook 的底层原理实现，虽然实际上 preact 与 react 的 实现有所差异，但是胜在简单，了解了解思路逻辑也是可以的嘛。</p>
<a id="more"></a>

<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>目前react内置了13种hooks</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  useCallback, <span class="comment">// ---- 缓存函数</span></span><br><span class="line">  useMemo,    <span class="comment">// ---- 缓存函数</span></span><br><span class="line">  useContext,  <span class="comment">// ---- 上下文共享状态 hook</span></span><br><span class="line">  useEffect,   <span class="comment">// ---- 副作用</span></span><br><span class="line">  useLayoutEffect, <span class="comment">// ---- 副作用（阻塞)</span></span><br><span class="line">  useImperativeHandle,<span class="comment">// ---- 暴露子组件命令句柄</span></span><br><span class="line">  useDebugValue, <span class="comment">// ---- 调试hooks</span></span><br><span class="line">  useReducer, <span class="comment">// ---- action hook</span></span><br><span class="line">  useRef,     <span class="comment">// ---- ref引用</span></span><br><span class="line">  useState,   <span class="comment">// ---- state Hook</span></span><br><span class="line">  useResponder,</span><br><span class="line">  useTransition,</span><br><span class="line">  useDeferredValue,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./ReactHooks'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;withSuspenseConfig&#125; <span class="keyword">from</span> <span class="string">'./ReactBatchConfig'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (exposeConcurrentModeAPIs <span class="comment">/* false */</span>) &#123;</span><br><span class="line">  React.useTransition = useTransition;</span><br><span class="line">  React.useDeferredValue = useDeferredValue;</span><br><span class="line">  React.SuspenseList = REACT_SUSPENSE_LIST_TYPE;</span><br><span class="line">  React.unstable_withSuspenseConfig = withSuspenseConfig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (enableFlareAPI<span class="comment">/* false */</span>) &#123;</span><br><span class="line">  React.unstable_useResponder = useResponder;</span><br><span class="line">  React.unstable_createResponder = createResponder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后3个 Hook 尚处于 unstable ，需要等到支持<code>conCurrentMode</code>，这里就不去赘述。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span>&gt;(<span class="params">initialState: ((</span>) =&gt; <span class="title">S</span>) | <span class="title">S</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">inputs</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useEffect(create, inputs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useRef</span>&lt;<span class="title">T</span>&gt;(<span class="params">initialValue: T</span>): </span>&#123;current: T&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useRef(initialValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从最常用的useState、useEffect、useRef源码，可以看到几乎都和 <code>resolveDispatcher</code> 函数有关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveDispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">  invariant(</span><br><span class="line">    dispatcher !== <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for'</span> +</span><br><span class="line">      <span class="string">' one of the following reasons:\n'</span> +</span><br><span class="line">      <span class="string">'1. You might have mismatching versions of React and the renderer (such as React DOM)\n'</span> +</span><br><span class="line">      <span class="string">'2. You might be breaking the Rules of Hooks\n'</span> +</span><br><span class="line">      <span class="string">'3. You might have more than one copy of React in the same app\n'</span> +</span><br><span class="line">      <span class="string">'See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.'</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都知道 <code>Hooks</code> 的三条铁则，这些方法只会在拿到节点实例的时候触发执行，为了适配多平台<code>ReactCurrentDispatcher</code> 实际上需要等到 <code>react-dom</code> 渲染的时候才能拿到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Keeps track of the current dispatcher.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> ReactCurrentDispatcher = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@type <span class="type">&#123;ReactComponent&#125;</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  current: (<span class="literal">null</span>: <span class="literal">null</span> | Dispatcher),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>光看这些得不到什么比较有效的信息，但本质上是将节点实例返回后调用该节点实例上的对应方法。</p>
<h2 id="原理探究"><a href="#原理探究" class="headerlink" title="原理探究"></a>原理探究</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [str, setStr] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> change = useCallback(<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    setStr(e.target.value)</span><br><span class="line">  &#125;,[])</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'effect'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'effect clean'</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,[<span class="built_in">Math</span>.random()])</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'layoutEffect'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'layoutEffect clean'</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [str])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;input value=&#123;str&#125; onChange=&#123;change&#125; /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个简单的Hook组件，可能会有个疑问，<code>Hooks</code> 是针对 Function Component 设计的Api，从而赋予 Function Component 拥有与类组件同样保存状态的能力。为什么不会被实例化还能够拥有状态，是怎么做到的？</p>
<p>其实Hook都依赖了闭包，而hook之间依靠单向链表的方式串联，从而拥有了“状态”，这也是之所以为什么Hooks必须在函数作用域的最顶层声明且不能嵌套在块级作用域内，如果在某个循环或者是表达式内跳过执行，那么上一次的Hook“链表”和本次update的链表某个指针指向错误，将会得到意料之外的结果。</p>
<p>可以借鉴下<a href="https://github.com/preactjs/preact/blob/master/hooks/src/index.js#L75" target="_blank" rel="noopener"><code>preact</code></a>的实现，与React不同，preact使用的是下标索引。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化时，只有一个catchError属性</span></span><br><span class="line"><span class="keyword">import</span> &#123; options &#125; <span class="keyword">from</span> <span class="string">'preact'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentIndex; <span class="comment">// 当前hook索引</span></span><br><span class="line"><span class="keyword">let</span> currentComponent; <span class="comment">// 当前组件</span></span><br><span class="line"><span class="keyword">let</span> afterPaintEffects = []; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存旧方法，初始为 undefined</span></span><br><span class="line"><span class="keyword">let</span> oldBeforeRender = options._render;</span><br><span class="line"><span class="keyword">let</span> oldAfterDiff = options.diffed;</span><br><span class="line"><span class="keyword">let</span> oldCommit = options._commit;</span><br><span class="line"><span class="keyword">let</span> oldBeforeUnmount = options.unmount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * currentComponent get hook state</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>index The index of the hook to get</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;import('./internal').HookState&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHookState</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (options._hook) options._hook(currentComponent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hooks = currentComponent.__hooks ||  (currentComponent.__hooks = &#123;</span><br><span class="line">        _list: [], <span class="comment">// 放置effect的状态</span></span><br><span class="line">        _pendingEffects: []， <span class="comment">// 渲染下一帧后要调用的effect队列</span></span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="comment">// 新建effect</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= hooks._list.length) &#123;</span><br><span class="line">      hooks._list.push(&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hooks._list[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>getHookState</code> 收集管理Effect，即便没有实例化其本质上是函数每次都会重新执行。通过比较依赖值结果来决定逻辑更新，从这点上看<code>getHookState</code>是一个组件的核心管理器。需要注意的是 <code>_pendingEffect</code> 放入的是不阻塞页面渲染的 effect 操作，也就是useEffect。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface ComponentHooks &#123;</span><br><span class="line">  _list: HookState[];</span><br><span class="line">  _pendingEffects: EffectHookState[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface Component extends PreactComponent&lt;any, any&gt; &#123;</span><br><span class="line">  __hooks?: ComponentHooks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hook组件与类组件差不多，只不过多了一个<code>__hooks</code>属性 —— hooks管理器。</p>
<h3 id="useState-与-useReducer"><a href="#useState-与-useReducer" class="headerlink" title="useState 与 useReducer"></a>useState 与 useReducer</h3><p>匆匆一瞥:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;import('./index'). StateUpdater&lt;any&gt;&#125;</span> <span class="variable">initialState</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useReducer(invokeOrReturn, initialState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;import('./index').Reducer&lt;any, any&gt;&#125;</span> <span class="variable">reducer</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;import('./index').StateUpdater&lt;any&gt;&#125;</span> <span class="variable">initialState</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;(initialState: any) =&gt; void&#125;</span> </span>[init]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;[ any, (state: any) =&gt; void ]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useReducer</span>(<span class="params">reducer, initialState, init</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/** <span class="doctag">@type <span class="type">&#123;import('./internal').ReducerHookState&#125;</span> </span>*/</span></span><br><span class="line">  <span class="keyword">const</span> hookState = getHookState(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (!hookState._component) &#123;</span><br><span class="line">    hookState._component = currentComponent;</span><br><span class="line"></span><br><span class="line">    hookState._value = [</span><br><span class="line">      !init ? invokeOrReturn(<span class="literal">undefined</span>, initialState) : init(initialState),</span><br><span class="line"></span><br><span class="line">      action =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> nextValue = reducer(hookState._value[<span class="number">0</span>], action);</span><br><span class="line">        <span class="keyword">if</span> (hookState._value[<span class="number">0</span>] !== nextValue) &#123;</span><br><span class="line">          hookState._value[<span class="number">0</span>] = nextValue;</span><br><span class="line">          hookState._component.setState(&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hookState._value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 preact 里 useState 与useReducer是一码事。也可以使用useState定义useReducer。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyReducer</span>(<span class="params">reducer, initialState, init</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> compatible = init ? init(initialState) : initialState;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(compatible);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nextState = reducer(state, action);</span><br><span class="line">    setState(nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [state, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Foo组件effect收集阶段，useState调用useReducer传入加工函数<code>invokeOrReturn</code>作为reducer传入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeOrReturn</span>(<span class="params">arg, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> f === <span class="string">'function'</span> ? f(arg) : f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>getHookState</code>在当前组件申明一个新的hooks，放入<code>currentComponent.__hooks._list</code>然后将其返回。hookState暂时只是个空对象，当它没有关联组件时需要对其进行当前组件的关联。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useReducer</span>(<span class="params">reducer, initialState, init</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hookState = getHookState(currentIndex++);<span class="comment">// 创建hook</span></span><br><span class="line">  <span class="keyword">if</span> (!hookState._component) &#123;</span><br><span class="line">    hookState._component = currentComponent; <span class="comment">// 关联到当前组件</span></span><br><span class="line"></span><br><span class="line">    hookState._value = [</span><br><span class="line">      !init ? invokeOrReturn(<span class="literal">undefined</span>, initialState) : init(initialState),<span class="comment">// 初始值</span></span><br><span class="line"></span><br><span class="line">      action =&gt; &#123;</span><br><span class="line">        <span class="comment">// action 即setStr更新器的参数</span></span><br><span class="line">        <span class="keyword">const</span> nextValue = reducer(hookState._value[<span class="number">0</span>], action);</span><br><span class="line">        <span class="keyword">if</span> (hookState._value[<span class="number">0</span>] !== nextValue) &#123;</span><br><span class="line">          hookState._value[<span class="number">0</span>] = nextValue;</span><br><span class="line">          hookState._component.setState(&#123;&#125;);<span class="comment">// 再通过类组件的setState去通知更新</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hookState._value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ./internal.ts</span></span><br><span class="line"><span class="keyword">export</span> interface ReducerHookState &#123;</span><br><span class="line">  _value?: any; <span class="comment">// 值与更新器</span></span><br><span class="line">  _component?: Component; <span class="comment">// 关联组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hookState._value 返回的即是平常所用的 <code>const [str, setStr] = useState(&#39;&#39;);</code>，值与更新器。<br>hookState._component 就是一个简单的无状态组件，但是React底层仍然是通过调用setState触发enqueueRender进行diff更新。</p>
<p>这些后面再写…因为确实很难简短描述。</p>
<h3 id="useEffect-与-useLayoutEffect"><a href="#useEffect-与-useLayoutEffect" class="headerlink" title="useEffect 与 useLayoutEffect"></a>useEffect 与 useLayoutEffect</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any[]&#125;</span> <span class="variable">oldArgs</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any[]&#125;</span> <span class="variable">newArgs</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argsChanged</span>(<span class="params">oldArgs, newArgs</span>) </span>&#123; <span class="comment">// 比对新旧依赖</span></span><br><span class="line">  <span class="keyword">return</span> !oldArgs || newArgs.some(<span class="function">(<span class="params">arg, index</span>) =&gt;</span> arg !== oldArgs[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;import('./internal').Effect&#125;</span> <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any[]&#125;</span> </span>args 依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/** <span class="doctag">@type <span class="type">&#123;import('./internal').EffectHookState&#125;</span> </span>*/</span></span><br><span class="line">  <span class="keyword">const</span> state = getHookState(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (argsChanged(state._args, args)) &#123; <span class="comment">// 比对依赖决定是否执行</span></span><br><span class="line">    state._value = callback;</span><br><span class="line">    state._args = args;</span><br><span class="line">    <span class="comment">// 推入 effect 队列</span></span><br><span class="line">    currentComponent.__hooks._pendingEffects.push(state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;import('./internal').Effect&#125;</span> <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any[]&#125;</span> <span class="variable">args</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useLayoutEffect</span>(<span class="params">callback, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/** <span class="doctag">@type <span class="type">&#123;import('./internal').EffectHookState&#125;</span> </span>*/</span></span><br><span class="line">  <span class="keyword">const</span> state = getHookState(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (argsChanged(state._args, args)) &#123;</span><br><span class="line">    state._value = callback;</span><br><span class="line">    state._args = args;</span><br><span class="line">    <span class="comment">// 推入组件render回调队列</span></span><br><span class="line">    currentComponent._renderCallbacks.push(state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./internal.ts</span></span><br><span class="line"><span class="keyword">export</span> interface EffectHookState &#123;</span><br><span class="line">  _value?: Effect; <span class="comment">// 回调函数</span></span><br><span class="line">  _args?: any[]; <span class="comment">// 依赖项</span></span><br><span class="line">  _cleanup?: Cleanup; <span class="comment">// 清理函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://static.yuanziwen.cn/blog/react/1.png_plain" alt></p>
<p>useEffect 与 useLayoutEffect 唯一不同的是在于推入的队列以及执行的时机，前面讲到过，<code>__hooks._pendingEffects</code> 队列执行的时机是下一帧绘制前执行(本次render后，下次render前)，不阻塞本次的浏览器渲染。而 <code>_renderCallbacks</code> 则在组件commit钩子内执行</p>
<p>组件render的流程是怎样的？还有是怎么进行比对和派发更新的。</p>
<p>在 Function Component中 除去 vnode 阶段外，组件自身有四个钩子阶段，也就是 render=&gt;diffed=&gt;commit=&gt;unmount</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">options._render = <span class="function"><span class="params">vnode</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldBeforeRender) oldBeforeRender(vnode);</span><br><span class="line"></span><br><span class="line">  currentComponent = vnode._component; <span class="comment">// 当前组件</span></span><br><span class="line">  currentIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentComponent.__hooks) &#123;</span><br><span class="line">    <span class="comment">// 先执行清理函数</span></span><br><span class="line">    currentComponent.__hooks._pendingEffects.forEach(invokeCleanup);</span><br><span class="line">    <span class="comment">// 清空上次渲染未处理的Effect(useEffect)</span></span><br><span class="line">    currentComponent.__hooks._pendingEffects.forEach(invokeEffect);</span><br><span class="line">    currentComponent.__hooks._pendingEffects = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">options.diffed = <span class="function"><span class="params">vnode</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldAfterDiff) oldAfterDiff(vnode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> c = vnode._component;</span><br><span class="line">  <span class="keyword">if</span> (!c) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hooks = c.__hooks;</span><br><span class="line">  <span class="keyword">if</span> (hooks) &#123;</span><br><span class="line">    <span class="comment">// vnode 的 diff 完成之后，将当前的_pendingEffects推进执行队列</span></span><br><span class="line">    <span class="keyword">if</span> (hooks._pendingEffects.length) &#123;</span><br><span class="line">       <span class="comment">// afterPaint 本次帧绘完——下一帧开始前执行</span></span><br><span class="line">      afterPaint(afterPaintEffects.push(c));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">options._commit = <span class="function">(<span class="params">vnode, commitQueue</span>) =&gt;</span> &#123;</span><br><span class="line">  commitQueue.some(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行阻塞渲染任务内的清理函数</span></span><br><span class="line">    component._renderCallbacks.forEach(invokeCleanup);</span><br><span class="line">    <span class="comment">// 更新清理函数</span></span><br><span class="line">    component._renderCallbacks = component._renderCallbacks.filter(<span class="function"><span class="params">cb</span> =&gt;</span></span><br><span class="line">      cb._value ? invokeEffect(cb) : <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldCommit) oldCommit(vnode, commitQueue);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">options.unmount = <span class="function"><span class="params">vnode</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldBeforeUnmount) oldBeforeUnmount(vnode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> c = vnode._component;</span><br><span class="line">  <span class="keyword">if</span> (!c) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hooks = c.__hooks;</span><br><span class="line">  <span class="keyword">if</span> (hooks) &#123;</span><br><span class="line">    <span class="comment">// 组件卸载直接执行清理函数</span></span><br><span class="line">    hooks._list.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> hook._cleanup &amp;&amp; hook._cleanup());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;import('./internal').EffectHookState&#125;</span> <span class="variable">hook</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeCleanup</span>(<span class="params">hook</span>) </span>&#123; <span class="comment">// 执行清理函数</span></span><br><span class="line">    <span class="keyword">if</span> (hook._cleanup) hook._cleanup();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke a Hook's effect</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;import('./internal').EffectHookState&#125;</span> <span class="variable">hook</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeEffect</span>(<span class="params">hook</span>) </span>&#123; <span class="comment">// 执行回调函数</span></span><br><span class="line">    <span class="keyword">const</span> result = hook._value();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">'function'</span>) hook._cleanup = result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后有两个函数,<code>invokeCleanup</code> 和 <code>invokeEffect</code> 用来执行清理函数和回调函数.</p>
<p>前面三个钩子在<a href="https://github.com/preactjs/preact/blob/4f52598076a7d09c13a57d1c5d64610047332074/src/render.js#L16" target="_blank" rel="noopener">render</a>函数内被同步调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, parentDom, replaceNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (options._root) options._root(vnode, parentDom);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isHydrating = replaceNode === IS_HYDRATE;</span><br><span class="line">  <span class="keyword">let</span> oldVNode = isHydrating  ? <span class="literal">null</span> </span><br><span class="line">    : (replaceNode &amp;&amp; replaceNode._children) || parentDom._children;</span><br><span class="line">  vnode = createElement(Fragment, <span class="literal">null</span>, [vnode]); <span class="comment">// 创建新的vnode</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> commitQueue = [];</span><br><span class="line">  diff(</span><br><span class="line">    parentDom, <span class="comment">// 父节点</span></span><br><span class="line">    ((isHydrating ? parentDom : replaceNode || parentDom)._children = vnode), <span class="comment">// newVnode</span></span><br><span class="line">    oldVNode || EMPTY_OBJ, <span class="comment">// oldVNode ，初始化渲染时为空对象</span></span><br><span class="line">    EMPTY_OBJ, <span class="comment">// 上下文对象</span></span><br><span class="line">    parentDom.ownerSVGElement !== <span class="literal">undefined</span>, <span class="comment">// 是否为Svg节点</span></span><br><span class="line">    replaceNode &amp;&amp; !isHydrating <span class="comment">// 替换的同级节点</span></span><br><span class="line">      ? [replaceNode]</span><br><span class="line">      : oldVNode</span><br><span class="line">      ? <span class="literal">null</span></span><br><span class="line">      : EMPTY_ARR.slice.call(parentDom.childNodes),</span><br><span class="line">    commitQueue, <span class="comment">// 有阻塞渲染任务的effect组件列表——useLayoutEffect</span></span><br><span class="line">    replaceNode || EMPTY_OBJ, <span class="comment">// 替换的节点</span></span><br><span class="line">    isHydrating <span class="comment">// 是否节点复用，服务端渲染使用</span></span><br><span class="line">  );</span><br><span class="line">  commitRoot(commitQueue, vnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的功能不用涉及，首先进行diff，<a href="https://github.com/preactjs/preact/blob/63eb63c0275096e81d0d6beac76a09fd8dc1ea5c/src/diff/index.js#L25" target="_blank" rel="noopener">diff</a>负责执行生命周期类方法以及调用<code>_render</code> 和 <code>diffed</code> 方法。</p>
<ul>
<li>_render 负责将 <code>currentComponent</code> 指向 <code>vnode._component</code> 并执行 <code>_pendingEffects</code> 队列。</li>
<li>diffed 执行 <code>afterPaint(afterPaintEffects.push(c))</code> 会把带有 <code>_pendingEffects</code> 推入 <code>afterPaintEffects</code> 队列，然后 <code>afterPaint</code> 调用 <code>afterNextFrame(flushAfterPaintEffects)</code> 执行effect 保证其在下一帧前调用.</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">afterPaint</span>(<span class="params">newQueueLength</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// diffed在每次render内只执行一次</span></span><br><span class="line">  <span class="keyword">if</span> (newQueueLength === <span class="number">1</span> || prevRaf !== options.requestAnimationFrame) &#123;</span><br><span class="line">    prevRaf = options.requestAnimationFrame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    (prevRaf || afterNextFrame)(flushAfterPaintEffects);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当raf运行在后台标签页或者隐藏的&lt;iframe&gt; 里时，会被暂停调用以提升性能和电池寿命。</span></span><br><span class="line"><span class="comment"> * 当前帧的raf并不会结束，所以需要结合setTimeout以确保即使raf没有触发也会调用回调</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;() =&gt; void&#125;</span> <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">afterNextFrame</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> done = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    cancelAnimationFrame(raf);</span><br><span class="line">    setTimeout(callback);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> timeout = setTimeout(done, RAF_TIMEOUT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> raf;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    raf = requestAnimationFrame(done);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushAfterPaintEffects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  afterPaintEffects.some(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (component._parentDom) &#123; <span class="comment">// 如果节点还在html内</span></span><br><span class="line">      <span class="comment">// 执行清理函数</span></span><br><span class="line">      component.__hooks._pendingEffects.forEach(invokeCleanup);</span><br><span class="line">      <span class="comment">// 执行effects</span></span><br><span class="line">      component.__hooks._pendingEffects.forEach(invokeEffect);</span><br><span class="line">      component.__hooks._pendingEffects = [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  afterPaintEffects = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到diff后的vnode之后，还不能进行渲染。</p>
<ul>
<li>commit 阶段，在<a href="https://github.com/preactjs/preact/blob/63eb63c0275096e81d0d6beac76a09fd8dc1ea5c/src/diff/index.js#L230" target="_blank" rel="noopener">commitRoot</a> 内被调用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&lt;import('../internal').Component&gt;&#125;</span> </span>commitQueue 含有layoutEffect阻塞渲染任务组件列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;import('../internal').VNode&#125;</span> </span>root vnode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params">commitQueue, root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (options._commit) options._commit(root, commitQueue);</span><br><span class="line"></span><br><span class="line">  commitQueue.some(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 清空执行任务</span></span><br><span class="line">      commitQueue = c._renderCallbacks;</span><br><span class="line">      c._renderCallbacks = [];</span><br><span class="line">      commitQueue.some(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">        cb.call(c);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      options._catchError(e, c._vnode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个阶段在<a href="https://github.com/preactjs/preact/blob/1142fff2b863f59297ee014611deb3f28929dfaa/src/diff/children.js#L26" target="_blank" rel="noopener">diffChildren</a> 删除vnode之前执行.</p>
<h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p>在官方例子里,<code>useImperativeHandle</code>用于获取子组件实例方法.因为自定义组件会过滤ref所以通常要与 <code>forwardRef</code> 组合搭配.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FancyInput = forwardRef(</span><br><span class="line">  (props, ref) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">    useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">      focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        inputRef.current.focus();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> childrenRef = useRef()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;FancyInput ref=&#123;childrenRef&#125;/&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; childrenRef.focus()&#125;&gt;click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其原理是获取到父组件的ref后将实例方法对象传入.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> <span class="variable">ref</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;() =&gt; object&#125;</span> <span class="variable">createHandle</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any[]&#125;</span> <span class="variable">args</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useImperativeHandle</span>(<span class="params">ref, createHandle, args</span>) </span>&#123;</span><br><span class="line">  useLayoutEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="comment">//兼容旧版本createRef</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">'function'</span>) ref(createHandle());</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ref) ref.current = createHandle();</span><br><span class="line">    &#125;,</span><br><span class="line">    args == <span class="literal">null</span> ? args : args.concat(ref) <span class="comment">// 依赖值</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useMemo-与-useCallback"><a href="#useMemo-与-useCallback" class="headerlink" title="useMemo 与 useCallback"></a>useMemo 与 useCallback</h3><p>useCallback 是 useMemo的函数版本,其原理实现相同.通过比较依赖的变化返回新值.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;() =&gt; any&#125;</span> <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any[]&#125;</span> <span class="variable">args</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useMemo</span>(<span class="params">callback, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/** <span class="doctag">@type <span class="type">&#123;import('./internal').MemoHookState&#125;</span> </span>*/</span></span><br><span class="line">  <span class="keyword">const</span> state = getHookState(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (argsChanged(state._args, args)) &#123; <span class="comment">// 比对依赖是否重新创建</span></span><br><span class="line">    state._args = args;</span><br><span class="line">    state._callback = callback;</span><br><span class="line">    <span class="keyword">return</span> (state._value = callback());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state._value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;() =&gt; void&#125;</span> <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any[]&#125;</span> <span class="variable">args</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useCallback</span>(<span class="params">callback, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useMemo(<span class="function"><span class="params">()</span> =&gt;</span> callback, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>useRef也是对于useMemo的变种.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useRef</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">current</span>: initialValue &#125;), []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createContext"><a href="#createContext" class="headerlink" title="createContext"></a>createContext</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/create-context.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createContext</span>(<span class="params">defaultValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> context = &#123;</span><br><span class="line">    _id: <span class="string">'__cC'</span> + i++,</span><br><span class="line">    _defaultValue: defaultValue,</span><br><span class="line">    Consumer(props, context) &#123;</span><br><span class="line">      <span class="keyword">return</span> props.children(context);</span><br><span class="line">    &#125;,</span><br><span class="line">    Provider(props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.getChildContext) &#123;</span><br><span class="line">        <span class="keyword">const</span> subs = [];</span><br><span class="line">        <span class="keyword">this</span>.getChildContext = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          ctx[context._id] = <span class="keyword">this</span>;</span><br><span class="line">          <span class="keyword">return</span> ctx;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.shouldComponentUpdate = <span class="function"><span class="params">_props</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (props.value !== _props.value) &#123;</span><br><span class="line">            subs.some(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">              c.context = _props.value;</span><br><span class="line">              <span class="comment">// provide值变化时更新订阅的组件</span></span><br><span class="line">              enqueueRender(c);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.sub = <span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">          subs.push(c);</span><br><span class="line">          <span class="keyword">let</span> old = c.componentWillUnmount;</span><br><span class="line">          c.componentWillUnmount = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 组件卸载时从订阅中移除</span></span><br><span class="line">            subs.splice(subs.indexOf(c), <span class="number">1</span>);</span><br><span class="line">            old &amp;&amp; old.call(c);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> props.children;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  context.Consumer.contextType = context;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/hooks/index</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;import('./internal').PreactContext&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useContext</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> provider = currentComponent.context[context._id];</span><br><span class="line">  <span class="keyword">if</span> (!provider) <span class="keyword">return</span> context._defaultValue; <span class="comment">// 没有找到Provide组件</span></span><br><span class="line">  <span class="keyword">const</span> state = getHookState(currentIndex++);</span><br><span class="line">  <span class="comment">// This is probably not safe to convert to "!"</span></span><br><span class="line">  <span class="keyword">if</span> (state._value == <span class="literal">null</span>) &#123;</span><br><span class="line">    state._value = <span class="literal">true</span>;</span><br><span class="line">    provider.sub(currentComponent); <span class="comment">// 订阅组件</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> provider.props.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过订阅收发的模式生产和消费数据.</p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>本文的目的是研究Hooks原理与机制,实际上 preact 与 react 其实有很多地方不一样,其底层如children和ref的处理机制受限;children只能是数组,react则可以是任何数据;ref的获取时机;事件系统直接绑定在元素上而非基于冒泡;由于体积较小diff算法过于简单;setState的时机被推迟;生态问题…</p>
<p>不过作为一个只有3kb的库,确实不能对其要求太高.</p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="blog.yuanziwen.cn">Seven</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="blog.yuanziwen.cn/2019/11/17/React传-3/">blog.yuanziwen.cn/2019/11/17/React传-3/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/React/">React</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2019/12/16/为什么ServerLess/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">为什么ServerLess</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2019/10/30/React传-2/">
        <span class="next-text nav-default">React传-2</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'cxeaTV5BFDCxPmxoCcG9QPxf-gzGzoHsz',
        appKey: 's577OrPG5sB4Szom6mvHuI1X',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info: guest,
        pageSize:'10' || 10,
    });
  </script>

<footer id="footer" class="footer"><div class="social-links"><a href="mailto:yuanziwen7489757@gmail.com" class="iconfont icon-email" title="email"></a>
          <a href="https://juejin.im/user/59aa31a06fb9a02485103ddf" class="iconfont juejin" title="掘金"><div class="img"></div></a>
        <a href="https://github.com/yzw7489757" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <!--<span class="division">|</span>
  <span class="theme-info">
    footer.theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>-->
  <span class="power-by">
   <a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备18011257号-1</a>
  </span>
  <span class="copyright-year">&copy;2017 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Seven</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
<script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js?t=1593502596546')
    .then(function () {console.log('ServiceWorker Register Successfully.')})
    .catch(function (e) {console.error(e)});
}
</script></body>
</html>
