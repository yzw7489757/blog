<!DOCTYPE html>
<html lang="zh-Hans">
  <head><meta name="generator" content="Hexo 3.9.0"><link rel="manifest" href="/manifest.json"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="React传-1"><meta name="keywords" content="Seven YuanZiWen"><link rel="alternate" href="/atom.xml" title="Seven Blog"><link rel="shortcut icon" type="image/x-icon" href="https://static.yuanziwen.cn/blog/favicon.ico?v=2.11.0">
<link rel="canonical" href="blog.yuanziwen.cn/2019/09/24/React传-1/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1e4ffaffd9b2bc832b39e2b866a92c7b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>React传-1 - Seven Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Seven Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Record
          </li>
      </a><a href="/music/">
        <li class="mobile-menu-item">Music(NoAuto)
          </li>
      </a><a href="/photo/">
        <li class="mobile-menu-item">Album
          </li>
      </a><a href="/book/">
        <li class="mobile-menu-item">Book
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Seven Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Record
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/music/">
            Music(NoAuto)
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/photo/">
            Album
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/book/">
            Book
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">React传-1
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-09-24
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#写在前面"><span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#起源"><span class="toc-text">起源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从入口开始"><span class="toc-text">从入口开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Component"><span class="toc-text">Component</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ExpirationTime"><span class="toc-text">ExpirationTime</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PureComponent"><span class="toc-text">PureComponent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#createRef"><span class="toc-text">createRef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Children"><span class="toc-text">Children</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Children-map"><span class="toc-text">Children.map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mapChildren"><span class="toc-text">mapChildren</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mapIntoWithKeyPrefixInternal"><span class="toc-text">mapIntoWithKeyPrefixInternal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getPooledTraverseContext-与-releaseTraverseContext"><span class="toc-text">getPooledTraverseContext 与 releaseTraverseContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#traverseAllChildren-traverseAllChildrenImpl"><span class="toc-text">traverseAllChildren/traverseAllChildrenImpl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mapSingleChildIntoContext"><span class="toc-text">mapSingleChildIntoContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#整体流程"><span class="toc-text">整体流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Children-forEach"><span class="toc-text">Children.forEach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Children-count"><span class="toc-text">Children.count</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Children-toArray"><span class="toc-text">Children.toArray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Children-only"><span class="toc-text">Children.only</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReactElement"><span class="toc-text">ReactElement</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#createElement"><span class="toc-text">createElement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#create-ReactElement"><span class="toc-text">create ReactElement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createFactory"><span class="toc-text">createFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cloneElement"><span class="toc-text">cloneElement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cloneAndReplaceKey"><span class="toc-text">cloneAndReplaceKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isValidElement"><span class="toc-text">isValidElement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsx-jsxDEV"><span class="toc-text">jsx/jsxDEV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defineRefPropWarningGetter-defineKeyPropWarningGetter"><span class="toc-text">defineRefPropWarningGetter/defineKeyPropWarningGetter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hasValidRef-hasValidKey"><span class="toc-text">hasValidRef/hasValidKey</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.2.1/css/hint.min.css"><p><img src="https://static.yuanziwen.cn/blog/react-source-code/4.png_plain" alt="alt=poster"></p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>计划用半年的时间去深入 <code>React</code> 源码并记录下来，本文是系列文章第一章，前面大多数会以功能为主，不会涉及太多事务机制与流程，后半部分以架构、流程为主。这个是一个水到渠成的事情。看的越多，对其理解的广度就越大，深度也随之沉淀，在深入的同时站在作者的角度去思考，能够脱离源码照葫芦画瓢，才能算理解，读懂本身源码并不重要。可能没有什么休息时间，但是会尽量挤出来完善文章，也算是一种兴趣与习惯。</p>
<a id="more"></a>

<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>2011 年，前端工程师 <code>Jordan Walke</code> 创建了ReactJS的早期原型FaxJS。</p>
<iframe src="https://cdn.knightlab.com/libs/timeline3/latest/embed/index.html?source=16Khs43YDBSpoiq23SFEExAA2kzOsa7hri-MWw2QC940&font=Default&lang=en&initial_zoom=2&height=650" width="100%" height="700px" frameborder="0" scrolling="no"> </iframe>

<p><a href="https://cdn.knightlab.com/libs/timeline3/latest/embed/index.html?source=16Khs43YDBSpoiq23SFEExAA2kzOsa7hri-MWw2QC940" target="_blank" rel="noopener">时间轴</a></p>
<p>，</p>
<h2 id="从入口开始"><a href="#从入口开始" class="headerlink" title="从入口开始"></a>从入口开始</h2><p>时至今日(2019.9.28)，五个小时前<code>React</code>已经将版本更新到 <code>16.10.0</code> 了，预计大半年内将步入17大版本。希望在系列文章完结之后更新(免得我又得看一遍)。</p>
<p>React 与 Vue 的源码相同的使用 Facebook 开源的 Flow 静态类型检查工具，为什么要用 Flow 而不用 Typescript ？ 原因可能是 React 诞生的时间较早，那时候还没有 Typescript，后来也由于 Typescript 15年被社区广泛接受才火起来。还一个原因是 Flow 没有 Typescript 那么“严格”，所有的检查都是可选的。</p>
<p>fork/clone/open三部曲，找到 <code>packages/react/src/React.js</code>，剔除注释和空白行的源码还不到一百行，这个入口文件集成了所有的api暴露出去。</p>
<blockquote>
<p>React中的源码与React-DOM分离，所以在packages/React内很多只是“形”上的API</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactVersion <span class="keyword">from</span> <span class="string">'../../shared/ReactVersion'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  REACT_FRAGMENT_TYPE,</span><br><span class="line">  REACT_PROFILER_TYPE,</span><br><span class="line">  REACT_STRICT_MODE_TYPE,</span><br><span class="line">  REACT_SUSPENSE_TYPE,</span><br><span class="line">  REACT_SUSPENSE_LIST_TYPE,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../../shared/ReactSymbols'</span>;</span><br></pre></td></tr></table></figure>

<p>最顶部导入了React当前版本号，<code>ReactSymbols</code> 文件管理着全局的 <code>React</code>功能组件 Symbol 标志</p>
<h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component, PureComponent&#125; <span class="keyword">from</span> <span class="string">'./ReactBaseClasses'</span>;</span><br></pre></td></tr></table></figure>

<p><code>Component</code> 和 <code>PureComponent</code> 组件都是经常用的， 猜也能猜到都是定义一些初始化方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.props = props;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">  <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue; <span class="comment">// 更新器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Component.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  invariant(</span><br><span class="line">    <span class="keyword">typeof</span> partialState === <span class="string">'object'</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> partialState === <span class="string">'function'</span> ||</span><br><span class="line">      partialState == <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'setState(...): takes an object of state variables to update or a '</span> +</span><br><span class="line">      <span class="string">'function which returns an object of state variables.'</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState, callback, <span class="string">'setState'</span>);<span class="comment">// 加入更新队列</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Component.prototype.forceUpdate = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueForceUpdate(<span class="keyword">this</span>, callback, <span class="string">'forceUpdate'</span>); <span class="comment">// 强制加入更新队列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义了Component类的 <code>setState</code> 和 <code>forceUpdate</code> 方法，以便在组件实例化后调用，将当前的props，context，refs进行绑定，并初始化更新。</p>
<p>每个组件内部都有一个 <code>updater</code> ，被用来驱动state更新的工具对象，执行更新队列，没传入updater时，<code>this.updater</code> 默认为 <code>ReactNoopUpdateQueue</code>，但是它没什么意义，只是做警告用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactNoopUpdateQueue = &#123;</span><br><span class="line">  isMounted: <span class="function"><span class="keyword">function</span>(<span class="params">publicInstance</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  enqueueForceUpdate: <span class="function"><span class="keyword">function</span>(<span class="params">publicInstance, callback, callerName</span>) </span>&#123;</span><br><span class="line">    warnNoop(publicInstance, <span class="string">'forceUpdate'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  enqueueReplaceState: <span class="function"><span class="keyword">function</span>(<span class="params">publicInstance, completeState, callback, callerName</span>) </span>&#123;</span><br><span class="line">    warnNoop(publicInstance, <span class="string">'replaceState'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  enqueueSetState: <span class="function"><span class="keyword">function</span>(<span class="params">publicInstance, partialState, callback, callerName</span>) </span>&#123;</span><br><span class="line">    warnNoop(publicInstance, <span class="string">'setState'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>isMounted</code> 在组件未挂载的情况下<code>isMounted</code> 一直会返回 <code>false</code>,例如在 <code>constructor</code> 里调用 <code>setState</code>或者组件已卸载/未使用，其他方法的作用是在开发环境下警告用户不要在<code>constructor</code> 内调用this原型上的方法。因为实际上真正的 <code>updater</code> 都是在 renderer 后注入的。真正的updater:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> classComponentUpdater = &#123;</span><br><span class="line">  isMounted, <span class="comment">// fn() =&gt; true</span></span><br><span class="line">  enqueueSetState(inst, payload, callback) &#123;</span><br><span class="line">     <span class="comment">// 获取fiber 也就是inst._reactInternalFiber</span></span><br><span class="line">    <span class="keyword">const</span> fiber = getInstance(inst);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 msToExpirationTime(performance.now()) 得到一个时间，后续涉及到 ExpirationTime</span></span><br><span class="line">    <span class="keyword">const</span> currentTime = requestCurrentTimeForUpdate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取suspense配置，与即将新增的 withSuspenseConfig Api强相关，默认情况下都是null</span></span><br><span class="line">    <span class="keyword">const</span> suspenseConfig = requestCurrentSuspenseConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据开始实际计算任务过期时间</span></span><br><span class="line">    <span class="keyword">const</span> expirationTime = computeExpirationForFiber(</span><br><span class="line">      currentTime,</span><br><span class="line">      fiber,</span><br><span class="line">      suspenseConfig,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//创建update对象</span></span><br><span class="line">    <span class="keyword">const</span> update = createUpdate(expirationTime, suspenseConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//setState的更新对象</span></span><br><span class="line">    update.payload = payload;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setState的callback</span></span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        warnOnInvalidCallback(callback, <span class="string">'setState'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      update.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放入队列</span></span><br><span class="line">    enqueueUpdate(fiber, update);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始调度</span></span><br><span class="line">    scheduleWork(fiber, expirationTime);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// other ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setState的任务调度以这种形式发出的，另外 与forceUpdate 、 replaceState 也差不多。</p>
<p>那上面提到的ExpirationTime是什么？</p>
<h3 id="ExpirationTime"><a href="#ExpirationTime" class="headerlink" title="ExpirationTime"></a>ExpirationTime</h3><p>ExpirationTime是一个“保险”，为防止某个update因为优先级的原因一直被打断而未能执行。React会设置一个ExpirationTime，当时间到了ExpirationTime的时候，如果某个update还未执行的话，React将会强制执行该update，这就是ExpirationTime的作用。它有两种计算方法，一种<code>computeInteractiveExpiration</code>同步更新，与 <code>computeAsyncExpiration</code> 返回异步更新的expirationTime</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整型最大数值，V8中针对32位系统所设置的最大值 Math.pow(2,30) - 1;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Sync = MAX_SIGNED_31_BIT_INT; <span class="comment">// 1073741823</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Batched = Sync - <span class="number">1</span>; <span class="comment">// 1073741822</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UNIT_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> MAGIC_NUMBER_OFFSET = Batched - <span class="number">1</span>; <span class="comment">//1073741821</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msToExpirationTime</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> MAGIC_NUMBER_OFFSET - (ms / UNIT_SIZE | <span class="number">0</span>); <span class="comment">// 1073741821 - now()/10|0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ceiling</span>(<span class="params">num: number, precision: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (((num / precision) | <span class="number">0</span>) + <span class="number">1</span>) * precision; <span class="comment">// 取整，本次区间分类最大值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeExpirationBucket</span>(<span class="params">currentTime, expirationInMs, bucketSizeMs</span>): <span class="title">ExpirationTime</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* LOW 任务 =&gt; 1073741821 - ceiling(1073741821 - currentTime + 5000 / 10, 250 / 10)</span></span><br><span class="line"><span class="comment">                1073741821 - (((1073741821 - currentTime + 500) / 25) | 0) * 25 - 25</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* HIGH任务 =&gt; 1073741821 - ceiling(1073741821 - currentTime + (__DEV__ ? 500 : 150) / 10, 100 / 10)</span></span><br><span class="line"><span class="comment">          DEV   1073741821 - ceiling(1073741821 - currentTime + 50, 10)</span></span><br><span class="line"><span class="comment">                1073741821 - (((1073741821 - currentTime + 50) / 10) | 0) * 10 - 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          !DEV  1073741821 - ceiling(1073741821 - currentTime + 15, 10)</span></span><br><span class="line"><span class="comment">                1073741821 - (((1073741821 - currentTime + 15) / 10) | 0) * 10 - 10</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    MAGIC_NUMBER_OFFSET - ceiling(MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// LOW 低优先级任务</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LOW_PRIORITY_EXPIRATION = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LOW_PRIORITY_BATCH_SIZE = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">computeAsyncExpiration</span>(<span class="params">currentTime: ExpirationTime</span>): <span class="title">ExpirationTime</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> computeExpirationBucket(</span><br><span class="line">    currentTime,</span><br><span class="line">    LOW_PRIORITY_EXPIRATION,</span><br><span class="line">    LOW_PRIORITY_BATCH_SIZE,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HIGH 高优先级任务</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HIGH_PRIORITY_EXPIRATION = __DEV__ ? <span class="number">500</span> : <span class="number">150</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HIGH_PRIORITY_BATCH_SIZE = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">computeInteractiveExpiration</span>(<span class="params">currentTime: ExpirationTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> computeExpirationBucket(</span><br><span class="line">    currentTime,</span><br><span class="line">    HIGH_PRIORITY_EXPIRATION,</span><br><span class="line">    HIGH_PRIORITY_BATCH_SIZE,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">computeSuspenseExpiration</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  currentTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  timeoutMs: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ExpirationTime</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> computeExpirationBucket(</span><br><span class="line">    currentTime,</span><br><span class="line">    timeoutMs,</span><br><span class="line">    LOW_PRIORITY_BATCH_SIZE,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>performance.now()</code>生成 currentTime，当不支持<code>performance</code>时转利用<code>Date.now()</code>，这个值不用太过关注，只需要理解成时间戳即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> now1 = performance.now(); <span class="comment">// 53028380</span></span><br><span class="line"><span class="keyword">const</span> now2 = performance.now(); <span class="comment">// 53028389  ↑ 9</span></span><br><span class="line"><span class="keyword">const</span> now3 = performance.now(); <span class="comment">// 53028391  ↑ 11</span></span><br><span class="line"><span class="keyword">const</span> now4 = performance.now(); <span class="comment">// 53028405  ↑ 25</span></span><br><span class="line"><span class="keyword">const</span> now5 = performance.now(); <span class="comment">// 53028420  ↑ 40</span></span><br><span class="line"><span class="keyword">const</span> now6 = performance.now(); <span class="comment">// 53028430  ↑ 50</span></span><br><span class="line"><span class="keyword">const</span> now7 = performance.now(); <span class="comment">// 53028444  ↑ 55</span></span><br><span class="line"><span class="keyword">const</span> now8 = performance.now(); <span class="comment">// 53028468  ↑ 79</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LOW 任务</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now1 + <span class="number">500</span>) / <span class="number">25</span>) | <span class="number">0</span>) * <span class="number">25</span> - <span class="number">25</span>; <span class="comment">// 53027871</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now2 + <span class="number">500</span>) / <span class="number">25</span>) | <span class="number">0</span>) * <span class="number">25</span> - <span class="number">25</span>; <span class="comment">// 53027871 ↑ 0</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now3 + <span class="number">500</span>) / <span class="number">25</span>) | <span class="number">0</span>) * <span class="number">25</span> - <span class="number">25</span>; <span class="comment">// 53027871 ↑ 0</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now4 + <span class="number">500</span>) / <span class="number">25</span>) | <span class="number">0</span>) * <span class="number">25</span> - <span class="number">25</span>; <span class="comment">// 53027896 ↑ 25</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now5 + <span class="number">500</span>) / <span class="number">25</span>) | <span class="number">0</span>) * <span class="number">25</span> - <span class="number">25</span>; <span class="comment">// 53027896 ↑ 25</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now6 + <span class="number">500</span>) / <span class="number">25</span>) | <span class="number">0</span>) * <span class="number">25</span> - <span class="number">25</span>; <span class="comment">// 53027921 ↑ 50</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now7 + <span class="number">500</span>) / <span class="number">25</span>) | <span class="number">0</span>) * <span class="number">25</span> - <span class="number">25</span>; <span class="comment">// 53027921 ↑ 50</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now8 + <span class="number">500</span>) / <span class="number">25</span>) | <span class="number">0</span>) * <span class="number">25</span> - <span class="number">25</span>; <span class="comment">// 53027946 ↑ 75</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HIGH 任务 以DEV模式为例</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now1 + <span class="number">50</span>) / <span class="number">10</span>) | <span class="number">0</span>) * <span class="number">10</span> - <span class="number">10</span>; <span class="comment">// 53028321</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now2 + <span class="number">50</span>) / <span class="number">10</span>) | <span class="number">0</span>) * <span class="number">10</span> - <span class="number">10</span>; <span class="comment">// 53028331 ↑ 10</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now3 + <span class="number">50</span>) / <span class="number">10</span>) | <span class="number">0</span>) * <span class="number">10</span> - <span class="number">10</span>; <span class="comment">// 53028331 ↑ 10</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now4 + <span class="number">50</span>) / <span class="number">10</span>) | <span class="number">0</span>) * <span class="number">10</span> - <span class="number">10</span>; <span class="comment">// 53028351 ↑ 30</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now5 + <span class="number">50</span>) / <span class="number">10</span>) | <span class="number">0</span>) * <span class="number">10</span> - <span class="number">10</span>; <span class="comment">// 53028361 ↑ 40</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now6 + <span class="number">50</span>) / <span class="number">10</span>) | <span class="number">0</span>) * <span class="number">10</span> - <span class="number">10</span>; <span class="comment">// 53028371 ↑ 50</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now7 + <span class="number">50</span>) / <span class="number">10</span>) | <span class="number">0</span>) * <span class="number">10</span> - <span class="number">10</span>; <span class="comment">// 53028391 ↑ 70</span></span><br><span class="line"><span class="number">1073741821</span> - (((<span class="number">1073741821</span> - now8 + <span class="number">50</span>) / <span class="number">10</span>) | <span class="number">0</span>) * <span class="number">10</span> - <span class="number">10</span>; <span class="comment">// 53028411 ↑ 90</span></span><br></pre></td></tr></table></figure>

<p>通过规律，可以看到LOW优先级任务时，区间&lt;25的，得到的都是同一个值，而HIGH高优先级任务的区间为10，单位为毫秒，这个有什么用呢？</p>
<p>如果触发了多次事件，每次难道都要丢enqueueUpdate里立即调度？React让两个相近（25ms内）的update得到相同的expirationTime，它可以将多次事件分批打包丢入 <code>enqueueUpdate</code>里，假如我在24ms内触发了两个事件，那么React会将他们丢入<code>同一批车</code>，目的就是让这两个update自动合并成一个<code>Update</code>，并且只会触发一次更新，从而达到批量更新的目的。</p>
<p>从之前的代码看 computeInteractiveExpiration传入的是150、100，computeAsyncExpiration传入的是5000、250，前者的优先级更高，而过期执行时间为交互事件为 100/UNIT_SIZE = 10，异步事件则为 250/UNIT_SIZE = 25, 佐证了事实。</p>
<h2 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComponentDummy</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">ComponentDummy.prototype = Component.prototype;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PureComponent</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.props = props;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">  <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pureComponentPrototype = (PureComponent.prototype = <span class="keyword">new</span> ComponentDummy());</span><br><span class="line">pureComponentPrototype.constructor = PureComponent;</span><br><span class="line"><span class="comment">// Avoid an extra prototype jump for these methods.</span></span><br><span class="line"><span class="built_in">Object</span>.assign(pureComponentPrototype, Component.prototype);</span><br><span class="line">pureComponentPrototype.isPureReactComponent = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>与 <code>Component</code> 类相同属性的 <code>PureComponent</code> 类有所不同，首先创建了一个空函数 <code>ComponentDummy</code>，并将通过共享原型继承的方式将实例原型指向了 <code>Component</code> 的原型，其构造函数指定为<code>PureComponent</code>。其实就是在外面套了一层 <code>pureComponentPrototype</code> 的 <code>Component</code>。</p>
<h2 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createRef&#125; <span class="keyword">from</span> <span class="string">'./ReactCreateRef'</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRef</span>(<span class="params"></span>): <span class="title">RefObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> refObject = &#123;</span><br><span class="line">    current: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.seal(refObject);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> refObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回一个refObject，其current的属性在组件挂载时进行关联，与react-dom强相关，后面再了解。现在只需要知道它很简单。</p>
<h2 id="Children"><a href="#Children" class="headerlink" title="Children"></a>Children</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;forEach, map, count, toArray, only&#125; <span class="keyword">from</span> <span class="string">'./ReactChildren'</span>;</span><br></pre></td></tr></table></figure>

<p>React 将 children 的 API 暴露出来，这里最常使用的应该是 <code>React.Children.map</code> 和 <code>React.Children.forEach</code> 。</p>
<h3 id="Children-map"><a href="#Children-map" class="headerlink" title="Children.map"></a>Children.map</h3><p>适用于替代 <code>this.props.children.map</code> ，因为这种写法通常用来嵌套组件，但是如果嵌套的是一个函数就会报错。而 <code>React.Children.map</code> 则不会。当需要写一个 <code>Radio</code> 组件需要依赖其父组件 <code>RadioGroup</code> 的 <code>props</code> 值，那么<code>this.props.children.map</code> 配合 <code>cloneElement</code> 简直不能再完美。还可以用来过滤某些组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">React.cloneElement(props.children, &#123;</span><br><span class="line">  name: props.name</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            React.Children.map(children, (child, i) =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> ( i &lt; <span class="number">1</span> ) <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">return</span> child;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="mapChildren"><a href="#mapChildren" class="headerlink" title="mapChildren"></a>mapChildren</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapChildren</span>(<span class="params">children, func, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  mapIntoWithKeyPrefixInternal(children, result, <span class="literal">null</span>, func, context);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="mapIntoWithKeyPrefixInternal"><a href="#mapIntoWithKeyPrefixInternal" class="headerlink" title="mapIntoWithKeyPrefixInternal"></a>mapIntoWithKeyPrefixInternal</h4><p>第一步，如果子组件为null直接不处理。正常情况下申明一个数组，进行加工。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapIntoWithKeyPrefixInternal</span>(<span class="params">children, array, prefix, func, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> escapedPrefix = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">if</span> (prefix != <span class="literal">null</span>) &#123; <span class="comment">// 顾名思义，处理key</span></span><br><span class="line">    escapedPrefix = escapeUserProvidedKey(prefix) + <span class="string">'/'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出一个对象，作为上下文，遍历children</span></span><br><span class="line">  <span class="keyword">const</span> traverseContext = getPooledTraverseContext(</span><br><span class="line">    array,</span><br><span class="line">    escapedPrefix,</span><br><span class="line">    func,</span><br><span class="line">    context,</span><br><span class="line">  );</span><br><span class="line">  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);</span><br><span class="line">  <span class="comment">// 释放对象</span></span><br><span class="line">  releaseTraverseContext(traverseContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getPooledTraverseContext-与-releaseTraverseContext"><a href="#getPooledTraverseContext-与-releaseTraverseContext" class="headerlink" title="getPooledTraverseContext 与 releaseTraverseContext"></a>getPooledTraverseContext 与 releaseTraverseContext</h4><p>第二步，处理key的暂时不用管。最终通过 <code>getPooledTraverseContext</code> 到对象池里取一个对象，给 <code>traverseAllChildren</code> 进行处理，结束的时候通过 <code>releaseTraverseContext</code> reset所有属性放回去，做到复用，避免了一次性创建大量对象和释放对象消耗性能造成的内存抖动。</p>
<blockquote>
<p>getPooledTraverseContext  用来取。<br>releaseTraverseContext 用来清空后放回</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 维护一个大小为 10 的对象重用池</span></span><br><span class="line"><span class="keyword">const</span> POOL_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> traverseContextPool = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPooledTraverseContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  mapResult,</span></span></span><br><span class="line"><span class="function"><span class="params">  keyPrefix,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapContext,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (traverseContextPool.length) &#123; <span class="comment">// 如果当前对象池内有可用对象，就从队尾pop一个初始化后返回</span></span><br><span class="line">    <span class="keyword">const</span> traverseContext = traverseContextPool.pop();</span><br><span class="line">    traverseContext.result = mapResult;</span><br><span class="line">    traverseContext.keyPrefix = keyPrefix;</span><br><span class="line">    traverseContext.func = mapFunction;</span><br><span class="line">    traverseContext.context = mapContext;</span><br><span class="line">    traverseContext.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> traverseContext;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则返回一个新的对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      result: mapResult,</span><br><span class="line">      keyPrefix: keyPrefix,</span><br><span class="line">      func: mapFunction,</span><br><span class="line">      context: mapContext,</span><br><span class="line">      count: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">releaseTraverseContext</span>(<span class="params">traverseContext</span>) </span>&#123;</span><br><span class="line">  traverseContext.result = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.keyPrefix = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.func = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.context = <span class="literal">null</span>;</span><br><span class="line">  traverseContext.count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (traverseContextPool.length &lt; POOL_SIZE) &#123; <span class="comment">// 如果对象池内没满，就放到对象池内，等待复用</span></span><br><span class="line">    traverseContextPool.push(traverseContext);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="traverseAllChildren-traverseAllChildrenImpl"><a href="#traverseAllChildren-traverseAllChildrenImpl" class="headerlink" title="traverseAllChildren/traverseAllChildrenImpl"></a>traverseAllChildren/traverseAllChildrenImpl</h4><p>第三步，最重要的一步，在取出一个待复用对象后，<code>traverseAllChildren</code> 判断为null就没必要处理了。直接 return。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildren</span>(<span class="params">children, callback, traverseContext</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> traverseAllChildrenImpl(children, <span class="string">''</span>, callback, traverseContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildrenImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children, <span class="regexp">//</span> children</span></span></span><br><span class="line"><span class="function"><span class="params">  nameSoFar, <span class="regexp">//</span> 父级 key</span></span></span><br><span class="line"><span class="function"><span class="params">  callback, <span class="regexp">//</span> 如果是可渲染节点</span></span></span><br><span class="line"><span class="function"><span class="params">  traverseContext, <span class="regexp">//</span> 对象池复用对象</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> children;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'undefined'</span> || type === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    <span class="comment">// 以上都被认为是null。</span></span><br><span class="line">    children = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是可渲染的节点则为true，表示能调用callback</span></span><br><span class="line">  <span class="keyword">let</span> invokeCallback = <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (children === <span class="literal">null</span>) &#123;</span><br><span class="line">    invokeCallback = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">        invokeCallback = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">        <span class="keyword">switch</span> (children.$$<span class="keyword">typeof</span>) &#123;</span><br><span class="line">          <span class="keyword">case</span> REACT_ELEMENT_TYPE: <span class="comment">// React元素 或者是 Portals</span></span><br><span class="line">          <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">            invokeCallback = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (invokeCallback) &#123; <span class="comment">// 可渲染节点，直接调用回调</span></span><br><span class="line">    callback( <span class="comment">// 调用 mapSingleChildIntoContext</span></span><br><span class="line">      traverseContext,</span><br><span class="line">      children,</span><br><span class="line">      nameSoFar === <span class="string">''</span> ? SEPARATOR + getComponentKey(children, <span class="number">0</span>) : nameSoFar,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line">  <span class="keyword">let</span> nextName;</span><br><span class="line">  <span class="keyword">let</span> subtreeCount = <span class="number">0</span>; <span class="comment">//在当前子树中找到的子级的层级数。</span></span><br><span class="line">  <span class="keyword">const</span> nextNamePrefix = nameSoFar === <span class="string">''</span> ? SEPARATOR : nameSoFar + SUBSEPARATOR;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123; <span class="comment">// 如果children是数组，则递归处理</span></span><br><span class="line">  <span class="comment">// 例如 React.Children.map(this.props.children, c =&gt; [[c, c]])</span></span><br><span class="line">  <span class="comment">// c =&gt; [[c, c]] 会被摊平为 [c, c, c, c]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">      child = children[i];</span><br><span class="line">      nextName = nextNamePrefix + getComponentKey(child, i); <span class="comment">// 在每一层不断用“：”分隔拼接key</span></span><br><span class="line">      subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">        child,</span><br><span class="line">        nextName,</span><br><span class="line">        callback,</span><br><span class="line">        traverseContext,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是对象的话通过 obj[Symbol.iterator] 取迭代器</span></span><br><span class="line">    <span class="keyword">const</span> iteratorFn = getIteratorFn(children);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> iteratorFn === <span class="string">'function'</span>) &#123; <span class="comment">// 如果是迭代器是函数就拿到结果</span></span><br><span class="line">      <span class="keyword">const</span> iterator = iteratorFn.call(children);</span><br><span class="line">      <span class="keyword">let</span> step;</span><br><span class="line">      <span class="keyword">let</span> ii = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (!(step = iterator.next()).done) &#123; <span class="comment">// 继续递归处理</span></span><br><span class="line">        child = step.value;</span><br><span class="line">        nextName = nextNamePrefix + getComponentKey(child, ii++);</span><br><span class="line">        subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">          child,</span><br><span class="line">          nextName,</span><br><span class="line">          callback,</span><br><span class="line">          traverseContext,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'object'</span>) &#123; <span class="comment">// 如果迭代器是普通对象也就无法迭代</span></span><br><span class="line">      <span class="keyword">let</span> addendum = <span class="string">''</span>;</span><br><span class="line">      <span class="keyword">const</span> childrenString = <span class="string">''</span> + children;</span><br><span class="line">      invariant(</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="string">'Objects are not valid as a React child (found: %s).%s'</span>,</span><br><span class="line">        childrenString === <span class="string">'[object Object]'</span></span><br><span class="line">          ? <span class="string">'object with keys &#123;'</span> + <span class="built_in">Object</span>.keys(children).join(<span class="string">', '</span>) + <span class="string">'&#125;'</span></span><br><span class="line">          : childrenString,</span><br><span class="line">        addendum,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> subtreeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">&#123; children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(React.Children.map(children, c =&gt; [[[[c, c]]]]));</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    children</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> Children = <span class="function">(<span class="params">&#123; msg &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;span&gt;</span><br><span class="line">    &#123; msg &#125;</span><br><span class="line">  &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>

<p><img src="https://static.yuanziwen.cn/blog/react-source-code/1.jpg_plain" alt="alt"></p>
<p>上面函数的核心作用就是通过把传入的 children 数组通过遍历摊平成单个节点，其中迭代的所有callback都是 <code>mapSingleChildIntoContext</code>。</p>
<h4 id="mapSingleChildIntoContext"><a href="#mapSingleChildIntoContext" class="headerlink" title="mapSingleChildIntoContext"></a>mapSingleChildIntoContext</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bookKeeping getPooledTraverseContext 内从复用对象池取出来的 traverseContext</span></span><br><span class="line"><span class="comment">// child 传入的节点</span></span><br><span class="line"><span class="comment">// childKey 节点的 key</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapSingleChildIntoContext</span>(<span class="params">bookKeeping, child, childKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;result, keyPrefix, func, context&#125; = bookKeeping;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// func === React.Children.map(props.children, c =&gt; c) 的 c =&gt; c 函数</span></span><br><span class="line">  <span class="keyword">let</span> mappedChild = func.call(context, child, bookKeeping.count++);</span><br><span class="line">  <span class="comment">// 如果func返回值设定为数组 React.Children.map(this.props.children, c =&gt; [c, c])</span></span><br><span class="line">  <span class="comment">// 表示每个元素将被返回两次。假如children为 c1，c2，那么最后返回的应该是c1,c1,c2,c2</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(mappedChild)) &#123;</span><br><span class="line">    <span class="comment">// 是数组的话，就再调用 mapIntoWithKeyPrefixInternal</span></span><br><span class="line">    <span class="comment">// 和 mapChildren 调用它的流程一样。递归将其铺平</span></span><br><span class="line">    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c =&gt; c);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedChild != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是不为null并且是有效的 Element</span></span><br><span class="line">    <span class="keyword">if</span> (isValidElement(mappedChild)) &#123;</span><br><span class="line">      <span class="comment">// 克隆 Element &amp;&amp; 替换掉key 推入result</span></span><br><span class="line">      mappedChild = cloneAndReplaceKey(</span><br><span class="line">        mappedChild,</span><br><span class="line">        keyPrefix + (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key)</span><br><span class="line">            ? escapeUserProvidedKey(mappedChild.key) + <span class="string">'/'</span> : <span class="string">''</span>) + childKey,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(mappedChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的逻辑又回到了 <code>mapIntoWithKeyPrefixInternal</code> ，通过递归调用使返回的数组结果展开铺平。</p>
<h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p>大概整体流程</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`mapChildren`</span> ===================&gt; <span class="string">`mapIntoWithKeyPrefixInternal`</span> ==================&gt; <span class="string">`getPooledTraverseContext`</span>(复用对象池)</span><br><span class="line">                                                  /\                                                ||</span><br><span class="line">                                                 /||\                                               ||</span><br><span class="line">                                                  ||                                                ||</span><br><span class="line">                                                  ||                                               \||<span class="regexp">/</span></span><br><span class="line"><span class="regexp">                                                  ||                                                \/</span></span><br><span class="line"><span class="regexp">                                                  ||Yes                                 `traverseAllChildren`(遍历children树)</span></span><br><span class="line"><span class="regexp">                                                  ||                                                ||</span></span><br><span class="line"><span class="regexp">                                                  ||                                                ||</span></span><br><span class="line"><span class="regexp">                                                  ||                                               \||/</span></span><br><span class="line">                                                  ||                                                \/</span><br><span class="line">                                     No           ||                                        (children是数组又会重新递归执行)</span><br><span class="line"><span class="string">`releaseTraverseContext`</span>(释放对象池)&lt;=====<span class="string">`mapSingleChildIntoContext`</span>(铺平result)&lt;=============<span class="string">`traverseAllChildrenImpl`</span></span><br></pre></td></tr></table></figure>

<h3 id="Children-forEach"><a href="#Children-forEach" class="headerlink" title="Children.forEach"></a>Children.forEach</h3><p>相比 <code>map</code>，<code>forEachChildren</code> 则简单的多，因为不用去返回一个新的结果，只需要对children做遍历，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEachChildren</span>(<span class="params">children, forEachFunc, forEachContext</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> traverseContext = getPooledTraverseContext(</span><br><span class="line">    <span class="literal">null</span>, <span class="comment">// 不需要返回数组，所以result为null</span></span><br><span class="line">    <span class="literal">null</span>, <span class="comment">// key也不需要</span></span><br><span class="line">    forEachFunc,</span><br><span class="line">    forEachContext,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 第二个参数 forEachSingleChild 简单调用了 forEachFunc</span></span><br><span class="line">  traverseAllChildren(children, forEachSingleChild, traverseContext);</span><br><span class="line">  releaseTraverseContext(traverseContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEachSingleChild</span>(<span class="params">bookKeeping, child, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;func, context&#125; = bookKeeping;</span><br><span class="line">  func.call(context, child, bookKeeping.count++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Children-count"><a href="#Children-count" class="headerlink" title="Children.count"></a>Children.count</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countChildren</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> traverseAllChildren(children, () =&gt; <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用来计算children的个数，平时用的较少。和前面2个方法的行为差不多，预置的callback也不会进行任何处理。最终返回当前children的子元素，并不会向下递归查找。</p>
<h3 id="Children-toArray"><a href="#Children-toArray" class="headerlink" title="Children.toArray"></a>Children.toArray</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  mapIntoWithKeyPrefixInternal(children, result, <span class="literal">null</span>, child =&gt; child);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用来将<code>children</code>转化成普通的数组，原理和 mapChildren 一样，可以用来将传入的<code>children</code>重新进行排序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   render () &#123;</span><br><span class="line">     <span class="keyword">const</span> children = React.Children.toArray(<span class="keyword">this</span>.props.children);</span><br><span class="line">     <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;children.sort((a,b)=&gt;a-b).join('-')&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &lt;Sort&gt;</span><br><span class="line">  &#123;<span class="number">2</span>&#125;&#123;<span class="number">5</span>&#125;&#123;<span class="number">8</span>&#125;&#123;<span class="number">4</span>&#125;&#123;<span class="number">9</span>&#125;</span><br><span class="line"> &lt;<span class="regexp">/Sort&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/  view</span></span><br><span class="line"><span class="regexp">2-4-5-8-9</span></span><br></pre></td></tr></table></figure>

<h3 id="Children-only"><a href="#Children-only" class="headerlink" title="Children.only"></a>Children.only</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onlyChild</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  invariant(</span><br><span class="line">    isValidElement(children),</span><br><span class="line">    <span class="string">'React.Children.only expected to receive a single React element child.'</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>校验children是否为ReactElement，是则返回，否则报错。可以用来制做一个只接受一个 <code>children</code> 的 <code>&lt;Single&gt;</code> 组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> React.Children.only(<span class="keyword">this</span>.props.children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;Single&gt;</span><br><span class="line">        &lt;div&gt;first&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;second&lt;/</span>div&gt; &#123;<span class="comment">/* error */</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/Single&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="ReactElement"><a href="#ReactElement" class="headerlink" title="ReactElement"></a>ReactElement</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  createElement,</span><br><span class="line">  createFactory,</span><br><span class="line">  cloneElement,</span><br><span class="line">  isValidElement,</span><br><span class="line">  jsx,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./ReactElement'</span>;</span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  createElement: __DEV__ ? createElementWithValidation : createElement,</span><br><span class="line">  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,</span><br><span class="line">  createFactory: __DEV__ ? createFactoryWithValidation : createFactory,</span><br><span class="line">  isValidElement: isValidElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开发环境下会自动validator，切到<code>packages/react/src/ReactElement.js</code>，大纲如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hasValidRef ------------------------------- 判断是否有合理的ref</span><br><span class="line">hasValidKey ------------------------------- 判断是否有合理的key</span><br><span class="line">defineRefPropWarningGetter ---------------- 锁定props.ref</span><br><span class="line">defineKeyPropWarningGetter ---------------- 锁定props.key</span><br><span class="line">ReactElement ------------------------------ 转化ReactElement</span><br><span class="line">jsx --------------------------------------- 使用jsx方式创建Element</span><br><span class="line">jsxDEV ------------------------------------ 使用jsx方式创建Element(DEV)</span><br><span class="line">createElement ----------------------------- 创建并返回指定类型的ReactElement</span><br><span class="line">createFactory ----------------------------- 工厂模式createElement构造器</span><br><span class="line">cloneAndReplaceKey ------------------------ 替换新key</span><br><span class="line">cloneElement ------------------------------ 克隆Element</span><br><span class="line">isValidElement ---------------------------- 判定是否ReactElement</span><br></pre></td></tr></table></figure>

<h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><p>这个方法大家耳熟能详。React用的最多的方法，没有之一。它负责React内所有元素节点的创建及初始化。</p>
<p>该方法接受三个参数 <code>type, config, children</code> ,<code>type</code> 是标签或者组件的名称，div/span/ul，对应的自定义Component首字母一定是大写。<code>config</code> 则包含所有的属性配置，<code>children</code> 代表子节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> propName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> ref = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasValidRef(config)) &#123;<span class="comment">// 查找config内是否存在合理的ref</span></span><br><span class="line">      ref = config.ref;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasValidKey(config)) &#123;<span class="comment">// 查找config内是否存在合理的key</span></span><br><span class="line">      key = <span class="string">''</span> + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self = config.__self === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__self;</span><br><span class="line">    source = config.__source === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__source;</span><br><span class="line">    <span class="comment">// 将剩余属性添加到新的props对象中</span></span><br><span class="line">    <span class="comment">// 这也就是为什么&lt;Component key=&#123;Math.random()&#125;/&gt;子组件中为什么找不到key/ref/__self/__source属性的原因</span></span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// 忽略原型链上的属性，并且抽离key/ref/__self/__source属性</span></span><br><span class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        props[propName] = config[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// children参数可以不止一个，除去前两个参数，其他的都是children</span></span><br><span class="line">  <span class="keyword">const</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对children做格式处理。一个为对象，多个则为Array</span></span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> childArray = <span class="built_in">Array</span>(childrenLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Object</span>.freeze) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.freeze(childArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析defaultProps，定义组件的默认Props属性</span></span><br><span class="line">  <span class="comment">// Com.defaultProps = &#123; msg:'default' &#125;</span></span><br><span class="line">  <span class="keyword">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">    <span class="keyword">const</span> defaultProps = type.defaultProps;</span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (props[propName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在开发环境下，锁定props上 key与 ref 的getter，不予获取</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key || ref) &#123;</span><br><span class="line">      <span class="keyword">const</span> displayName = <span class="keyword">typeof</span> type === <span class="string">'function'</span></span><br><span class="line">          ? type.displayName || type.name || <span class="string">'Unknown'</span></span><br><span class="line">          : type;</span><br><span class="line">      <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        defineKeyPropWarningGetter(props, displayName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">        defineRefPropWarningGetter(props, displayName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后转化成React元素</span></span><br><span class="line">  <span class="keyword">return</span> ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner.current, <span class="comment">// 创建React元素的组件</span></span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactCurrentOwner = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@type <span class="type">&#123;ReactComponent&#125;</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  current: (<span class="literal">null</span>: <span class="literal">null</span> | Fiber),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>createElement</code> 仅仅起到为<code>ReactElement</code>加工前过滤属性的作用。</p>
<h3 id="create-ReactElement"><a href="#create-ReactElement" class="headerlink" title="create ReactElement"></a>create ReactElement</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactElement = <span class="function"><span class="keyword">function</span>(<span class="params">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// $$typeof将其标识为一个React元素</span></span><br><span class="line">    $$<span class="keyword">typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReactElement的内置属性</span></span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建此元素的组件。</span></span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//为了利于测试，在开发环境下忽略这些属性（不可枚举），并且冻结props与element</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    element._store = &#123;&#125;;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(element._store, <span class="string">'validated'</span>, &#123;</span><br><span class="line">      configurable: <span class="literal">false</span>,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      value: <span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// self and source are DEV only properties.</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(element, <span class="string">'_self'</span>, &#123;</span><br><span class="line">      configurable: <span class="literal">false</span>,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      writable: <span class="literal">false</span>,</span><br><span class="line">      value: self,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(element, <span class="string">'_source'</span>, &#123;</span><br><span class="line">      configurable: <span class="literal">false</span>,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      writable: <span class="literal">false</span>,</span><br><span class="line">      value: source,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.freeze) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.freeze(element.props);</span><br><span class="line">      <span class="built_in">Object</span>.freeze(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ReactElement</code> 将其属性做二次处理，等待被渲染成DOM，在平常开发我们通过<code>console.log</code>打印出自定义Component 属性与<code>element</code>一致。</p>
<p><img src="https://static.yuanziwen.cn/blog/react-source-code/2.jpg_plain" alt="alt"></p>
<h3 id="createFactory"><a href="#createFactory" class="headerlink" title="createFactory"></a>createFactory</h3><p>工厂模式的 <code>createElement</code>，通过预置 <code>type</code> 参数创建指定类型的节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> child1 = React.createElement(<span class="string">'li'</span>, <span class="literal">null</span>, <span class="string">'First Text Content'</span>);</span><br><span class="line"><span class="keyword">var</span> child2 = React.createElement(<span class="string">'li'</span>, <span class="literal">null</span>, <span class="string">'Second Text Content'</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> factory = React.createFactory(<span class="string">"li"</span>);</span><br><span class="line"><span class="keyword">var</span> child1 = factory(<span class="literal">null</span>, <span class="string">'First Text Content'</span>);</span><br><span class="line"><span class="keyword">var</span> child2 = factory(<span class="literal">null</span>, <span class="string">'Second Text Content'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> root  = React.createElement(<span class="string">'ul'</span>, &#123;<span class="attr">className</span>: <span class="string">'list'</span>&#125;, child1, child2);</span><br><span class="line">ReactDOM.render(root,<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createFactory</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过bind预置type参数返回新的函数</span></span><br><span class="line">  <span class="keyword">const</span> factory = createElement.bind(<span class="literal">null</span>, type);</span><br><span class="line">  <span class="comment">// Expose the type on the factory and the prototype so that it can be easily accessed on elements. E.g. `&lt;Foo /&gt;.type === Foo`.</span></span><br><span class="line">  <span class="comment">// This should not be named `constructor` since this may not be the function that created the element, and it may not even be a constructor.</span></span><br><span class="line">  <span class="comment">// Legacy hook: remove it</span></span><br><span class="line">  factory.type = type;</span><br><span class="line">  <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cloneElement"><a href="#cloneElement" class="headerlink" title="cloneElement"></a>cloneElement</h3><p>通过传入新的element与props及children，得到clone后的一个新元素。<code>element</code> 为cloneElement，<code>config</code> 是 newProps，可以重新定义 <code>key</code> 和 <code>ref</code>，<code>children</code> 子节点。<br>整体方法与createElement大致相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cloneElement</span>(<span class="params">element, config, children</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断有效的ReactElement</span></span><br><span class="line">  invariant(</span><br><span class="line">    !(element === <span class="literal">null</span> || element === <span class="literal">undefined</span>),</span><br><span class="line">    <span class="string">'React.cloneElement(...): The argument must be a React element, but you passed %s.'</span>,</span><br><span class="line">    element,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> propName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy原始 props</span></span><br><span class="line">  <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, element.props);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提取保留key &amp; ref</span></span><br><span class="line">  <span class="keyword">let</span> key = element.key;</span><br><span class="line">  <span class="keyword">let</span> ref = element.ref;</span><br><span class="line">  <span class="comment">// 为了追踪与定位，继承被clone的Element这三个属性</span></span><br><span class="line">  <span class="keyword">const</span> self = element._self;</span><br><span class="line">  <span class="keyword">const</span> source = element._source;</span><br><span class="line">  <span class="keyword">let</span> owner = element._owner;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里的处理和createElement差不多</span></span><br><span class="line">    <span class="comment">// unique ，ref 和 key 可以自定义覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (hasValidRef(config)) &#123;</span><br><span class="line">      ref = config.ref;</span><br><span class="line">      owner = ReactCurrentOwner.current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasValidKey(config)) &#123;</span><br><span class="line">      key = <span class="string">''</span> + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他属性覆盖current props</span></span><br><span class="line">    <span class="keyword">let</span> defaultProps;</span><br><span class="line">    <span class="keyword">if</span> (element.type &amp;&amp; element.type.defaultProps) &#123;</span><br><span class="line">      defaultProps = element.type.defaultProps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (config[propName] === <span class="literal">undefined</span> &amp;&amp; defaultProps !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="comment">// Resolve default props</span></span><br><span class="line">          props[propName] = defaultProps[propName];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          props[propName] = config[propName];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 剩余的与 createElement 一样</span></span><br><span class="line">  <span class="keyword">const</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> childArray = <span class="built_in">Array</span>(childrenLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ReactElement(element.type, key, ref, self, source, owner, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cloneAndReplaceKey"><a href="#cloneAndReplaceKey" class="headerlink" title="cloneAndReplaceKey"></a>cloneAndReplaceKey</h3><p>顾名思义，与 <code>cloneElement</code> 名字上虽然差不多，但实际返回的是通过ReactElement传入newKey重新创建的旧Element。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cloneAndReplaceKey</span>(<span class="params">oldElement, newKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newElement = ReactElement(</span><br><span class="line">    oldElement.type,</span><br><span class="line">    newKey,</span><br><span class="line">    oldElement.ref,</span><br><span class="line">    oldElement._self,</span><br><span class="line">    oldElement._source,</span><br><span class="line">    oldElement._owner,</span><br><span class="line">    oldElement.props,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isValidElement"><a href="#isValidElement" class="headerlink" title="isValidElement"></a>isValidElement</h3><p>也很简单，通过判断 <code>$$typeof</code> 是否为内置的ReactElement类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isValidElement</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="keyword">typeof</span> object === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">    object !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    object.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jsx-jsxDEV"><a href="#jsx-jsxDEV" class="headerlink" title="jsx/jsxDEV"></a>jsx/jsxDEV</h3><p>没怎么使用过这个API，猜测应该是通过 <code>react-dom</code> 转化后使用的创建语法。</p>
<p>从代码逻辑上看，与 <code>createElement</code> 大致形同，<code>jsxDEV</code> 比 <code>jsx</code> 多了两个能自定义的属性，<code>source</code> 和 <code>self</code>，按照代码注释，是为了防止出现 <code>&lt;div key=&quot;Hi&quot; {...props} /&gt;</code> 情况中 <code>key</code> 比 <code>props</code> 先定义，导致被覆盖的情况。将对<code>&lt;div {...props} key=&quot;Hi&quot; /&gt;</code> 之外的所有情况统一使用 <code>jsxDEV</code> 来强行赋值 key 与 ref。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">jsxDEV</span>(<span class="params">type, config, maybeKey, source, self</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> propName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reserved names are extracted</span></span><br><span class="line">  <span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> ref = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Currently, key can be spread in as a prop. This causes a potential issue if key is also explicitly declared (ie. &lt;div &#123;...props&#125; key="Hi" /&gt; or &lt;div key="Hi" &#123;...props&#125; /&gt; ). We want to deprecate key spread,</span></span><br><span class="line">  <span class="comment">// but as an intermediary step, we will use jsxDEV for everything except &lt;div &#123;...props&#125; key="Hi" /&gt;, because we aren't currently able to tell if key is explicitly declared to be undefined or not.</span></span><br><span class="line">  <span class="keyword">if</span> (maybeKey !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    key = <span class="string">''</span> + maybeKey;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasValidKey(config)) &#123;</span><br><span class="line">    key = <span class="string">''</span> + config.key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasValidRef(config)) &#123;</span><br><span class="line">    ref = config.ref;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remaining properties are added to a new props object</span></span><br><span class="line">  <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">      !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">    ) &#123;</span><br><span class="line">      props[propName] = config[propName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Resolve default props</span></span><br><span class="line">  <span class="keyword">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">    <span class="keyword">const</span> defaultProps = type.defaultProps;</span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (props[propName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (key || ref) &#123;</span><br><span class="line">    <span class="keyword">const</span> displayName =</span><br><span class="line">      <span class="keyword">typeof</span> type === <span class="string">'function'</span></span><br><span class="line">        ? type.displayName || type.name || <span class="string">'Unknown'</span></span><br><span class="line">        : type;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">      defineKeyPropWarningGetter(props, displayName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">      defineRefPropWarningGetter(props, displayName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="defineRefPropWarningGetter-defineKeyPropWarningGetter"><a href="#defineRefPropWarningGetter-defineKeyPropWarningGetter" class="headerlink" title="defineRefPropWarningGetter/defineKeyPropWarningGetter"></a>defineRefPropWarningGetter/defineKeyPropWarningGetter</h3><p><code>key</code> 是用来优化React渲染速度的，而 <code>ref</code> 是用来获取到React渲染后的真实DOM节点。正常情况下应该将这两个属性置之世外，仿佛这两个属性都应该是React本身的API。所以这两个方法就是用来禁止获取和设置的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> specialPropKeyWarningShown, specialPropRefWarningShown;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineKeyPropWarningGetter</span>(<span class="params">props, displayName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> warnAboutAccessingKey = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!specialPropKeyWarningShown) &#123; <span class="comment">// 只会读取一次</span></span><br><span class="line">      specialPropKeyWarningShown = <span class="literal">true</span>;</span><br><span class="line">      warningWithoutStack(</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="string">'%s: `key` is not a prop. Trying to access it will result '</span> +</span><br><span class="line">          <span class="string">'in `undefined` being returned. If you need to access the same '</span> +</span><br><span class="line">          <span class="string">'value within the child component, you should pass it as a different '</span> +</span><br><span class="line">          <span class="string">'prop. (https://fb.me/react-special-props)'</span>,</span><br><span class="line">        displayName,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  warnAboutAccessingKey.isReactWarning = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(props, <span class="string">'key'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: warnAboutAccessingKey,</span><br><span class="line">    configurable: true,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在组件内尝试 <code>console.log(props.key)</code> 的时候，就会发现报错。</p>
<p><img src="https://static.yuanziwen.cn/blog/react-source-code/3.jpg_plain" alt="alt"></p>
<p>两个方法逻辑一模一样，就不写粘贴两遍了。</p>
<h3 id="hasValidRef-hasValidKey"><a href="#hasValidRef-hasValidKey" class="headerlink" title="hasValidRef/hasValidKey"></a>hasValidRef/hasValidKey</h3><p>这两个方法差不多，在开发模式下多了一个校验，通过 <code>Object.prototype.hasOwnProperty</code> 检查当前对象属性上是否存在 <code>ref/key</code>，并获取其访问器函数 <code>get</code>，如果事先被<code>defineKeyPropWarningGetter/defineRefPropWarningGetter</code> 锁定则 <code>getter.isReactWarning</code> 就必然为 <code>true</code>(注意锁定方法调用的时机)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasValidRef</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasOwnProperty.call(config, <span class="string">'ref'</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> getter = <span class="built_in">Object</span>.getOwnPropertyDescriptor(config, <span class="string">'ref'</span>).get;</span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; getter.isReactWarning) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config.ref !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="blog.yuanziwen.cn">Seven</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="blog.yuanziwen.cn/2019/09/24/React传-1/">blog.yuanziwen.cn/2019/09/24/React传-1/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/React/">React</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2019/10/06/重学原型与继承/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">重学原型与继承</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2019/09/13/制定专属自己的-React-Hooks/">
        <span class="next-text nav-default">制定专属自己的 React Hooks</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'cxeaTV5BFDCxPmxoCcG9QPxf-gzGzoHsz',
        appKey: 's577OrPG5sB4Szom6mvHuI1X',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info: guest,
        pageSize:'10' || 10,
    });
  </script>

<footer id="footer" class="footer"><div class="social-links"><a href="mailto:yuanziwen7489757@gmail.com" class="iconfont icon-email" title="email"></a>
          <a href="https://juejin.im/user/59aa31a06fb9a02485103ddf" class="iconfont juejin" title="掘金"><div class="img"></div></a>
        <a href="https://github.com/yzw7489757" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <!--<span class="division">|</span>
  <span class="theme-info">
    footer.theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>-->
  <span class="power-by">
   <a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备18011257号-1</a>
  </span>
  <span class="copyright-year">&copy;2017 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Seven</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
<script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js?t=1593502174043')
    .then(function () {console.log('ServiceWorker Register Successfully.')})
    .catch(function (e) {console.error(e)});
}
</script></body>
</html>
