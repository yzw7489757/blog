<!DOCTYPE html>
<html lang="zh-Hans">
  <head><meta name="generator" content="Hexo 3.9.0"><link rel="manifest" href="/manifest.json"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="制定专属自己的 React Hooks"><meta name="keywords" content="Seven YuanZiWen"><link rel="alternate" href="/atom.xml" title="Seven Blog"><link rel="shortcut icon" type="image/x-icon" href="https://static.yuanziwen.cn/blog/favicon.ico?v=2.11.0">
<link rel="canonical" href="blog.yuanziwen.cn/2019/09/13/制定专属自己的-React-Hooks/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1e4ffaffd9b2bc832b39e2b866a92c7b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>制定专属自己的 React Hooks - Seven Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Seven Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Record
          </li>
      </a><a href="/logs/">
        <li class="mobile-menu-item">Log
          </li>
      </a><a href="/music/">
        <li class="mobile-menu-item">Music
          </li>
      </a><a href="/photo/">
        <li class="mobile-menu-item">Album
          </li>
      </a><a href="/book/">
        <li class="mobile-menu-item">Book
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Seven Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Record
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/logs/">
            Log
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/music/">
            Music
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/photo/">
            Album
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/book/">
            Book
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">制定专属自己的 React Hooks
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-09-13
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#useState"><span class="toc-text">useState</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-text">我们先看下官方的api</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指向问题"><span class="toc-text">指向问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#根作用域顺序声明"><span class="toc-text">根作用域顺序声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useEffect"><span class="toc-text">useEffect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖于闭包"><span class="toc-text">依赖于闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于依赖项不要对React撒谎"><span class="toc-text">关于依赖项不要对React撒谎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后话"><span class="toc-text">后话</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useLayoutEffect"><span class="toc-text">useLayoutEffect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useReducer"><span class="toc-text">useReducer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useContext"><span class="toc-text">useContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useMemo"><span class="toc-text">useMemo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖项"><span class="toc-text">依赖项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useCallback"><span class="toc-text">useCallback</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于memo与callback"><span class="toc-text">关于memo与callback</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useRef"><span class="toc-text">useRef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useImperativeHandle"><span class="toc-text">useImperativeHandle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useDebugValue"><span class="toc-text">useDebugValue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义钩子"><span class="toc-text">自定义钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现-setState-回调"><span class="toc-text">实现 setState 回调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#设置相同值"><span class="toc-text">设置相同值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#回调内再次赋值"><span class="toc-text">回调内再次赋值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useLifeCycles"><span class="toc-text">useLifeCycles</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useRequestAnimationFrame"><span class="toc-text">useRequestAnimationFrame</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usePrevious"><span class="toc-text">usePrevious</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useEventListener"><span class="toc-text">useEventListener</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useDebounce"><span class="toc-text">useDebounce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useThrottle"><span class="toc-text">useThrottle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useImtArray"><span class="toc-text">useImtArray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usePromise"><span class="toc-text">usePromise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useGetter"><span class="toc-text">useGetter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useLockBodyScroll"><span class="toc-text">useLockBodyScroll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useTheme"><span class="toc-text">useTheme</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useInput"><span class="toc-text">useInput</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useDragger"><span class="toc-text">useDragger</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生命周期：从类组件到函数组件的过渡"><span class="toc-text">生命周期：从类组件到函数组件的过渡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#componentDidMount-与-componentWillUnmount"><span class="toc-text">componentDidMount 与 componentWillUnmount</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forceUpdate"><span class="toc-text">forceUpdate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getSnapshotBeforeUpdate"><span class="toc-text">getSnapshotBeforeUpdate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#componentDidUpdate"><span class="toc-text">componentDidUpdate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shouldComponentUpdate"><span class="toc-text">shouldComponentUpdate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后话-1"><span class="toc-text">后话</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更有有意思的Hooks"><span class="toc-text">更有有意思的Hooks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-text">参考文献</span></a></li></ol>
    </div>
  </div><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.2.1/css/hint.min.css"><p>Hooks 是 <code>16.7.0-alpha</code> 新加入的新特性，目的解决状态逻辑复用，使无状态组件拥有了许多状态组件的能力，如自更新能力(useState)、访问ref(useRef)、上下文context(useContext)、更高级的setState(useReducer)及周期方法(useEffect/useLayoutEffect)及缓存(useMemo、useCallback)。其底层实现没有太多变动，整体更接近函数式语法，逻辑内聚，高阶封装这两大特点，让你同时领悟到 Hooks 的强大与优雅。</p>
<a id="more"></a>

<p>如果你已经厌倦写诸如修改网页标题，判断用户离线状态，监听页面大小，用户手机状态(电池、螺旋仪…)，说明你已经不甘心做一个重复劳动的开发者 ，那么自定义hooks非常适合你。只想关注Custom Hooks，<a href="#custom">F 传送</a>!!!!</p>
<p>在阅读本文之前，建议unLearning，也就是忘记你之前学会的“React” ，它已经不是那个“它”了，否则只会给你带来“误导”。</p>
<blockquote>
<p>ps: 为了更好的阅读体验，- 表示删减代码， + 表示新增代码，* 表示修改行</p>
</blockquote>
<p>本文<a href="https://github.com/yzw7489757/like-hooks" target="_blank" rel="noopener">Custom Hooks github</a></p>
<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>看这篇解析之前，我们已经知道自己的水平，岂能像新手一样先看api？<br><strong>当然是要先从源码入手。</strong></p>
<p><img src="https://static.yuanziwen.cn/blog/hooks/1.png_plain" alt="alt"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span>&gt;(<span class="params">initialState: ((</span>) =&gt; <span class="title">S</span>) | <span class="title">S</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WTF ？？？<br><img src="https://static.yuanziwen.cn/blog/hooks/2.png_plain" alt="alt"></p>
<p>回到正题，做人怎么能手高眼低呢？</p>
<p><del>高手，当然是要先从源码入手。</del></p>
<h3><u><b>我们先看下官方的api</b></u></h3>

<p><code>useState</code> 用来定义组件数据变量。传入一个初始值，得到一个数组，前者为值，后者是一个dispatch函数，通过dispatch函数可以去更新该值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [value, updateVal] = useState(<span class="number">0</span>)</span><br><span class="line">value <span class="comment">// 0</span></span><br><span class="line">updateVal(<span class="number">1</span>)</span><br><span class="line">value <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>也可以传入一个同步函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ⚠️ Math.random() 每次 render 都会调用Math.random()</span></span><br><span class="line"><span class="keyword">const</span> [value, updateVal] = useState(<span class="built_in">Math</span>.random());</span><br><span class="line"><span class="comment">// 只会执行一次</span></span><br><span class="line"><span class="keyword">const</span> [value, updateVal] = useState(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random());</span><br></pre></td></tr></table></figure>

<p>useState仅在函数组件第一次执行初始化。在组件存在期间始终返回最新的值。不会再次去执行初始化函数。看到这，是不是觉得和闭包一样？</p>
<h3 id="指向问题"><a href="#指向问题" class="headerlink" title="指向问题"></a>指向问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Index.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'classComponent'</span>, <span class="keyword">this</span>.state.value), <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: <span class="number">5</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, updateVal] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'FunctionComponent'</span>, value), <span class="number">1000</span>);</span><br><span class="line">    updateVal(<span class="number">5</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Index /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// classComponent 5</span></span><br><span class="line"><span class="comment">// FunctionComponent 0</span></span><br></pre></td></tr></table></figure>

<p>如果你还不了解 <code>useEffect</code>，可以暂时把上面 <code>useEffect</code> 暂时看成是 <code>componentWillMount</code> 。目的是一秒钟后打印当前的value值。</p>
<p>前者通过 <code>this</code> 可以访问到最新的值，而函数组件由于闭包的原因，打印的时候访问的还是更新前的值。这种情况可以通过useRef解决，如果你还不了解<a href="#useRef">useRef</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = useRef(<span class="literal">null</span>);</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(num.current), <span class="number">1000</span>); <span class="comment">// 2</span></span><br><span class="line">    updateVal(<span class="function">(<span class="params">pre</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newPre = pre * <span class="number">2</span>;</span><br><span class="line">      num.current = newPre;</span><br><span class="line">      <span class="keyword">return</span> newPre;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<p>但是<code>updateVal</code> 执行的时机无法保证（毕竟在整个周期的最后）；还有个比较low的方案 —— 就是 <code>useState</code> 的 <code>dispatch</code> 函数 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> updateVal(<span class="function">(<span class="params">pre</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'FunctionComponent'</span>, pre);</span><br><span class="line">      <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;), <span class="number">1000</span>);</span><br><span class="line">    updateVal(<span class="number">5</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"><span class="comment">// classComponent 5</span></span><br><span class="line"><span class="comment">// FunctionComponent 5</span></span><br></pre></td></tr></table></figure>

<p>效果是能实现，但是由于 dispatch set 新值会触发一次 re-render。 所以这个方案不建议使用。后面会有封装的hooks达到目的。</p>
<h3 id="根作用域顺序声明"><a href="#根作用域顺序声明" class="headerlink" title="根作用域顺序声明"></a>根作用域顺序声明</h3><blockquote>
<p><strong>不能嵌套在 <code>if</code> 或者 <code>for</code> 中声明</strong></p>
</blockquote>
<p>之前看过不少hooks的文章，都说hooks是以数组的形式存储的,所以才会出现指向问题。但在后来实践发现并非如此（连官方也这么误导我）.</p>
<blockquote>
<p>React 如何将 Hook 调用与组件相关联？<br><br>React 跟踪当前渲染组件。 由于 Hooks 规则，我们知道 Hook 只能从 React 组件调用（或自定义 Hooks 也只能从 React 组件中调用）。<br>每个组件都有一个 “内存单元” 的内部列表。它们只是 JavaScript 对象，我们可以在其中放置一些数据。当调用 useState() 这样的Hook 时，<u><b>它读取当前单元格(或在第一次呈现时初始化它)，然后将指针移动到下一个单元格。</b></u>这就是多个 useState() 调用各自获取独立本地状态的方式。</p>
</blockquote>
<p>实际上是以一种单向循环链表。类似A.next === B =&gt; B.next === C 。<br><img src="https://static.yuanziwen.cn/blog/hooks/3.png_plain" alt="alt"><br>剖析 <a href="https://juejin.im/post/5bdfc1c4e51d4539f4178e1f#heading-3" target="_blank" rel="noopener">引用</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state1,setState1] = useState(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> [state2,setState2] = useState(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> [state3,setState3] = useState(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>每个<code>FunctionalComponent</code>都会有个对应的Fiber对象，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: WorkTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: null | string,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Instance</span></span><br><span class="line">  <span class="keyword">this</span>.tag = tag;</span><br><span class="line">  <span class="keyword">this</span>.key = key;</span><br><span class="line">  <span class="keyword">this</span>.elementType = <span class="literal">null</span>;  <span class="comment">// ReactElement[$$typeof]</span></span><br><span class="line">  <span class="keyword">this</span>.type = <span class="literal">null</span>;         <span class="comment">// ReactElement.type</span></span><br><span class="line">  <span class="keyword">this</span>.stateNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...others</span></span><br><span class="line">  <span class="keyword">this</span>.ref = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// ...others</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其中调用的<code>useState</code> 会有个 <code>Hook</code> 对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Hook = &#123;</span><br><span class="line">  memoizedState: <span class="built_in">any</span>,</span><br><span class="line"></span><br><span class="line">  baseState: <span class="built_in">any</span>,</span><br><span class="line">  baseUpdate: Update&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; | <span class="literal">null</span>,</span><br><span class="line">  queue: UpdateQueue&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  next: Hook | <span class="literal">null</span>, <span class="comment">// 指向下一个hook节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其他的问题不用太关注，只需要知道当在第一次执行到<code>useState</code>的时候，会对应 <code>Fiber</code> 对象上的 <code>memoizedState</code>，这个属性原来设计来是用来存储 <code>ClassComponent</code> 的 <code>state</code> 的，因为在 <code>ClassComponent</code> 中 <code>state</code> 是一整个对象，所以可以和<code>memoizedState</code> 一一对应。</p>
<p>但是在 <code>Hooks</code> 中，React并不知道我们调用了几次 <code>useState</code>，所以在保存 state 这件事情上，React 想出了一个比较有意思的方案，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Fiber.memoizedState === hook1</span><br><span class="line">state1 === hook1.memoizedState</span><br><span class="line">hook1.next === hook2</span><br><span class="line">state2 === hook2.memoizedState</span><br><span class="line">hook2.next === hook3</span><br><span class="line">state3 === hook2.memoizedState</span><br></pre></td></tr></table></figure>

<p>每个在 <code>FunctionalComponent</code> 中调用的 <code>useState</code> 都会有一个对应的 <code>Hook</code> 对象，他们按照执行的顺序以类似单向循环链表的数据格式存放在 <code>Fiber.memoizedState</code> 上。</p>
<p>如果出现下面这种逻辑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [status,setStatus] = useState(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">let</span> times = <span class="number">10</span> <span class="comment">// 某次逻辑修改了times</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; times; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> status = useState(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会导致某次 re-render 后，少了某个 hook ，next 指向错误，比如 hook1.next 指向了 hook3 造成数据混乱，无法达到预想效果。</p>
<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>生命周期的阶段性方法，类似setState(state, cb)中的cb，执行时机位于整个更新周期的最后。</p>
<p>话不多少，先上源码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////// useEffect</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">inputs</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useEffect(create, inputs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...省略</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  create: (</span>) =&gt; (<span class="params">(</span>) =&gt; <span class="title">void</span>) | <span class="title">void</span>,</span></span><br><span class="line"><span class="function">  <span class="title">deps</span>: <span class="title">Array</span>&lt;<span class="title">mixed</span>&gt; | <span class="title">void</span> | <span class="title">null</span>,</span></span><br><span class="line"><span class="function">): <span class="title">void</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> mountEffectImpl(</span><br><span class="line">    UpdateEffect | PassiveEffect,</span><br><span class="line">    UnmountPassive | MountPassive,</span><br><span class="line">    create,</span><br><span class="line">    deps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://static.yuanziwen.cn/blog/hooks/4.png_plain" alt="alt"></p>
<p>咳，这个方法可谓是hooks里最重要的一个hooks。如果把<code>useState</code>看成 <code>HTML+CSS</code>，那 <code>useEffect</code> 就是 <code>JS</code>。</p>
<p><code>useEffect(fn, deps?:any[])</code>，<code>fn</code> 执行函数，<code>deps</code> 依赖。与 <code>useState</code> 类似，<code>fn</code> 在初始化时执行一次。而后续执行则依赖于 <code>deps</code> 的变化，如果 re-render 后执行该 effects 发现此次 deps 与上次不同，就会触发执行。</p>
<blockquote>
<p>ps: React 内部使用 <code>Object.is</code> 对 deps 进行浅比较。</p>
</blockquote>
<p>刚开始脱离 classComponent 转而使用 hooks 时曾以为它在 <code>render</code> 前执行，其实不然。</p>
<blockquote>
<p>默认情况下，效果在每次完成渲染后运行</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 仅在初始化时(首次render后)执行</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 每次render后执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>fn</code> 可返回一个清理函数，大多数运用于 <code>addEventListener</code> 与 <code>removeEventListener</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 首次render后执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 组件卸载前执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[]);</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) =&gt; </span>&#123; <span class="comment">/*dst...*/</span> &#125;)()</span><br><span class="line">    <span class="comment">// 每次render后执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 从第二次开始，先运行此清理函数，再执行fn</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>清理函数的执行时机可以理解为如果该 Effect 句柄执行过，则下次优先执行清理函数，以防止内存泄漏，最后一次执行时机在组件卸载后。</p>
<p>如果非要形容对应哪个生命周期，我更觉得像 <code>componentDidUpdate</code>。</p>
<blockquote>
<p>不要在 useEffect 中操作DOM。比如使用 requestAnimationFrame 添加几万个节点。会有意想不到的惊喜。</p>
</blockquote>
<p>eg:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Message = <span class="function">(<span class="params">&#123; boxRef, children &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> msgRef = React.useRef(<span class="literal">null</span>);</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> rect = boxRef.current.getBoundingClientRect(); <span class="comment">// 获取尺寸</span></span><br><span class="line">    msgRef.current.style.top = <span class="string">`<span class="subst">$&#123;rect.height + rect.top&#125;</span>px`</span>; <span class="comment">// 放到盒子下方</span></span><br><span class="line">  &#125;, [boxRef]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;span ref=&#123;msgRef&#125; className=<span class="string">"msgA"</span>&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">const App = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const [show, setShow] = React.useState(false);</span></span><br><span class="line"><span class="regexp">  const boxRef = React.useRef(null);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div ref=&#123;boxRef&#125; className="box" onClick=&#123;() =&gt; setShow(prev =&gt; !prev)&#125;&gt;</span></span><br><span class="line"><span class="regexp">          Click me A</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &#123;show &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Message</span> <span class="attr">boxRef</span>=<span class="string">&#123;boxRef&#125;</span>&gt;</span>useEffect<span class="tag">&lt;/<span class="name">Message</span>&gt;</span></span>&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>目的很简单，将 <code>Message</code> 组件 显示时放置到div下，但实际运行结果时会发现有一瞬间跳动效果。</p>
<p><img src="https://static.yuanziwen.cn/blog/hooks/5.png_plain" alt="alt"></p>
<p>当把Message组件内的 <code>useEffect</code> 换成<code>useLayoutEffect</code>就正常了。<br><a href="https://codesandbox.io/s/charming-surf-wz9fk?fontsize=14" target="_blank" rel="noopener"><img src="https://static.yuanziwen.cn/blog/hooks/sandbox.png_plain" alt="Edit charming-surf-wz9fk"></a></p>
<p>原因是虽然useEffect在浏览器绘制后执行，也代表着它会在新渲染之前触发。<strong>需要执行新的渲染之前它会先刷新现有的effects。</strong></p>
<p>什么？你不信？</p>
<p><img src="https://static.yuanziwen.cn/blog/hooks/6.png_plain" alt="alt"><br>e.g：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [val, updateVal] = useState(<span class="number">0</span>)</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// hooks1</span></span><br><span class="line">    updateVal(<span class="number">2</span>);</span><br><span class="line">&#125;, []);</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// hooks2</span></span><br><span class="line">    <span class="built_in">console</span>.log(val);<span class="comment">// ---- 0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 render后，先执行hook1 <code>updateVal(2)</code> 触发了 re-render，但在此之前需要先刷新现有的 effects，所以hooks2 <code>val</code> 打印出来的还是 <code>0</code> ，然后再次触发 render 渲染后的 effects hooks2才打印出 <code>2</code>。</p>
<h3 id="依赖于闭包"><a href="#依赖于闭包" class="headerlink" title="依赖于闭包"></a>依赖于闭包</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>你觉得快速的连续点击5次，弹出来的会是什么？</p>
<p><img src="https://static.yuanziwen.cn/blog/hooks/7.png_plain" alt="alt"><br>与classComponent不同，它访问的而是this。而不是闭包。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">componentDidUpdate() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://static.yuanziwen.cn/blog/hooks/8.png_plain" alt="alt"></p>
<p>在定时器里执行的事件，完全依赖于闭包。可能你不认同，但是事实确是如此。</p>
<h3 id="关于依赖项不要对React撒谎"><a href="#关于依赖项不要对React撒谎" class="headerlink" title="关于依赖项不要对React撒谎"></a>关于依赖项不要对React撒谎</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">const</span> [tagType, setTagType] = useState()</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> Api.getShopTag(&#123;</span><br><span class="line">            tagType</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setTagType(<span class="string">'hot'</span>)</span><br><span class="line">        request()</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>request</code> 函数依赖于 <code>tagType</code>，但是Effects没有依赖于<code>tagType</code>，当<code>tagType</code>改变时，<code>request</code> 内 <code>tagType</code> 的值仍然是 <code>hot</code>。<br>你可能只是想挂载的请求它，但是<br>现在只需要记住：如果你设置了依赖项，effect中用到的所有组件内的值都要包含在依赖中。这包括 props，state，函数 — 组件内的任何东西。</p>
<h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>在组件年内请求数据时，经常会这么写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        setList(result)</span><br><span class="line">        setLoaded(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        request()</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在正常情况下访问当然没问题，当组件体积庞大或者请求速度慢时，你会收到“惊喜”。</p>
<p><img src="https://static.yuanziwen.cn/blog/hooks/9.png_plain" alt="alt"><br>意思是还没请求完毕你就去到别的页面，导致effects内的 <code>setList/setLoaded</code> 无从下手送温暖。 这也是闭包的弊端 —— 无法及时销毁。还有一个解决方案是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" target="_blank" rel="noopener">AbortController</a>。</p>
<p>其实搞定这两个api就能完成80%的业务了。符合二八定律，即20%的功能完成80%的业务。封装自定义hooks大多数也需要它们。</p>
<h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><p>use<span style="color:red">Layout</span>Effect 名字与 <span>useEffect<span> 相差了一个 <span style="color:red">Layout</span>。<br>顾名思义，它们的区别就是执行时机不一样，表示在 Layout 后触发。即 render 后。</span></span></p>
<p><del>源码如下：</del></p>
<p><img src="https://static.yuanziwen.cn/blog/hooks/10.png_plain" alt="alt"></p>
<blockquote>
<p>签名与 useEffect 相同，但在所有 DOM 变化后同步触发。 使用它来从 DOM 读取布局并同步重新渲染。 在浏览器有机会绘制之前，将在 useLayoutEffect 内部计划的更新将同步刷新。</p>
</blockquote>
<p>官方解释它会阻塞渲染，所以<strong>在不操作dom的情况用 useEffect ，以避免阻止视觉更新。</strong></p>
<p><img src="https://static.yuanziwen.cn/blog/hooks/14.png_plain" alt><br>执行时机 render &gt; useLayoutEffect &gt; useEffect &gt; setState(useState) &gt; 清理effects &gt; render(第二遍) &gt; …</p>
<p>而useLayoutEffect内setState的执行机制和useEffect不一样。虽然最后都执行了合并策略。在mount和update的阶段也是不一样的。甚至函数组件顶部申明useState的顺序都会导致执行结果不一致。</p>
<p>相对于组件 mount，在 update 触发 Hooks 的顺序更让人容易理解一些。</p>
<p>requestAnimationFrame将任务“打碎”，执行的时机在于重绘后，也就是useLayoutEffect执行过后。</p>
<p>ps：如果你只是改变数据，首选<code>useEffect</code>，因为它不会阻塞渲染。这是优点也是缺点，不阻塞(代表异步)，当然也保证不了顺序。而涉及到 DOM 操作的建议使用<code>useLayoutEffect</code>。</p>
<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>内置hook，看名字就知道和redux有关。使用方法和redux相同。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state,action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> backups = &#123; ...state &#125;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'any'</span>: <span class="comment">// ... ; break;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> backups</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> initial = &#123; <span class="attr">nowTimes</span>: <span class="built_in">Date</span>.now() &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [val, dispatch] = useReducer(reducer,initial);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>useState</code> 手动一个实现 <code>useReducer</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMyReducer</span>(<span class="params">reducer, initialState, init</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> compatible = init ? init(initialState) : initialState;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(compatible);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nextState = reducer(state, action);</span><br><span class="line">    setState(nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [state, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三个参数类似于 <code>redux</code> 的 <code>initialState</code>，用于设置初始State。无论是否命中 reducer，每次 dispatch 都将触发 re-render。</p>
<p>如果你想用它代替 <code>Redux</code> 可能还是缺少点什么。有一个明显的问题，这里定义的state是和组件绑定的，和 <code>useState</code> 一样，无法和其他组件共享数据。但是通过 <code>useContext</code> 可以达到目的。</p>
<h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><blockquote>
<p>useContext(context: React.createContext)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Context/index.js</span></span><br><span class="line"><span class="keyword">const</span> ContextStore = React.createContext()</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Todo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = React.useContext(ContextStore);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(value, <span class="literal">null</span>, <span class="number">4</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ContextStore.Provider value=&#123;store&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Todo /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/ContextStore.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过使用方法发现，配合 <code>useReducer</code> 可以在组件树顶层使用 <code>Context.Provider</code> 生产/改变数据，在子组件使用 <code>useContext</code> 消费数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myContext = React.createContext();</span><br><span class="line"><span class="keyword">const</span> ContextProvider = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> products = useReducer(productsReducer, &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line">    <span class="keyword">const</span> order = useReducer(orderReducer, &#123; <span class="attr">order</span>: [] &#125;);</span><br><span class="line">    <span class="keyword">const</span> store = &#123;</span><br><span class="line">        product: products,</span><br><span class="line">        order: order <span class="comment">// [ order,deOrder ]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;myContext.Provider value=&#123;store&#125;&gt;</span><br><span class="line">          &lt;Todo /&gt;</span><br><span class="line">        &lt;<span class="regexp">/myContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Todo = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const &#123; product, order &#125; = useContext(myContext)</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">        &lt;React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">            &#123;</span></span><br><span class="line"><span class="regexp">                JSON.stringify(state, null, 4)</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;product.dispatch&#125;&gt; product dispatch &lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>弊端是当数据量变大时，整个应用会变得“十分臃肿”并且性能差劲。这有个很不错的实现 <a href="https://github.com/yisbug/iostore" target="_blank" rel="noopener">iostore</a>。</p>
<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>译文备忘录，如果更贴切点我想应该叫缓存，<code>useCache</code>？ 但后来想想也对，叫备忘录也没错，毕竟是状态逻辑复用。</p>
<p><code>useMemo</code>和<code>reselect</code>库功能相同，都是依赖于传入的值，有固定的输入就一定有固定的输出。不必重新去计算，优化性能。在依赖不改变的情况下避免重新去计算浪费性能。</p>
<p>但是reselect用起来太繁琐了。useMemo相对简单的多</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoDate = useMemo(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().toLocalString() </span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure>

<p>useMemo的第二个参数与useEffect功能相同，当依赖发生变化才会进行重新计算。<code>memoDate</code>在组件内将始终不变。</p>
<h3 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h3><p>可能你写过这样的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> aysnc () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> Api.getMainShopTag(&#123;</span><br><span class="line">            startNum: count,</span><br><span class="line">            size: <span class="number">10</span></span><br><span class="line">        &#125;)</span><br><span class="line">        setCount(result.count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;request&#125;</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span> request <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>简单的一个分页标签请求，开始一切正常，当请求第二次的时候发现 <code>count</code> 仍为0。<code>useMemo</code> 缓存了函数，自然也缓存了函数内变量的指向。所以需要在deps内添加函数内需要依赖的参数。</p>
<p>如果你对这一切还不熟悉，react-hooks 针对 eslint 推出一款插件 <code>eslint-plugin-react-hooks</code>，它可以自动帮你修复依赖项，并且提供优化支持。在制定自定义hooks的时候，严格遵守准则。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i eslint-plugin-react-hooks -D</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// other ...</span></span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        <span class="string">"html"</span>,<span class="string">"react"</span>,<span class="string">"react-hooks"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"rules"</span>:&#123;</span><br><span class="line">        <span class="string">"react-hooks/rules-of-hooks"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="string">"react-hooks/exhaustive-deps"</span>: <span class="string">"warn"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>useCallback 是 <code>useMemo</code>的变体。两者作用相同，你可以理解为前者更偏向于函数缓存。在定义一些不依赖于当前组件的属性变量方法时，可以尽量采用 <code>useCallback</code> 缓存。避免组件每次render前再次申明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useCallback(fn, deps) === useMemo(<span class="function"><span class="params">()</span> =&gt;</span> fn, deps))</span><br></pre></td></tr></table></figure>

<p>比如上面的代码你可以简化成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = useCallback(aysnc () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> Api.getMainShopTag(&#123;</span><br><span class="line">            startNum: count,</span><br><span class="line">            size: <span class="number">10</span></span><br><span class="line">        &#125;)</span><br><span class="line">        setCount(result.count)</span><br><span class="line">    &#125;, [count]);</span><br></pre></td></tr></table></figure>

<h3 id="关于memo与callback"><a href="#关于memo与callback" class="headerlink" title="关于memo与callback"></a>关于memo与callback</h3><p>useCallback与useMemo需要慎重使用。很多人以为两者是为了解决创建函数带来的性能问题，其实不然。</p>
<p>上菜：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> forgetPwd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> sendSmsCode = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> forgetPwd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> sendSmsCode = useMemo(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">/*...*/</span> &#125;, [A,B])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中两者效果是一样的，无论如何 <code>sendSmsCode</code> 都会被创建。只不因为后者需要比对依赖而耗费了稍微一点点的性能(蚊子再小也是肉)，那可能会有疑问，为什么使用了缓存性能反而越来越差。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;() =&gt; &#123;&#125;&#125;&gt;Search&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 第二次render</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;() =&gt; &#123;&#125;&#125;&gt;Search&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>

<p>两次渲染 inline 函数永远不会相等，与memo的概念背道而驰。这是没有意义的diff。只会浪费时间，而组件也绝对不会被memo优化。</p>
<p>useCallback 实际上缓存的是 inline callback 的实例，配合React.memo能够起到避免不必要的渲染。两者缺一个性能都会变差。当你的函数组件 UI 容器内有任何一个 inline 函数，任何优化都是没有意义的。</p>
<h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p><span id="useRef">解决的问题是组件数据状态无法保存，有如下代码</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Interval</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [time, setTime] = useState(<span class="built_in">Date</span>.now());</span><br><span class="line">  <span class="keyword">let</span> intervalId;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTime(<span class="built_in">Date</span>.now());</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> clear = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearInterval(intervalId);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;start&#125; type=<span class="string">"button"</span>&gt;start&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;clear&#125; type="button"&gt;clear&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>看起来很正常的一段逻辑，但是启动定时器后，发现无法关闭定时器了。</p>
<p>这是因为启动定时器后，<code>setTime(Date.now())</code> 更新值后，函数组件被 re-render。此时<code>intervalId</code>已经被重新声明了。所以清除不了之前的定时器。</p>
<p>函数组件没有被实例化，意味着无法使用this、没有内部的组件属性变量。需要避免其每次被重新声明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [intervalId, setIntervalId] = useState(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> start = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setIntervalId(</span><br><span class="line">        setInterval(<span class="function"><span class="params">()</span> =&gt;</span> setTime(<span class="built_in">Date</span>.now()), <span class="number">500</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>难道必须全部使用 <code>useState</code> 储存状态么？前面提到过，每次执行 <code>setIntervalId</code> 句柄都会触发一次 re-render，即使没有在视图里没有用到。</p>
<p>可以用 <code>useRef</code> 处理组件属性。改造组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... other</span></span><br><span class="line"><span class="keyword">let</span> intervalId = useRef(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> start = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    intervalId.current = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTime(<span class="built_in">Date</span>.now());</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> clear = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearInterval(intervalId.current);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 useRef 最好的理由是不会触发 re-render 。源码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountRef</span>&lt;<span class="title">T</span>&gt;(<span class="params">initialValue: T</span>): </span>&#123;current: T&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> ref = &#123;<span class="attr">current</span>: initialValue&#125;;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.seal(ref);</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = ref;</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那怎么理解useRef？</p>
<p>你可以把它看成是一个盒子。可以放任何数据(甚至组件) —— 海纳百川有容乃大。在盒子中的东西（current）会被隔离，且值将会被深拷贝，不会被外界所干扰、同时也不会响应。你可以重新通过 <code>ref.current</code> 去赋值。并且不会触发 re-render 与 <code>useEffect</code> 。通过 <code>.current</code> 获取的值始终都是最新的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = useRef(&#123; <span class="attr">status</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> focus = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 始终都是最新的</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(info.current), <span class="number">1000</span>); <span class="comment">// &#123;status: true&#125;</span></span><br><span class="line">    info.current.status = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input = useRef();</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//可以访问元素上的方法</span></span><br><span class="line">    input.current.focus()</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// info改变不会触发</span></span><br><span class="line">&#125;, [info.current.status])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;input&#125;</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">onFocus</span>=<span class="string">&#123;focus&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h2><p>虽然通过<code>useRef</code>可以访问本组件属性。但如果父元素想操作子组件就显得较无能无力。在 classComponent 你可以使用<code>this.chilren</code>去访问子组件方法。函数组件就没有这项特权了，毕竟没有被实例化，官方提供<code>useImperativeHandle(原useImperativeMethods)</code>向父组件暴露组件方法。额外的是需要配合 <code>forwardRef</code> 转发该节点使用，官方的例子已经极为清楚了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FancyInput.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">    focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;,</span><br><span class="line">    blurs: <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// dst...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">FancyInput = forwardRef(FancyInput);</span><br><span class="line"></span><br><span class="line"><span class="comment">//App.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fancyInputRef = useRef()</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        fancyInputRef.current.focus()</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;React.Fragment&gt;</span><br><span class="line">            &lt;FancyInput ref=&#123;fancyInputRef&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h2><p>这个就属于辅助标识了。在某个custom Hook 使用，标识该钩子是 custom hook。<br>比如申明一个 <code>useMount</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useMount = <span class="function">(<span class="params">mount</span>) =&gt;</span> &#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    mount &amp;&amp; mount();</span><br><span class="line">  &#125;, []);</span><br><span class="line">  useDebugValue(<span class="string">'it"s my Custom hook'</span>,fit =&gt; <span class="string">`<span class="subst">$&#123;fit&#125;</span> !`</span> );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  useMount(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">/*dst...*/</span>&#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider&gt;</span><br><span class="line">      &lt;Count /&gt;</span><br><span class="line">      &lt;IncrementButton /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://static.yuanziwen.cn/blog/hooks/15.png_plain" alt="alt"><br>该Api只会在ReactDevTools启用状况下才会加载，蓝色代表 <code>Custom Hook</code> 名称，比如use<span style="color:orange">Mount</span>。红色为描述。</p>
<h2 id="自定义钩子"><a href="#自定义钩子" class="headerlink" title="自定义钩子"></a>自定义钩子</h2><h3 id="实现-setState-回调"><a href="#实现-setState-回调" class="headerlink" title="实现 setState 回调"></a>实现 setState 回调</h3><p><span id="custom">首先实现一个简陋版本</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, updateVal] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> init = useRef(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doSomething = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    updateVal(<span class="function"><span class="params">pre</span> =&gt;</span> pre + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    init.current += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (init.current &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// callback</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'has changed'</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [value]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;doSomething&#125;</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这或许不能称为callback，监听可能更符合一点，可以封装成hooks</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hooks.js</span></span><br><span class="line"><span class="keyword">const</span> useStateWithCb = <span class="function">(<span class="params">initialState, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span>=&gt;</span>initialState);</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> callback(state), [state, callback]); <span class="comment">//每次state更新的时候都会去执行该回调</span></span><br><span class="line">  <span class="keyword">return</span> [state, setState];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [value, updataVal ] = useStateWithCb(<span class="number">0</span>, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样初始化也会执行，相应可以参照上文给<code>useStateWithCb</code>加上 useRef 来避免初始化执行。这里就不再演示了。还一种方法是利用 <code>useLayoutEffect</code> 也能达成相同的效果。</p>
<p>不过这样做的弊端是不能动态的传入回调。叔可忍婶婶不能忍，既然返回的updateVal不能改，那就劫持它。于是就用到 <code>Proxy</code> 的 <code>apply</code> 拦截函数调用。</p>
<blockquote>
<p>apply 函数有3个参数</p>
</blockquote>
<ul>
<li>target 调用的目标对象(函数)。</li>
<li>thisArg 调用上下文对象。</li>
<li>argumentsList 被调用时的参数数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hooks.js</span></span><br><span class="line"><span class="keyword">const</span> useStateWithCb = <span class="function">(<span class="params">initialVal</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span>=&gt;</span>initialVal);</span><br><span class="line">  <span class="keyword">const</span> hijackSetState = useMemo(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">new</span> <span class="built_in">Proxy</span>(setState, &#123; <span class="comment">// 这里做一层缓存，确保不会再次创建</span></span><br><span class="line">    apply(target, thisArg, argumentsList) &#123; <span class="comment">// 拦截</span></span><br><span class="line">      <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(argumentsList);</span><br><span class="line">      <span class="keyword">if</span> (args.length &gt; <span class="number">1</span> &amp;&amp; <span class="keyword">typeof</span> args.slice(<span class="number">-1</span>)[<span class="number">0</span>] === <span class="string">'function'</span>) &#123; <span class="comment">// 如果尾参数为函数</span></span><br><span class="line">        fn.current = args.pop(); <span class="comment">// 赋值给 fn.current</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target.apply(thisArg, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),[]);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">typeof</span> fn.current === <span class="string">'function'</span> &amp;&amp; fn.current(state);</span><br><span class="line">  &#125;, [state]);</span><br><span class="line">  <span class="keyword">return</span> [state, hijackSetState];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; useStateWithCb &#125; <span class="keyword">from</span> <span class="string">'hooks'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, updateVal] = useStateWithCb(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doSomething = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    updateVal.current(<span class="function"><span class="params">pre</span> =&gt;</span> pre + <span class="number">1</span>, (newVal) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(newVal); <span class="comment">// 1</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;doSomething&#125;</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="设置相同值"><a href="#设置相同值" class="headerlink" title="设置相同值"></a>设置相同值</h4><p>效果是能实现，但设置相同值，<code>Object.is</code> 会将其判定 <code>unChanged</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//App.js</span></span><br><span class="line"><span class="keyword">const</span> [value, updateVal] = useStateWithCb(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    updateVal(<span class="number">2</span>, (newVal) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(newVal); <span class="comment">// 值未改变，触发不了newVal</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于Effect 依赖于 state ，对于基本类型数据直接比较的值，所以触发不了 Effect 的回调函数，而Object，Array，Map，Symbol等直接比较内存地址的却可以。可以对基本类型做特别处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断原始类型数据 undefined,number,boolean,string, null,NaN</span></span><br><span class="line"><span class="keyword">const</span> isOriginal = <span class="function"><span class="params">o</span> =&gt;</span> <span class="keyword">typeof</span> o === <span class="string">'object'</span> ? !o : <span class="keyword">typeof</span> o !== <span class="string">'function'</span>;</span><br><span class="line"><span class="comment">// 创建随机数</span></span><br><span class="line"><span class="keyword">const</span> random = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).split(<span class="string">''</span>).join(<span class="string">'.'</span>)</span><br><span class="line"><span class="comment">// 函数判断</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(fn) === <span class="string">"[object Function]"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useStateWithCb = <span class="function">(<span class="params">initialVal</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span>=&gt;</span>initialVal);</span><br><span class="line">  <span class="keyword">const</span> fn = useRef(<span class="literal">null</span>);</span><br><span class="line">+ <span class="keyword">const</span> [r, sr] = useState(<span class="function"><span class="params">()</span>=&gt;</span>random()); <span class="comment">// 创建随机数句柄</span></span><br><span class="line">  <span class="keyword">const</span> hijackSetState = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(setState, &#123;</span><br><span class="line">    apply(target, thisArg, argumentsList) &#123;</span><br><span class="line">      <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(argumentsList);</span><br><span class="line">+     <span class="keyword">if</span> (isOriginal(args[<span class="number">0</span>]) &amp;&amp; args[<span class="number">0</span>] === state) &#123; <span class="comment">// 原始类型 &amp;&amp; 等与自身</span></span><br><span class="line">+       sr(random()); <span class="comment">// 如果是原始类型则更新随机数</span></span><br><span class="line">+     &#125;</span><br><span class="line">      <span class="keyword">if</span> (args.length &gt; <span class="number">1</span> &amp;&amp; <span class="keyword">typeof</span> args.slice(<span class="number">-1</span>)[<span class="number">0</span>] === <span class="string">'function'</span>) &#123;</span><br><span class="line">        fn.current = args.pop();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target(...args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),[]);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    isFunction(fn.current) &amp;&amp; fn.current(state);</span><br><span class="line">+ &#125;, [state, r]); <span class="comment">// 增加 随机数 作为依赖</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [state, hijackSetState];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码简洁，说明思路即可。</p>
<h4 id="回调内再次赋值"><a href="#回调内再次赋值" class="headerlink" title="回调内再次赋值"></a>回调内再次赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    updateVal(<span class="function"><span class="params">pre</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;pre&#125;</span>2`</span>, (firstVal) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(firstVal); <span class="comment">// 1</span></span><br><span class="line">      updateVal(<span class="function"><span class="params">pre</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;pre&#125;</span>3`</span>, (secondVal) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(secondVal); <span class="comment">// 循环调用</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种情况也能想得到是由于每次调用的都是上一次的更新器导致死循环。</p>
<p>那就把最新的更新器传给callback。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hooks.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useStateWithCb</span> (<span class="params">initialVal</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...other</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">-    isFunction(fn.current) &amp;&amp; fn.current(state);</span><br><span class="line">+    isFunction(fn.current) &amp;&amp; fn.current(state, hijackSetState);</span><br><span class="line">    &#125;, [state, r, hijackSetState]);</span><br><span class="line">   <span class="comment">// ...other</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [value, updateVal] = useStateWithCb(<span class="number">1</span>);</span><br><span class="line">    updateVal(<span class="function"><span class="params">pre</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;pre&#125;</span>2`</span>, (firstVal, firstSetter) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(firstVal); <span class="comment">// 12</span></span><br><span class="line">      firstSetter(<span class="function"><span class="params">pre</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;pre&#125;</span>3`</span>, (secondVal, secondSetter) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(secondVal); <span class="comment">// 123</span></span><br><span class="line">        secondSetter(<span class="function"><span class="params">pre</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;pre&#125;</span>4`</span>, (thirdVal, thirdSetter) =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(thirdVal); <span class="comment">// 1234</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<details>
<summary>完整版</summary>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useStateWithCb = <span class="function">(<span class="params">initialVal</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span>=&gt;</span>initialVal);</span><br><span class="line">  <span class="keyword">const</span> fn = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> [r, sr] = useState(<span class="function"><span class="params">()</span>=&gt;</span>random());</span><br><span class="line">  <span class="keyword">const</span> hijackSetState = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(setState, &#123;</span><br><span class="line">    apply(target, thisArg, argumentsList) &#123;</span><br><span class="line">      <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(argumentsList);</span><br><span class="line">      <span class="keyword">if</span> (isOriginal(args[<span class="number">0</span>]) &amp;&amp; args[<span class="number">0</span>] === state) &#123;</span><br><span class="line">        sr(random());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        args.length &gt; <span class="number">1</span></span><br><span class="line">          &amp;&amp; <span class="keyword">typeof</span> args.slice(<span class="number">-1</span>)[<span class="number">0</span>] === <span class="string">'function'</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        fn.current = args.pop();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target(...args);</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span></span><br><span class="line">  &#125;), []);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">typeof</span> fn.current === <span class="string">'function'</span> &amp;&amp; fn.current(state, hijackSetState);</span><br><span class="line">  &#125;, [state, r, hijackSetState]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [state, hijackSetState];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</details>
有兴趣的可以安装 `npm i like-hooks -S`。使用方法和上文一致。

<p><a href="https://codesandbox.io/s/serverless-morning-r2svr?fontsize=14&initialpath=StateCb&module=%2Fsrc%2Fviews%2FStateCb.js" target="_blank" rel="noopener">在SandBox查看</a></p>
<h3 id="useLifeCycles"><a href="#useLifeCycles" class="headerlink" title="useLifeCycles"></a>useLifeCycles</h3><p>或许不需要单独拿出来。但还是忍不住凑字数。</p>
<p><img src="https://static.yuanziwen.cn/blog/hooks/11.png_plain" alt="alt"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useLifeCycles = <span class="function">(<span class="params">mount, unMount</span>) =&gt;</span> &#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    mount &amp;&amp; mount();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      unMount &amp;&amp; unMount();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="useRequestAnimationFrame"><a href="#useRequestAnimationFrame" class="headerlink" title="useRequestAnimationFrame"></a>useRequestAnimationFrame</h3><p>RequestAnimationFrame使用的频率很高，理所当然将其封装成一个hooks；名字太长可不是个好事。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * useRaf useRequestAnimationFrame</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>callback 回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>startRun 立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> useRaf = <span class="function">(<span class="params">callback, startRun = <span class="literal">true</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> requestRef = useRef(); <span class="comment">// 储存RequestAnimationFrame返回的id</span></span><br><span class="line">  <span class="keyword">const</span> previousTimeRef = useRef(<span class="literal">null</span>); <span class="comment">// 每次耗时间隔</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> animate = useCallback(<span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (previousTimeRef.current !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> deltaTime = time - previousTimeRef.current; <span class="comment">// 耗时间隔</span></span><br><span class="line">      callback(deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">    previousTimeRef.current = time;</span><br><span class="line">    requestRef.current = requestAnimationFrame(animate);</span><br><span class="line">  &#125;, [callback]);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    requestRef.current = requestAnimationFrame(animate);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> cancelAnimationFrame(requestRef.current);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stopRaf = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(startRun) cancelAnimationFrame(requestRef.current);</span><br><span class="line">    requestRef.current = <span class="literal">null</span>;</span><br><span class="line">  &#125;, [animate]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> restartRaf = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (requestRef.current === <span class="literal">null</span>) &#123;</span><br><span class="line">      requestAnimationFrame(animate);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [animate]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [restartRaf, stopRaf];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCounter] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCounter(<span class="function"><span class="params">pre</span> =&gt;</span> pre + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> [start, stop] = useRaf(<span class="function"><span class="params">()</span> =&gt;</span> run());</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button type=<span class="string">"button"</span> onClick=&#123;start&#125;&gt;开始&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button type="button" onClick=&#123;stop&#125;&gt;暂停&lt;/</span>button&gt;</span><br><span class="line">      &lt;h1&gt;&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://codesandbox.io/s/serverless-morning-r2svr?fontsize=14&initialpath=%2FrunClock" target="_blank" rel="noopener">在SandBox查看</a></p>
<p>该hook接受一个函数作为帧变动的callback，callback接受一个参数，作为距离上次<code>performance.now()</code> 的间隔耗时，通常为16ms上下(意义不大，但可为低配置用户启用优化方案)。hook返回两个控制器，一个用来重启，当然不会将数据重置，另一个用来暂停。</p>
<blockquote>
<p>ps：不要用来操作DOM，如果非得操作，建议改成<code>useLayoutEffect</code>。</p>
</blockquote>
<p>有了这个hook，相信你就能够轻轻松松做出秒表、倒计时、数字逐帧变动等酷炫组件了。</p>
<h3 id="usePrevious"><a href="#usePrevious" class="headerlink" title="usePrevious"></a>usePrevious</h3><p>利用 <code>useRef</code> 保存上一次的值，在Effect里第一次取值会拿到 <code>undefined</code> 的情况。有时候还需要去判断，这里利用Symbol 判断，首次返回该值。当然你也可以不考虑这种情况（第二个参数为false）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> usePrevious = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> r = useRef(<span class="built_in">Math</span>.random().toString(<span class="number">36</span>)) <span class="comment">// 利用随机数创建全局唯一的id</span></span><br><span class="line">  <span class="keyword">const</span> ref = useRef(<span class="built_in">Symbol</span>.for(r.current));</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ref.current = value;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Symbol</span>.for(r.current) === ref.current ? value : ref.current;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://codesandbox.io/s/serverless-morning-r2svr?fontsize=14&initialpath=usePrevious&module=%2Fsrc%2Fviews%2FUsePrevious.js" target="_blank" rel="noopener">在SandBox查看</a></p>
<h3 id="useEventListener"><a href="#useEventListener" class="headerlink" title="useEventListener"></a>useEventListener</h3><p>不想去频繁写原生event事件，将其封装成hooks。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEventListener</span>(<span class="params">eventName, handler, target = window</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoHandler = useRef();</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    memoHandler.current = handler;</span><br><span class="line">  &#125;, [handler]);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> eventListener = <span class="function"><span class="params">event</span> =&gt;</span> memoHandler.current(event);</span><br><span class="line">    <span class="keyword">const</span> targetEl =</span><br><span class="line">      <span class="string">"current"</span> <span class="keyword">in</span> target &amp;&amp; <span class="keyword">typeof</span> target.current === <span class="string">"object"</span></span><br><span class="line">        ? target.current</span><br><span class="line">        : target;</span><br><span class="line">    targetEl.addEventListener(eventName, eventListener);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      targetEl.removeEventListener(eventName, eventListener);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [eventName, target]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于React-DOM为IE9+，不考虑 <code>attachEvent</code>。函数组件只能通过ref访问元素，增加.current判断防止报错。</p>
<p><a href="https://codesandbox.io/s/serverless-morning-r2svr?fontsize=14&initialpath=useEventListener&module=%2Fsrc%2Fviews%2FUseEventListener.js" target="_blank" rel="noopener">在SandBox查看</a></p>
<h3 id="useDebounce"><a href="#useDebounce" class="headerlink" title="useDebounce"></a>useDebounce</h3><p>防抖都不会陌生</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>fn 被防抖函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>[ms=300] 间隔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useDebounce = <span class="function">(<span class="params">fn, args, ms = <span class="number">300</span> </span>) =&gt;</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> pendingInput = useRef(<span class="literal">true</span>);</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> savedHandlerId;</span><br><span class="line">    <span class="keyword">if</span> (pendingInput.current) &#123;</span><br><span class="line">      pendingInput.current = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      savedHandlerId = setTimeout(fn, ms);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearTimeout(savedHandlerId);</span><br><span class="line">  &#125;, [fn, ms, args]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://codesandbox.io/s/serverless-morning-r2svr?fontsize=14&initialpath=useDebounce&module=%2Fsrc%2Fviews%2FUseDebounce.js" target="_blank" rel="noopener">在SandBox查看</a></p>
<h3 id="useThrottle"><a href="#useThrottle" class="headerlink" title="useThrottle"></a>useThrottle</h3><p>节流有更加简单的第三方实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> throttled = useRef(throttle(<span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dst...</span></span><br><span class="line">&#125;, <span class="number">1000</span>))</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> throttled.current(value), [value])</span><br></pre></td></tr></table></figure>

<p>但是入乡随俗，还是要实现一个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 节流函数，等电梯，电梯15秒一轮，进人不重置。</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; fn 被节流函数</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; args 依赖更新参数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; [timing=300] 节流阀时间</span></span><br><span class="line"><span class="comment"> * @returns 节流值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> useThrottleFn1 = <span class="function">(<span class="params">fn, args, timing = <span class="number">300</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span> =&gt;</span> fn(...args));</span><br><span class="line">  <span class="keyword">const</span> timeout = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> lastArgs = useRef(<span class="literal">null</span>); <span class="comment">// 最近一次参数</span></span><br><span class="line">  <span class="keyword">const</span> hasChanged = useRef(<span class="literal">false</span>); <span class="comment">// 是否有更新</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timeout.current) &#123;</span><br><span class="line">      <span class="keyword">const</span> timeoutHandler = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasChanged.current) &#123; <span class="comment">// 有更新，立即更新并再启动一次，否则放弃更新</span></span><br><span class="line">          hasChanged.current = <span class="literal">false</span>;</span><br><span class="line">          setState(<span class="function"><span class="params">()</span> =&gt;</span> fn(...lastArgs.current));</span><br><span class="line">          timeout.current = setTimeout(timeoutHandler, timing);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          timeout.current = <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      timeout.current = setTimeout(timeoutHandler, timing);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      lastArgs.current = args; <span class="comment">// 更新最新参数</span></span><br><span class="line">      hasChanged.current = <span class="literal">true</span>; <span class="comment">// 有更新任务</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [...args, fn, timing]);</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> throttledValue = useThrottle(<span class="function"><span class="params">value</span> =&gt;</span> value, [val], <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><a href="https://codesandbox.io/s/serverless-morning-r2svr?fontsize=14&initialpath=useThrottle&module=%2Fsrc%2Fviews%2FUseThrottle.js" target="_blank" rel="noopener">在SandBox查看</a></p>
<h3 id="useImtArray"><a href="#useImtArray" class="headerlink" title="useImtArray"></a>useImtArray</h3><p>制作一个 <code>ImmutableArray</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过二次封装数组，达到类似ImmutableArray效果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>initial </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> useImtArray = <span class="function">(<span class="params">initial = []</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(initial)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'useImtArray argument Expectations are arrays. Actually, they are'</span> + <span class="built_in">Object</span>.prototype.toString.call(initial))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> initial</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value,</span><br><span class="line">    push: useCallback(<span class="function"><span class="params">val</span> =&gt;</span> setValue(<span class="function"><span class="params">v</span> =&gt;</span> [...v, val]), []),</span><br><span class="line">    pop: useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setValue(<span class="function"><span class="params">arr</span> =&gt;</span> arr.slice(<span class="number">0</span>, arr.length - <span class="number">1</span>)), []),</span><br><span class="line">    shift: useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setValue(<span class="function"><span class="params">arr</span> =&gt;</span> arr.slice(<span class="number">1</span>, arr.length)),[]),</span><br><span class="line">    unshift: useCallback(<span class="function"><span class="params">val</span> =&gt;</span> setValue(<span class="function"><span class="params">v</span> =&gt;</span> [val, ...v]), []),</span><br><span class="line">    clear: useCallback(<span class="function"><span class="params">()</span> =&gt;</span> setValue(<span class="function"><span class="params">()</span> =&gt;</span> []), []),</span><br><span class="line">    removeByVal: useCallback(<span class="function"><span class="params">val</span> =&gt;</span> setValue(<span class="function"><span class="params">arr</span> =&gt;</span> arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> v !== val)),[]),</span><br><span class="line">    removeByIdx: useCallback(<span class="function"><span class="params">index</span> =&gt;</span> setValue(<span class="function"><span class="params">arr</span> =&gt;</span></span><br><span class="line">          arr.filter(<span class="function">(<span class="params">v, idx</span>) =&gt;</span> <span class="built_in">parseInt</span>(index, <span class="number">10</span>) !== idx),</span><br><span class="line">        ), []),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://codesandbox.io/s/serverless-morning-r2svr?fontsize=14&initialpath=useImtArray&module=%2Fsrc%2Fviews%2FUseImtArray.js" target="_blank" rel="noopener">在SandBox查看</a></p>
<h3 id="usePromise"><a href="#usePromise" class="headerlink" title="usePromise"></a>usePromise</h3><p>Promise当然也少不了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简化Promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>fn Promise函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>[args=[]] 依赖更新参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>loading:加载状态,value:成功状态的值,error:失败状态的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> usePromise = <span class="function">(<span class="params">fn, args = []</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(&#123;&#125;);</span><br><span class="line">  <span class="comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span></span><br><span class="line">  <span class="keyword">const</span> memoPromise = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> fn(), args);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pending = <span class="literal">true</span>; <span class="comment">// 防止多次触发</span></span><br><span class="line">    setState(<span class="function"><span class="params">newestState</span> =&gt;</span> (&#123; ...newestState, <span class="attr">loading</span>: <span class="literal">true</span> &#125;));</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(memoPromise())</span><br><span class="line">      .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pending) &#123;</span><br><span class="line">          setState(&#123;</span><br><span class="line">            loading: <span class="literal">false</span>,</span><br><span class="line">            value,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pending) &#123;</span><br><span class="line">          setState(&#123;</span><br><span class="line">            loading: <span class="literal">false</span>,</span><br><span class="line">            error,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      pending = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [memoPromise]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> )&#123;</span><br><span class="line">      resolve(<span class="string">'Success'</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      reject(<span class="string">'Fail'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; value, loading, error&#125; = usePromise(request)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;&#123;loading? <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> : result:<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;error||value&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://codesandbox.io/s/serverless-morning-r2svr?fontsize=14&initialpath=usePromise&module=%2Fsrc%2Fviews%2FUsePromise.js" target="_blank" rel="noopener">在SandBox查看</a></p>
<h3 id="useGetter"><a href="#useGetter" class="headerlink" title="useGetter"></a>useGetter</h3><p>通过 <code>Object.definedProperty</code> 能够简单的去监听读取属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; clone, isPlainObject &#125; <span class="keyword">from</span> <span class="string">'../utils'</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听对象属性被读取</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>watcher 监听对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>fn 回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> useGetter = <span class="function">(<span class="params">watcher, fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(watcher)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">`Expectation is the object, the actual result <span class="subst">$&#123;<span class="built_in">Object</span>.prototype.toString.call(</span></span></span><br><span class="line"><span class="string"><span class="subst">        watcher,</span></span></span><br><span class="line"><span class="string"><span class="subst">      )&#125;</span>`</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> value = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> watcher, [watcher]);</span><br><span class="line">  <span class="keyword">const</span> cloneVal = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> clone(watcher), [watcher]);</span><br><span class="line">  <span class="keyword">const</span> cb = useRef(fn);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.keys(cloneVal).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(value, name, &#123;</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> cb.current === <span class="string">'function'</span>)</span><br><span class="line">          cb.current(name, cloneVal);</span><br><span class="line">        <span class="keyword">return</span> cloneVal[name];</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://codesandbox.io/s/serverless-morning-r2svr?fontsize=14&initialpath=useGetter&module=%2Fsrc%2Fviews%2FUseGetter.js" target="_blank" rel="noopener">在SandBox查看</a></p>
<h3 id="useLockBodyScroll"><a href="#useLockBodyScroll" class="headerlink" title="useLockBodyScroll"></a>useLockBodyScroll</h3><p>这个钩子偶然看到的，针对防止遮罩滚动穿透。<a href="https://codesandbox.io/s/yvkol51m81?fontsize=14" target="_blank" rel="noopener">原地址</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁定body滚动条，多用于modal，后台</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> useLockBodyScroll = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> originalStyle = <span class="built_in">window</span>.getComputedStyle(<span class="built_in">document</span>.body)</span><br><span class="line">      .overflow;</span><br><span class="line">    <span class="built_in">document</span>.body.style.overflow = <span class="string">'hidden'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.body.style.overflow = originalStyle;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://codesandbox.io/s/serverless-morning-r2svr?fontsize=14&initialpath=useLockBodyScroll&module=%2Fsrc%2Fviews%2FUseLockBodyScroll.js" target="_blank" rel="noopener">在SandBox查看</a></p>
<h3 id="useTheme"><a href="#useTheme" class="headerlink" title="useTheme"></a>useTheme</h3><p>你甚至可以自己切换主题配色，就像这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更换主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>theme 主题数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> useTheme = <span class="function"><span class="params">theme</span> =&gt;</span> &#123;</span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> theme) &#123;</span><br><span class="line">      <span class="built_in">document</span>.documentElement.style.setProperty(</span><br><span class="line">        <span class="string">`--<span class="subst">$&#123;key&#125;</span>`</span>,</span><br><span class="line">        theme[key],</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [theme]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://codesandbox.io/s/serverless-morning-r2svr?fontsize=14&initialpath=useTheme&module=%2Fsrc%2Fviews%2FUseTheme.js" target="_blank" rel="noopener">在SandBox查看</a></p>
<h3 id="useInput"><a href="#useInput" class="headerlink" title="useInput"></a>useInput</h3><p>写input的时候你还在手动 <code>onChange</code> 么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * auto Input Hooks</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>initial Input初始值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>InputProps clear清空  replace(arg:any|Function) bind 绑定Input</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useInput</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(initial);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onChange</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    setValue(event.currentTarget.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> clear = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setValue(<span class="string">''</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> replace = <span class="function"><span class="params">arg</span> =&gt;</span> &#123;</span><br><span class="line">    setValue(<span class="function"><span class="params">pre</span> =&gt;</span> (<span class="keyword">typeof</span> arg === <span class="string">'function'</span> ? arg(pre) : arg));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    bind: &#123;</span><br><span class="line">      value,</span><br><span class="line">      onChange,</span><br><span class="line">    &#125;,</span><br><span class="line">    value,</span><br><span class="line">    clear,</span><br><span class="line">    replace,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Input</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> userName = useInput(<span class="string">"Seven"</span>); <span class="comment">// &#123;clear,replace,bind:&#123;value,onChange&#125;&#125;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...userName.bind</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://codesandbox.io/s/serverless-morning-r2svr?fontsize=14&initialpath=useInput&module=%2Fsrc%2Fviews%2FUseInput.js" target="_blank" rel="noopener">在SandBox查看</a></p>
<h3 id="useDragger"><a href="#useDragger" class="headerlink" title="useDragger"></a>useDragger</h3><p>一个极简的拖拽hook，稍加改造。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拖拽元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>el 目标元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>x,y偏移量 pageX,pageY 元素左上角位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDraggable</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [&#123; dx, dy &#125;, setOffset] = useState(&#123; <span class="attr">dx</span>: <span class="number">0</span>, <span class="attr">dy</span>: <span class="number">0</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> [&#123; pageX, pageY &#125;, setPageOffset] = useState(&#123;</span><br><span class="line">    pageX: <span class="number">0</span>,</span><br><span class="line">    pageY: <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; top, left &#125; = el.current.getBoundingClientRect();</span><br><span class="line">    setPageOffset(&#123; <span class="attr">pageX</span>: top, <span class="attr">pageY</span>: left &#125;);</span><br><span class="line">    <span class="keyword">const</span> handleMouseDown = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> startX = event.pageX - dx;</span><br><span class="line">      <span class="keyword">const</span> startY = event.pageY - dy;</span><br><span class="line">      <span class="keyword">const</span> handleMouseMove = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newDx = e.pageX - startX;</span><br><span class="line">        <span class="keyword">const</span> newDy = e.pageY - startY;</span><br><span class="line">        setOffset(&#123; <span class="attr">dx</span>: newDx, <span class="attr">dy</span>: newDy &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, handleMouseMove);</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">'mouseup'</span>, () =&gt; &#123;</span><br><span class="line">          <span class="built_in">document</span>.removeEventListener(<span class="string">'mousemove'</span>, handleMouseMove);</span><br><span class="line">        &#125;,&#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    el.current.addEventListener(<span class="string">'mousedown'</span>, handleMouseDown);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      el.current.removeEventListener(<span class="string">'mousedown'</span>, handleMouseDown);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [dx, dy, el]);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    el.current.style.transform = <span class="string">`translate3d(<span class="subst">$&#123;dx&#125;</span>px, <span class="subst">$&#123;dy&#125;</span>px, 0)`</span>;</span><br><span class="line">  &#125;, [dx, dy, el]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">x</span>: dx, <span class="attr">y</span>: dy, pageX, pageY &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://codesandbox.io/s/serverless-morning-r2svr?fontsize=14&initialpath=useDragger&module=%2Fsrc%2Fviews%2FUseDragger.js" target="_blank" rel="noopener">在SandBox查看</a></p>
<h2 id="生命周期：从类组件到函数组件的过渡"><a href="#生命周期：从类组件到函数组件的过渡" class="headerlink" title="生命周期：从类组件到函数组件的过渡"></a>生命周期：从类组件到函数组件的过渡</h2><p>截至目前 react 最新版本为 <code>16.9</code> ，从<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">图例</a>中，探索各生命周期的实现方案。虽然没有理由再去使用 LifyCycle 了，但是了解下还是可以的。</p>
<p><img src="https://static.yuanziwen.cn/blog/hooks/12.png_plain" alt="alt"></p>
<h3 id="componentDidMount-与-componentWillUnmount"><a href="#componentDidMount-与-componentWillUnmount" class="headerlink" title="componentDidMount 与 componentWillUnmount"></a>componentDidMount 与 componentWillUnmount</h3><p>由于是函数组件，没有被实例化，就没有一套完整的 LifeCycle 。<code>componentWillMount</code> 与 <code>componentDidMount</code> 只有顺序之分，放在组件顶部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 函数组件顶部</span></span><br><span class="line">    <span class="keyword">const</span> [value, setValue] = useState(<span class="number">0</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'componentDidMount'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'componentWillUnMount'</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;, []);</span><br><span class="line">    <span class="comment">// other</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="forceUpdate"></a>forceUpdate</h3><p>通过更新一个无关的state闭包变量强制更新</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [updateDep,setUpdateDep] = useState(<span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forceUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setUpdateDep(<span class="function">(<span class="params">updateDep</span>) =&gt;</span> updateDep + <span class="number">1</span> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h3><p>render后渲染dom之前调用，当然是 <code>useLayoutEffect</code>。效果有待验证。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SnapshotRef = useRef()</span><br><span class="line">useLayoutEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    SnapshotRef.current = <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><p>利用上文setState回调的例子，不同的是 <code>componentDidUpdate</code> 依赖的是所有值，所以没有deps。结合 <code>useRef</code> 和 <code>useEffect</code> 实现，<code>componentDidUpdate</code> 执行时机为组件第二次开始render，只需要判断执行render次数是否大于1即可。时机晚于 <code>useLayoutEffect</code>。以便可以拿到最新的 <code>SnapshotRef.current</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> updateRender = useRef(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  updateRender.current++ </span><br><span class="line">  <span class="keyword">if</span>(updateRender.current &gt; <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">// componentDidUpdate</span></span><br><span class="line">      <span class="comment">// get SnapshotRef.current do some thing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><p>在class里，<code>PureComponent</code> 替代自动<code>shouldComponentUpdate</code>，而在函数组件里，当然是memo，能将一个组件完美优化工作量可不会小。</p>
<h3 id="后话-1"><a href="#后话-1" class="headerlink" title="后话"></a>后话</h3><p>还是那句话，入乡随俗，React hooks 确实是革命性的变动，不能把 hooks 看成是 ClassComponent LifeCycle 的进化版，应该称之为重做版，于前者来说对新手也不太友好。把底层机制通过 effects 暴露给开发者确实是个明智之举。如果仍然想着用Hooks去实现LifeCycle 那么为什么不用 react 的“老版本”呢？</p>
<h2 id="更有有意思的Hooks"><a href="#更有有意思的Hooks" class="headerlink" title="更有有意思的Hooks"></a>更有有意思的Hooks</h2><p>本文有部分Hook都出自<code>react-use</code> 及 <code>hook-guide</code> 思路去开发的。相信掌握了hooks，你离成功剩下的只差一个Idea了。<br>Hooks | 描述<br>—- | —<br><a href="https://streamich.github.io/react-use/?path=/story/state-creatememo--docs" target="_blank" rel="noopener">React Use</a> | hooks 工具库<br><a href="https://usehooks.com/useHistory/" target="_blank" rel="noopener">useHistory</a> | 管理历史记录栈<br><a href="https://usehooks.com/useScript/" target="_blank" rel="noopener">useScript</a> |动态添加脚本<br><a href="https://usehooks.com/useAuth/" target="_blank" rel="noopener">useAuth</a>| 用户状态<br><a href="https://usehooks.com/useWhyDidYouUpdate/" target="_blank" rel="noopener">useWhyDidYouUpdate</a>|hook版Why-Did-You-Update<br><a href="https://usehooks.com/useDarkMode/" target="_blank" rel="noopener">useDarkMode</a> | 切换夜间模式</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>Dan <a href="https://overreacted.io/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">A Complete Guide to useEffect</a></li>
</ul>
<p>如果你还觉得不错，star一下也是不错的<a href="https://github.com/yzw7489757/like-hooks" target="_blank" rel="noopener">like-hooks</a></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="blog.yuanziwen.cn">Seven</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="blog.yuanziwen.cn/2019/09/13/制定专属自己的-React-Hooks/">blog.yuanziwen.cn/2019/09/13/制定专属自己的-React-Hooks/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/React/">React</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2019/09/24/React传-1/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">React传-1</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2019/07/23/数据结构与算法/">
        <span class="next-text nav-default">数据结构与算法(未完结)</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'cxeaTV5BFDCxPmxoCcG9QPxf-gzGzoHsz',
        appKey: 's577OrPG5sB4Szom6mvHuI1X',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info: guest,
        pageSize:'10' || 10,
    });
  </script>

<footer id="footer" class="footer"><div class="social-links"><a href="mailto:yuanziwen7489757@gmail.com" class="iconfont icon-email" title="email"></a>
          <a href="https://juejin.im/user/59aa31a06fb9a02485103ddf" class="iconfont juejin" title="掘金"><div class="img"></div></a>
        <a href="https://github.com/yzw7489757" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <!--<span class="division">|</span>
  <span class="theme-info">
    footer.theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>-->
  <span class="power-by">
   <a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备18011257号-1</a>
  </span>
  <span class="copyright-year">&copy;2017 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Seven</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
<script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js?t=1624262701310')
    .then(function () {console.log('ServiceWorker Register Successfully.')})
    .catch(function (e) {console.error(e)});
}
</script></body>
</html>
