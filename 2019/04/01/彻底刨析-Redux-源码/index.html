<!DOCTYPE html>
<html lang="zh-Hans">
  <head><meta name="generator" content="Hexo 3.9.0"><link rel="manifest" href="/manifest.json"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="彻底刨析 Redux 源码"><meta name="keywords" content="Seven YuanZiWen"><link rel="alternate" href="/atom.xml" title="Seven Blog"><link rel="shortcut icon" type="image/x-icon" href="https://static.yuanziwen.cn/blog/favicon.ico?v=2.11.0">
<link rel="canonical" href="blog.yuanziwen.cn/2019/04/01/彻底刨析-Redux-源码/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1e4ffaffd9b2bc832b39e2b866a92c7b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>彻底刨析 Redux 源码 - Seven Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Seven Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Record
          </li>
      </a><a href="/music/">
        <li class="mobile-menu-item">Music(NoAuto)
          </li>
      </a><a href="/photo/">
        <li class="mobile-menu-item">Album
          </li>
      </a><a href="/book/">
        <li class="mobile-menu-item">Book
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Seven Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Record
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/music/">
            Music(NoAuto)
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/photo/">
            Album
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/book/">
            Book
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">彻底刨析 Redux 源码
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-04-01
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编程模式"><span class="toc-text">编程模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#命令式编程"><span class="toc-text">命令式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数式编程"><span class="toc-text">函数式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逻辑式编程"><span class="toc-text">逻辑式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#差异"><span class="toc-text">差异</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整体流程"><span class="toc-text">整体流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从入口开始"><span class="toc-text">从入口开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#createStore"><span class="toc-text">createStore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中间件"><span class="toc-text">中间件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dispatch的妙用"><span class="toc-text">dispatch的妙用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#subscribe-添加订阅者"><span class="toc-text">subscribe 添加订阅者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#订阅-subscribe-者模式"><span class="toc-text">订阅(subscribe)者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监听-listen-者"><span class="toc-text">监听(listen)者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码分析"><span class="toc-text">代码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#replaceReducer-动态注入"><span class="toc-text">replaceReducer 动态注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#源码"><span class="toc-text">源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现reducer按需加载"><span class="toc-text">实现reducer按需加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#observable"><span class="toc-text">observable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#combineReducers"><span class="toc-text">combineReducers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bindActionCreators"><span class="toc-text">bindActionCreators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后话"><span class="toc-text">后话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#怎么管理大量的reducer、action、constants？"><span class="toc-text">怎么管理大量的reducer、action、constants？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#actions"><span class="toc-text">actions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constants"><span class="toc-text">constants</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reducers"><span class="toc-text">reducers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#store-reducers-js"><span class="toc-text">store/reducers.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#业务组件内调用"><span class="toc-text">业务组件内调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-如何查看每个组件渲染性能"><span class="toc-text">react 如何查看每个组件渲染性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#why-did-you-update"><span class="toc-text">why-did-you-update</span></a></li></ol>
    </div>
  </div><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.2.1/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多人总觉得 <code>Redux</code> 对于 <code>React</code> 来说就像是 <code>VueX</code> 和 <code>Vue</code> 一样的关系。</p>
<p>但其实，<code>Redux</code> 和 <code>React</code> 没有关系。只是作者和这两者有关系。</p>
<p><img src="https://static.yuanziwen.cn/blog/reduxCode/redux.png_plain" alt="alt"></p>
<p>Redux是函数式编程较为典型的例子，源码简洁明了。有助于了解设计与思想，后期从根源上找问题、复现问题也有帮助。</p>
<a id="more"></a>

<h2 id="编程模式"><a href="#编程模式" class="headerlink" title="编程模式"></a>编程模式</h2><p>近年函数式编程越来越火，常见的编程范式有命令式编程，声明式编程，逻辑式编程。</p>
<p>那什么是函数式编程，什么又是命令式编程呢？<br>以下个人见解，不喜勿喷，如果你有更好的观点欢迎留言讨论。</p>
<p>e.g.有一个公式，求连续自然数的平方和：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s = <span class="number">1</span>² + <span class="number">2</span>² + <span class="number">3</span>² + <span class="number">4</span>² + ... + N²</span><br></pre></td></tr></table></figure>

<h3 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h3><p>用命令式是这么解决问题的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">squares</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, sum = <span class="number">0</span>, squares = []</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    squares.push(arr[i] * arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; squares.length; i++)&#123;</span><br><span class="line">    sum += squares[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(squares([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])) <span class="comment">//55</span></span><br></pre></td></tr></table></figure>

<p>虽然说现在的你不会写出这样的代码，但以前肯定写过类似的。别说是同事，就算是自己过半个月回来也要熟悉一会亲手写的逻辑代码。</p>
<p>也称“业务型”编程，指的是用一步步下达命令最终去实现某个功能。行为过程不直观，只关心下一步应该怎么、然后再怎么、最后干什么，却对性能、易读性、复用性漠不关心。</p>
<p>因为需求的差异化、定制化太过严重，依赖于后端交互、并且函数式编程过于抽象，导致无法用函数式编程做到高效率开发，所以现在业务的实现，大多数都偏向于命令式编程。但是也带来很大的一个问题，过于重复，有位大佬(不知道谁)说过：“DRY(Don’t Repeat YouSelf)”。最典型的情况莫在于产品让你写若干个后台列表筛选页面，每个页面只是字段不一样而已。有些要筛选框、下拉框、搜索建议、评论等，而有些只要输入框，即使高阶组件面对这种情况也不能做到太多复用效果。</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>函数式编程是声明式的一种 —— 最经典的Haskell(老读成HaSaKi)。近几年大量库所应用。和生态圈的各类组件中，它们的标签很容易辨认 —— 不可变数据(immutable)、高阶函数(柯里化)、尾递归、惰性序列等… 它最大的特点就是专一、简洁、封装性好。</p>
<p>用函数式编程解决这个问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">squares</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="params">d</span>=&gt;</span><span class="built_in">Math</span>.pow(d,<span class="number">2</span>))</span><br><span class="line">  .reduce(<span class="function">(<span class="params">p,n</span>)=&gt;</span>p+n,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(squares([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])) <span class="comment">//55</span></span><br></pre></td></tr></table></figure>

<p>它不仅可读性更高，而且更加简洁，在这里，我们不用去关心for循环和索引，我们只关心两件事：</p>
<p>1.取出每个数字计算平方(map,Math.pow)</p>
<p>2.累加(reduce)</p>
<blockquote>
<p>ps: pow也可以不用，更简洁，这里只是为了需求，万一是十次方，<code>d*d*d*d*d*d*d*d*d*d</code> ？几十次方？？</p>
</blockquote>
<h3 id="逻辑式编程"><a href="#逻辑式编程" class="headerlink" title="逻辑式编程"></a>逻辑式编程</h3><p>属于稀有动物，有点像初中数学的命题推论和 <code>Node</code> 里的 <code>asset</code> 断言，通过一系列事实和规则，利用数理逻辑来推导或论证结论。但并不适合理论上的教学，所以没有被广泛采用。</p>
<h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><ul>
<li><p>函数式编程关心数据是如何被处理的,类似于自动流水线。</p>
</li>
<li><p>而命令式编程关心的是怎么去做？就像是手工，先这样做，再这样做，然后再这样，如果这样，就这样做 …</p>
</li>
<li><p>逻辑式编程是通过一定的规则和数据，推导出结论，类似于asset，使用极少</p>
</li>
</ul>
<p>他们几个有什么区别？这个问题对于一个非专出身有点难以理解。总结一下<br>引用 <a href="https://www.zhihu.com/question/28292740/answer/100284611" target="_blank" rel="noopener">nameoverflow</a> 的回答：</p>
<blockquote>
<p>函数式编程关心数据的映射，命令式编程关心解决问题的步骤。</p>
</blockquote>
<p>了解到这里，相信大概的概念你也能领悟到。<br>引入主题，redux是函数式编程很好的一门不扯皮了，我们开始干正事</p>
<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><img src="https://static.yuanziwen.cn/blog/redux/reduxFlow.gif_plain">

<h2 id="从入口开始"><a href="#从入口开始" class="headerlink" title="从入口开始"></a>从入口开始</h2><p>废话不能多，可能有些人需要Demo，创建了存档 =》<a href="https://github.com/yzw7489757/react-middleware/tree/redux-app-1/src" target="_blank" rel="noopener">项目分支Demo</a>，</p>
<p>将redux源码down下来，放到src/redux下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/redux/index.js</span></span><br><span class="line"><span class="keyword">import</span> createStore <span class="keyword">from</span> <span class="string">'./createStore'</span></span><br><span class="line"><span class="keyword">import</span> combineReducers <span class="keyword">from</span> <span class="string">'./combineReducers'</span></span><br><span class="line"><span class="keyword">import</span> bindActionCreators <span class="keyword">from</span> <span class="string">'./bindActionCreators'</span></span><br><span class="line"><span class="keyword">import</span> applyMiddleware <span class="keyword">from</span> <span class="string">'./applyMiddleware'</span></span><br><span class="line"><span class="keyword">import</span> compose <span class="keyword">from</span> <span class="string">'./compose'</span></span><br><span class="line"><span class="keyword">import</span> warning <span class="keyword">from</span> <span class="string">'./utils/warning'</span></span><br><span class="line"><span class="keyword">import</span> __DO_NOT_USE__ActionTypes <span class="keyword">from</span> <span class="string">'./utils/actionTypes'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a dummy function to check if the function name has been altered by minification.</span></span><br><span class="line"><span class="comment"> * If the function has been minified and NODE_ENV !== 'production', warn the user.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isCrushed</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">  <span class="keyword">typeof</span> isCrushed.name === <span class="string">'string'</span> &amp;&amp;</span><br><span class="line">  isCrushed.name !== <span class="string">'isCrushed'</span></span><br><span class="line">) &#123;</span><br><span class="line">  warning(</span><br><span class="line">    <span class="string">'You are currently using minified code outside of NODE_ENV === "production". '</span> +</span><br><span class="line">      <span class="string">'This means that you are running a slower development build of Redux. '</span> +</span><br><span class="line">      <span class="string">'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify '</span> +</span><br><span class="line">      <span class="string">'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) '</span> +</span><br><span class="line">      <span class="string">'to ensure you have the correct code for your production build.'</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  createStore,</span><br><span class="line">  combineReducers,</span><br><span class="line">  bindActionCreators,</span><br><span class="line">  applyMiddleware,</span><br><span class="line">  compose,</span><br><span class="line">  __DO_NOT_USE__ActionTypes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会判断在非生产环境下 <code>isCrushed</code> 表示在生产环境下压缩，因为使用压缩过后的 <code>redux</code> 会降低性能，这里建立一个空函数在入口处判断警告开发者。<br>三个条件：</p>
<ul>
<li>非生产环境。</li>
<li>函数有name , IE 不支持 Function.name。所以先要用 <code>typeof</code> 判断下</li>
<li>但是名称已经被改变 <code>isCrushed</code>。 压缩后<code>isCrushed.name !== &#39;isCrushed&#39;</code>;</li>
</ul>
<p>这里为什么要用 <code>typeof isCrushed.name</code> ，<code>typeof</code> 有容错保护机制，保证不会程序崩溃。<br><img src="https://static.yuanziwen.cn/blog/reduxCode/1.png_plain" alt="alt"></p>
<p>对外暴露5个常用的API。<br><code>__DO_NOT_USE__ActionTypes</code>。顾名思义不要用这里面的几个ActionTypes。但是随机数的方法为什么不用symbol防止重命名有待思考。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/redux/utils/actionTypes.js</span></span><br><span class="line"><span class="comment">// 生成随机数，大概输出sqrt(36*(7-1)) = 46656次后看到重复，一般程序事件触发不到这个次数</span></span><br><span class="line"><span class="keyword">const</span> randomString = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">Math</span>.random()</span><br><span class="line">    .toString(<span class="number">36</span>)</span><br><span class="line">    .substring(<span class="number">7</span>)</span><br><span class="line">    .split(<span class="string">''</span>)</span><br><span class="line">    .join(<span class="string">'.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ActionTypes = &#123;</span><br><span class="line">  INIT: <span class="string">`@@redux/INIT<span class="subst">$&#123;randomString()&#125;</span>`</span>, <span class="comment">//用来redux内部发送一个默认的dispatch, initialState</span></span><br><span class="line">  REPLACE: <span class="string">`@@redux/REPLACE<span class="subst">$&#123;randomString()&#125;</span>`</span>, <span class="comment">// store.replaceReducers替换当前reducer触发的内部Actions</span></span><br><span class="line">  PROBE_UNKNOWN_ACTION: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`@@redux/PROBE_UNKNOWN_ACTION<span class="subst">$&#123;randomString()&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>PROBE_UNKNOWN_ACTION</code> 则是redux内部随机检测<code>combineReducers</code>合并所有<code>reducer</code>默认情况下触发任何Action判断是否返回了相同的数据。</p>
<h2 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h2><blockquote>
<p>createStore(reducer:any,preloadedState?:any,enhancer?:middleware),最终返回一个 <code>state tree</code> 实例。可以进行<code>getState</code>， <code>subscribe</code> 监听和 <code>dispatch</code> 派发。</p>
</blockquote>
<p><code>createStore</code> 接收3个参数</p>
<ul>
<li>reducer: Function。给定当前<code>state tree</code>和要执行的<code>action</code>,返回下一个<code>state tree</code>。</li>
<li>preloadedState?: any，<code>initial state tree</code>。</li>
<li>enhancer?:middle, 增强器，若干个中间件可以通过 <code>applymiddleware</code> 产生一个增强器<code>enhancer</code>，多个增强器可以通过 <code>compose</code> 函数合并成一个增强器。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/redux/createStore.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'function'</span>) ||</span><br><span class="line">    (<span class="keyword">typeof</span> enhancer === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">3</span>] === <span class="string">'function'</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 检测是否传入了多个compose函数，抛出错误，提示强制组合成一个enhancer</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'It looks like you are passing several store enhancers to '</span> +</span><br><span class="line">        <span class="string">'createStore(). This is not supported. Instead, compose them '</span> +</span><br><span class="line">        <span class="string">'together to a single function.'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 直接传enhancer的情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    enhancer = preloadedState</span><br><span class="line">    preloadedState = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 校验enhancer</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回创建增强后的store</span></span><br><span class="line">    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 校验reducer</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the reducer to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//60 --------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>60行暂停一会，<code>return enhancer(createStore)(reducer, preloadedState)</code> 。如果传入了 <code>enhancer</code> 增强器的状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/store/index.js</span></span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'logger before'</span>, store.getState())</span><br><span class="line">  <span class="keyword">const</span> returnValue = next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'logger after'</span>, store.getState())</span><br><span class="line">  <span class="keyword">return</span> returnValue</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configStore</span>(<span class="params">preloadedState</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> composeEnhancer = <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;</span><br><span class="line">  <span class="keyword">const</span> logEnhancer = applyMiddleware(logger);<span class="comment">// 应用中间件生成的增强器</span></span><br><span class="line">  <span class="keyword">const</span> store = createStore(</span><br><span class="line">    ShopState,</span><br><span class="line">    preloadedState,</span><br><span class="line">    composeEnhancer(logEnhancer) <span class="comment">// compose可以将多个增强器合并成一个增强器Plus</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终创建store后的状态样子应该是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// enhancer = composeEnhancer(applyMiddleware(logger)))</span></span><br><span class="line">enhancer(createStore)(reducer, preloadedState)</span><br><span class="line"> ||</span><br><span class="line">\||<span class="regexp">/</span></span><br><span class="line"><span class="regexp"> \/</span></span><br><span class="line"><span class="regexp">composeEnhancer(applyMiddleware(logger)))(createStore)(reducer, preloadedState)</span></span><br></pre></td></tr></table></figure>

<p>看起来是不是很复杂，没事，我们一步一步来，先看下<code>compose</code>函数做了什么。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很精简，首先检查是否有增强器的情况，如果没有就返回一个空函数，如果有一个就返回该函数，只有多个的才会产生<code>compose</code>。这里的<code>compose</code>代码其实只有一行，通过迭代器生成组合迭代函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br></pre></td></tr></table></figure>

<p>其他都是做兼容。最终会将<code>compose(f,g,h...)</code>转化成<code>compose(f(g(h(...))))</code>。</p>
<blockquote>
<p>不同于柯里化，compose参数无限收集一次性执行，而科里化是预先设置参数长度等待执行。而且<code>compose(f(g(h(...))))</code>等价于<code>compose(h(g(f(...))))</code>，我们来看个Demo</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">str</span> =&gt;</span> str + <span class="string">'a'</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="function"><span class="params">str</span> =&gt;</span> str + <span class="string">'b'</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="function"><span class="params">str</span> =&gt;</span> str + <span class="string">'c'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span><span class="function">(<span class="params">...args</span>)=&gt;</span>a(b(...args)))</span><br><span class="line">&#125;</span><br><span class="line">compose(a,b,c)(<span class="string">'开始迭代了'</span>) <span class="comment">// 开始迭代了cba</span></span><br></pre></td></tr></table></figure>

<p>compose的入参现在只有一个，直接返回自身，可以被忽略，我们可以试试传入多个 <code>enhancer</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> enhancer = applyMiddleware(logger)</span><br><span class="line">compose(enhancer,enhancer,enhancer) <span class="comment">// 前后将会打印6次logger</span></span><br></pre></td></tr></table></figure>

<p>了解完了<code>compose</code>，我们再看<code>applyMiddleware(logger)</code></p>
<p><a href="https://github.com/reduxjs/redux/blob/master/src/applyMiddleware.js" target="_blank" rel="noopener">applyMiddleware源代码</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/redux/applyMiddleware.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> compose <span class="keyword">from</span> <span class="string">'./compose'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 接受若干个中间件参数</span></span><br><span class="line">   <span class="comment">// 返回一个enhancer增强器函数，enhancer的参数是一个createStore函数。等待被enhancer(createStore)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 先创建store，或者说，创建已经被前者增强过的store</span></span><br><span class="line">    <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line">    <span class="comment">// 如果还没有改造完成，就先被调用直接抛出错误</span></span><br><span class="line">    <span class="keyword">let</span> dispatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Dispatching while constructing your middleware is not allowed. '</span> +</span><br><span class="line">          <span class="string">'Other middleware would not be applied to this dispatch.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暂存改造前的store</span></span><br><span class="line">    <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历中间件 call(oldStore)，改造store，得到改造后的store数组</span></span><br><span class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    <span class="comment">// 组合中间件，将改造前的dispatch传入，每个中间件都将得到一个改造/增强过后的dispatch。</span></span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终返回一个加强后的createStore()函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能实现错误也是一种学习。有时候这种错误反而能带来一些更直观的感受，知道原因，在可见的未来完全可以去避免。上面抛出错误的情况只有一种</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 监听路由的时候 dispatch(action)，由于当前还未改造完，会抛错</span></span><br><span class="line">  history.listen(<span class="function"><span class="params">location</span> =&gt;</span> &#123; store.dispatch(updateLocation(location)) &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (action.type !== TRANSITION) &#123;</span><br><span class="line">        <span class="keyword">return</span> next(action)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> &#123; method, arg &#125; = action</span><br><span class="line">      history[method](arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在map middlewares的期间，<code>dispatch</code> 将要在下一步应用，但是目前没应用的时候，通过其他方法去调用了原生 <code>dispatch</code> 的某个方法，这样很容易造成混淆，因为改变的是同一个 <code>store</code> ，在你 <code>middlewares</code> 数量多的时候，你很难去找到原因到底为什么数据不符合预期。</p>
<p>核心方法是 <code>dispatch = compose(...chain)(store.dispatch)</code> ，现在看是不是与上面Demo的 <code>compose(a,b,c)(&#39;开始迭代了&#39;)</code> 看起来一模一样？我们继续把上面的逻辑捋一遍。假如我们有两个中间件，被applyMiddleware应用，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/store/index.js</span></span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123; <span class="comment">// 打印日志</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'logger before'</span>, store.getState())</span><br><span class="line">  <span class="keyword">const</span> returnValue = next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'logger after'</span>, store.getState())</span><br><span class="line">  <span class="keyword">return</span> returnValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handlerPrice = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123; <span class="comment">// 给每次新增的商品价格补小数位</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'action: '</span>, action);</span><br><span class="line">  action = &#123;</span><br><span class="line">    ...action,</span><br><span class="line">    data:&#123;</span><br><span class="line">      ...action.data,</span><br><span class="line">      shopPrice:action.data.shopPrice + <span class="string">'.00'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> returnValue = next(action)</span><br><span class="line">  <span class="keyword">return</span> returnValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configStore</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> composeEnhancer = <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;</span><br><span class="line">  <span class="keyword">const</span> store = createStore(</span><br><span class="line">    ShopState,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    composeEnhancer(applyMiddleware(logger,handlerPrice))) ------ enhancer</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>enhancer</code> 最终会返回一个增强函数，我们再看一遍<code>applyMiddleware</code>的源码，得出<code>applyMiddleware(logger,handlerPrice)</code> 执行后将会得到一个增强器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(store); next(action) &#125;</span><br><span class="line"><span class="keyword">const</span> handlerPrice = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(store); next(action) &#125;</span><br><span class="line">middlewares = [logger, handlerPrice]</span><br><span class="line">enhancer = <span class="function">(<span class="params">createStore</span>) =&gt;</span> <span class="function">(<span class="params">reducer, preloadedState, enhancer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化store</span></span><br><span class="line">    <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer)</span><br><span class="line">    <span class="comment">// 保存初始化的dispatch指针</span></span><br><span class="line">    <span class="keyword">var</span> dispatch = store.dispatch</span><br><span class="line">    <span class="keyword">var</span> chain = []</span><br><span class="line">      <span class="comment">// 暂存改造前的store</span></span><br><span class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将store传入，等待 logger(store) 返回的 next =&gt; action =&gt; next(action)</span></span><br><span class="line">    <span class="comment">// 通过闭包，每个中间件得到的都是同一个store即middlewareAPI。这样就保证了数据的迭代变化</span></span><br><span class="line">    chain = [logger, handlerPrice].map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    <span class="comment">/* 每次middleware(middlewareAPI) 应用中间件，都相当于 logger(store)一次，store也随之改变，返回两个next形参函数</span></span><br><span class="line"><span class="comment">    * [next =&gt; action =&gt; &#123; console.log(store); next(action) &#125;,// logger</span></span><br><span class="line"><span class="comment">    *  next =&gt; action =&gt; &#123; console.log(store); next(action) &#125;] // handlerPrice</span></span><br><span class="line"><span class="comment">    * 随之两个中间件等待被compose, 每个都可以单独访问next/dispatch前后的store</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line">    <span class="comment">// 先将所有的中间件compose合并，然后将store.dispatch作为next形数传入，得到每个action =&gt; store.dispatch(action)</span></span><br><span class="line">    <span class="comment">// 也就行上文的 next(action) === store.dispatch(action)</span></span><br><span class="line">    <span class="comment">// 最终抛出一个compose后的增强dispatch与store</span></span><br><span class="line">    <span class="comment">// 返回改造后的store</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现逻辑是通过<code>next(action)</code> 处理和传递 <code>action</code> 直到 <code>redux</code> 原生的 <code>dispatch</code> 接收处理。</p>
<p>我们回到之前的 <code>src/redux/createStore.js</code> 的 <code>return enhancer(createStore)(reducer, preloadedState)</code> ，如果看不懂的话这里可以分解成两步</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">const</span> enhancedCreateStore = enhancer(createStore) <span class="comment">//----增强的createStore函数</span></span><br><span class="line"><span class="number">2.</span><span class="keyword">return</span> enhancedCreateStore(reducer, preloadedState)</span><br></pre></td></tr></table></figure>

<p>此时将<code>createStore</code>传入，<code>enhancer(createStore)</code>后得到一个<code>enhancedCreateStore()</code>生成器。</p>
<p>也就是上文中的 <code>{...store,dispatch}</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enhancerStore = <span class="function">(<span class="params">reducer, preloadedState, enhancer</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略若干代码</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...store,</span><br><span class="line">    dispatch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时执行第2步再将<code>enhancerStore(reducer, preloadedState)</code>传入…………</p>
<p><img src="https://static.yuanziwen.cn/blog/reduxCode/2.png_plain" alt="alt"></p>
<p>然后就通过调用此时的dispatch达到一样的效果，上面已经介绍的很详细了，如果不熟悉的话，建议多看几遍。</p>
<p>三番四次扯到中间件，到底是什么东西？</p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>中间件说起来也不陌生，至于什么是中间件，维基百科的解释大家自行查找，本来只有一个词不懂，看了 Wiki 变成七八个词不懂。</p>
<p>在 JavaScript 里不管是前端还是 Node，都涉及颇广</p>
<blockquote>
<p>Ps：<code>Redux</code> 的 <code>middleware</code> 与 <code>koa</code> 流程机制不完全一样。具体的区别可以参考 Perkin 的 <a href="http://perkinzone.cn/2017/08/15/Redux,Koa,Express%E4%B9%8Bmiddleware%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94/" target="_blank" rel="noopener">Redux,Koa,Express之middleware机制对比</a>，本段 <code>koa</code> 内容已隐藏，同学们可选择性去了解。</p>
</blockquote>
<p>首先了解下 <code>Redux</code> 的 <code>middleware</code> ，正常流程上来说，和 <code>koa</code> 是一致的，但是如果在某个正在执行的 <code>middleware</code> 里派发 <code>action</code>，那么将会立即“中断” 并且重置当前 <code>dispatch</code><br><img src="https://static.yuanziwen.cn/blog/reduxCode/3.png_plain" alt="alt"><br>栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">store</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    next(action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handlerPrice = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  <span class="comment">// 禁止直接调用原生store.dispatch,在知道副作用的情况下加条件执行，否则程序将崩溃</span></span><br><span class="line">  <span class="comment">// 如果你想派发其他的任务，可以使用next()，此时next等价于dispatch</span></span><br><span class="line">  store.dispatch(&#123;<span class="attr">type</span>: <span class="string">'anything'</span> &#125;)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> enhancer = applyMiddleware(logger, handlerPrice)</span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">    ShopState,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    composeEnhancer(enhancer,handlerPrice))</span><br><span class="line"><span class="comment">// 结果无限循环的1和3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这是怎么做到的？我们来看，在 <code>store.dispatch({type: &#39;anything&#39; })</code> 的时候，此时的 <code>store</code> 表面子上看还是原生的，但实际上 <code>store === middlewareAPI // false</code> ，Why ?</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/redux/applyMiddleware.js</span></span><br><span class="line"><span class="keyword">let</span> dispatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">    <span class="string">'Dispatching while constructing your middleware is not allowed. '</span> +</span><br><span class="line">      <span class="string">'Other middleware would not be applied to this dispatch.'</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 暂存改造前的store</span></span><br><span class="line"><span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">  getState: store.getState,</span><br><span class="line">  dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args) <span class="comment">//--- 保存了dispatch的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">dispatch = compose(...chain)(store.dispatch) <span class="comment">// --- dispatch被改变</span></span><br></pre></td></tr></table></figure>

<p><code>dispatch</code> 最后的引用就是 <code>compose(...chain)(store.dispatch)</code> ，换句话说 <code>store.dispatch</code> 就是一次 middleWare Loop …</p>
<p>这样就能解释上面的代码了，<code>store.dispatch({type:&#39;anything&#39;})</code>其实就是从头又调了一遍中间件…</p>
<details>
    <summary>接下来是Koa的栗子，你可以了解或者跳过</summary>


<p>借Koa代码一阅，在 <a href="https://codesandbox.io/s/clever-hofstadter-dfcon" target="_blank" rel="noopener">SandBoxCode</a> 上手动尝试</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="https://static.yuanziwen.cn/blog/reduxCode/4.png_plain" alt="alt"></p>
<p>上图被称为 <code>洋葱模型</code>，很清晰的表明了一个请求是如何经过中间件最后生成响应。</p>
<p>举一个实际的例子，你每天回到家，假设家门是个中间件，你的卧室门也是个中间件，你是一个请求。那么你必须先进家门，再进卧室的门，你想再出去就必须先出卧室的门，再出家门。需要遵守的是，你必须<code>原路倒序返回</code>。 A-&gt;B-&gt;C-&gt;B-&gt;A。不能瞎蹦跶跳窗户出去(如果你家是一楼可以走后门当我没说)</p>
<p>那么再看上面的的例子就非常简单了。<code>koa</code> 通过 <code>use</code> 方法添加中间件，每个 <code>async</code> 函数就是你的要经过的门，而 <code>next()</code> 就表示你进门的动作。这不同于JavaScript执行机制中栈，更像是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">        +----------------------------------------------------------------------------------+</span><br><span class="line">        |                                                                                  |</span><br><span class="line">        |                                 middleware <span class="number">1</span>                                     |</span><br><span class="line">        |                                                                                  |</span><br><span class="line">        |          +--------------------------next()---------------------------+           |</span><br><span class="line">        |          |                                                           |           |</span><br><span class="line">        |          |                      middleware <span class="number">2</span>                         |           |</span><br><span class="line">        |          |                                                           |           |</span><br><span class="line">        |          |            +-------------next()--------------+            |           |</span><br><span class="line">        |          |            |         middleware <span class="number">3</span>            |            |           |</span><br><span class="line">        | action   |  action    |                                 |    action  |   action  |</span><br><span class="line">        | <span class="number">001</span>      |  <span class="number">002</span>       |                                 |    <span class="number">005</span>     |   <span class="number">006</span>     |</span><br><span class="line">        |          |            |   action              action    |            |           |</span><br><span class="line">        |          |            |   <span class="number">003</span>      next()     <span class="number">004</span>       |            |           |</span><br><span class="line">        |          |            |                                 |            |           |</span><br><span class="line">+----------------------------------------------------------------------------------------------------&gt;</span><br><span class="line">        |          |            |                                 |            |           |</span><br><span class="line">        |          |            |                                 |            |           |</span><br><span class="line">        |          |            +---------------------------------+            |           |</span><br><span class="line">        |          +-----------------------------------------------------------+           |</span><br><span class="line">        +----------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

</details>

<blockquote>
<p>最后再次提示：<code>Koa</code> 与 <code>Redux</code> 的 <code>middleware</code> 机制除了特殊状态下是一致的，特殊状态：在某个 <code>middleware</code> 内调用 <code>dispatch</code></p>
</blockquote>
<h2 id="dispatch的妙用"><a href="#dispatch的妙用" class="headerlink" title="dispatch的妙用"></a>dispatch的妙用</h2><p>回到主题，我们看61行之后的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currentReducer = reducer <span class="comment">// 当前reducer对象</span></span><br><span class="line"><span class="keyword">let</span> currentState = preloadedState  <span class="comment">// 当前state对象</span></span><br><span class="line"><span class="keyword">let</span> currentListeners = [] <span class="comment">// 当前的listeners订阅者集合, 使用subscribe进行订阅</span></span><br><span class="line"><span class="keyword">let</span> nextListeners = currentListeners <span class="comment">// currentListeners 备份</span></span><br><span class="line"><span class="keyword">let</span> isDispatching = <span class="literal">false</span> <span class="comment">// dispatch状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureCanMutateNextListeners</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextListeners === currentListeners) &#123;</span><br><span class="line">      nextListeners = currentListeners.slice()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  @returns &#123;any&#125; ，获取state唯一方法，如果当前正在dispatch，就抛出一个错误，告诉</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">          <span class="string">'You may not call store.getState() while the reducer is executing. '</span> +</span><br><span class="line">          <span class="string">'The reducer has already received the state as an argument. '</span> +</span><br><span class="line">          <span class="string">'Pass it down from the top reducer instead of reading it from the store.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的错误也很直观了，懂一些逻辑或英语的人基本都能明白，很无语的是这种错误开发过程中基本没人遇到过，但是在18年底很多用chrome redux扩展程序的人遭了殃。原因应该是在初始化 的时候没有排除在INIT阶段的 <code>dispatching===true</code> 就直接去取数据，这里的报错复现只要在<code>dispatch</code>的时候去调用一次 <code>getState()</code> 就行了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/App.js</span></span><br><span class="line"><span class="keyword">const</span> addShop = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type:<span class="string">'ADD_SHOP'</span>,</span><br><span class="line">      data:&#123;</span><br><span class="line">        ...newShop,</span><br><span class="line">        fn:<span class="function"><span class="params">()</span>=&gt;</span> getState() <span class="comment">// -----添加函数准备在dispatch的期间去执行它</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/store/index</span></span><br><span class="line"><span class="comment">//...other</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'ADD_SHOP'</span>: <span class="comment">//添加商品</span></span><br><span class="line">    newState = &#123;</span><br><span class="line">      ...newState,</span><br><span class="line">      shopList:newState.shopList.concat(action.data)</span><br><span class="line">    &#125;</span><br><span class="line">    action.data.fn() <span class="comment">//----- 在这里执行</span></span><br></pre></td></tr></table></figure>

<p>或者异步去中间件获取也会得到这个错误。先来分析什么时候 <code>isDispatching === true</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// dispatch只接受一个普通对象</span></span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Actions must be plain objects. '</span> +</span><br><span class="line">        <span class="string">'Use custom middleware for async actions.'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// action type为有效参数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Actions may not have an undefined "type" property. '</span> +</span><br><span class="line">        <span class="string">'Have you misspelled a constant?'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果当前正在dispatch，抛出警告，可能不会被派发出去，因为store还没有被change完成</span></span><br><span class="line">  <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// INIT 和 dispatch 都会触发这一步</span></span><br><span class="line">    <span class="comment">// 将当前的 reducer 和 state 以及 action 执行以达到更新State的目的</span></span><br><span class="line">    currentState = currentReducer(currentState, action)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论结果如何，先结束dispatching状态，防止阻塞下个任务</span></span><br><span class="line">    isDispatching = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新订阅者，通知遍历更新核心数据</span></span><br><span class="line">  <span class="keyword">const</span> listeners = (currentListeners = nextListeners)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> listener = listeners[i]</span><br><span class="line">    listener() <span class="comment">// 将下文的subscribe收集的订阅者通知更新</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> action <span class="comment">// 将 action 返回，在react-redux中要用到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... other 省略100行</span></span><br><span class="line">dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;) <span class="comment">//INIT store 会触发dispatch</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  dispatch,</span><br><span class="line">  subscribe,</span><br><span class="line">  getState,</span><br><span class="line">  replaceReducer,</span><br><span class="line">  [$$observable]: observable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 当然是在 <code>dispatch</code> 的时候，这是触发 <code>state change</code> 的唯一方法。首先会通过递归原型链顶层是否为<code>null</code>来区分普通对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> proto = obj</span><br><span class="line">  <span class="comment">// 递归对象的原型  终点是否为null</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Object</span>.getPrototypeOf(proto) !== <span class="literal">null</span>) &#123;</span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(obj) === proto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种检测方式和 <code>lodash</code> 几乎差不多，为什么不直接用toString.call呢？原因我认为toString的虽然可行，但是隐患太多，react想让开发者以字面量的方式创建Action，杜绝以new方式去创建action，就比如下面这种创建方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj) === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype) === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;) <span class="comment">// [object Object]</span></span><br><span class="line"><span class="comment">// but</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure>

<p>看起来也没有多难，但是我们看下redux仓库<a href="https://github.com/reduxjs/redux/blob/master/test/utils/isPlainObject.spec.js" target="_blank" rel="noopener">isPlainObject的测试用例</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> expect <span class="keyword">from</span> <span class="string">'expect'</span></span><br><span class="line"><span class="keyword">import</span> isPlainObject <span class="keyword">from</span> <span class="string">'../../src/utils/isPlainObject'</span></span><br><span class="line"><span class="keyword">import</span> vm <span class="keyword">from</span> <span class="string">'vm'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'isPlainObject'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'returns true only if plain object'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.prop = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> sandbox = &#123; <span class="attr">fromAnotherRealm</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="comment">// vm.runInNewContext (沙箱) 可以在Node环境中创建新的上下文环境运行一段 js</span></span><br><span class="line">    vm.runInNewContext(<span class="string">'fromAnotherRealm = &#123;&#125;'</span>, sandbox)</span><br><span class="line"></span><br><span class="line">    expect(isPlainObject(sandbox.fromAnotherRealm)).toBe(<span class="literal">true</span>)</span><br><span class="line">    expect(isPlainObject(<span class="keyword">new</span> Test())).toBe(<span class="literal">false</span>) <span class="comment">// ---</span></span><br><span class="line">    expect(isPlainObject(<span class="keyword">new</span> <span class="built_in">Date</span>())).toBe(<span class="literal">false</span>)</span><br><span class="line">    expect(isPlainObject([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])).toBe(<span class="literal">false</span>)</span><br><span class="line">    expect(isPlainObject(<span class="literal">null</span>)).toBe(<span class="literal">false</span>)</span><br><span class="line">    expect(isPlainObject()).toBe(<span class="literal">false</span>)</span><br><span class="line">    expect(isPlainObject(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;)).toBe(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>还有iframe、代码并非只在一个环境下运行，所以要考虑到比较多的因素，而lodash的考虑的因素更多——<a href="https://github.com/lodash/lodash/blob/4.17.5/test/test.js#L11407" target="_blank" rel="noopener">2.6w行测试用例…谨慎打开</a>，但是</p>
<p><img src="https://static.yuanziwen.cn/blog/reduxCode/5.png_plain" alt="alt"></p>
<h2 id="subscribe-添加订阅者"><a href="#subscribe-添加订阅者" class="headerlink" title="subscribe 添加订阅者"></a>subscribe 添加订阅者</h2><p>可能有些同学不太清楚订阅者模式和监听者模式的区别</p>
<h3 id="订阅-subscribe-者模式"><a href="#订阅-subscribe-者模式" class="headerlink" title="订阅(subscribe)者模式"></a>订阅(subscribe)者模式</h3><p>redux中就是使用 <code>subscribe</code> (译文订阅) , 打个比方，A告诉B，说你每次吃完饭就通知我一声，我去洗碗，被动去请求得到对方的同意，这是订阅者。B收集订阅者的时候可以去做筛选是否通知A。</p>
<h3 id="监听-listen-者"><a href="#监听-listen-者" class="headerlink" title="监听(listen)者"></a>监听(listen)者</h3><p>A不去得到B的同意，每次B吃完饭自动去洗碗，B不管他。最典型的莫过于<code>window</code>的<code>addEventListener</code>。B无法拒绝,只能通过A主动解绑。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 校验订阅函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the listener to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前派发的时候添加订阅者，抛出一个错误，因为可能已经有部分action已经dispatch掉。不能保证通知到该listener</span></span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'You may not call store.subscribe() while the reducer is executing. '</span> +</span><br><span class="line">          <span class="string">'If you would like to be notified after the store has been updated, subscribe from a '</span> +</span><br><span class="line">          <span class="string">'component and invoke store.getState() in the callback to access the latest state. '</span> +</span><br><span class="line">          <span class="string">'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...other</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要复现这个问题只需要阻塞 <code>dispatch</code> 函数中的 <code>currentState = await currentReducer(currentState, action)</code>，不改源码你可以通过上文的方法也能做到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addShop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type:<span class="string">'ADD_SHOP'</span>,</span><br><span class="line">      data:&#123;</span><br><span class="line">        ...newShop, <span class="comment">// ...商品数据</span></span><br><span class="line">        fn:<span class="function"><span class="params">()</span> =&gt;</span> subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// -----添加函数准备在dispatch的期间去执行它</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'我现在要再添加监听者'</span>) <span class="comment">// Error</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>reducer</code> change state 的时候去执行它，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/store/reducer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = ShopState, action)=&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> newState = &#123;...state&#125;</span><br><span class="line">  <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_SHOP'</span>: <span class="comment">//添加商品</span></span><br><span class="line">    newState = &#123;</span><br><span class="line">      ...newState,</span><br><span class="line">      shopList:newState.shopList.concat(action.data)</span><br><span class="line">    &#125;</span><br><span class="line">    action.data.fn() <span class="comment">//---- 执行,报错</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在中间件里调用 <code>subscribe</code> 添加订阅者也能达到相同的效果</p>
<p>当然，通过返回的函数你可以取消订阅</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listen</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...other</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isSubscribed = <span class="literal">true</span> <span class="comment">// 订阅标记</span></span><br><span class="line"></span><br><span class="line">    ensureCanMutateNextListeners() <span class="comment">// nextListener先拷贝currentListeners保存一次快照</span></span><br><span class="line">    nextListeners.push(listener) <span class="comment">// 收集此次订阅者，将在下次 dispatch 后更新该listener</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!isSubscribed) &#123; <span class="comment">// 多次解绑，已经解绑就没有必要再往下走了</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 同样，在dispatch的时候，禁止 unsubscribed 当前listener</span></span><br><span class="line">      <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">          <span class="string">'You may not unsubscribe from a store listener while the reducer is executing. '</span> +</span><br><span class="line">            <span class="string">'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      isSubscribed = <span class="literal">false</span> <span class="comment">// 标记为已经 unSubscribed</span></span><br><span class="line">      <span class="comment">// 每次unsubscribe都要深拷贝一次 currentListeners 好让nextListener拿到最新的 [listener] ，</span></span><br><span class="line">       ensureCanMutateNextListeners() <span class="comment">// 再次保存一份快照，</span></span><br><span class="line">      <span class="comment">// 再对 nextListeners(也就是下次dispatch) 取消订阅当前listener。</span></span><br><span class="line">      <span class="keyword">const</span> index = nextListeners.indexOf(listener)  </span><br><span class="line">      nextListeners.splice(index, <span class="number">1</span>)</span><br><span class="line">      currentListeners = <span class="literal">null</span> <span class="comment">// 防止污染 `ensureCanMutateNextListeners` 保存快照，使本次处理掉的listener被重用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ensureCanMutateNextListeners</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在 subscribe 和 unsubscribe 的时候，都会执行</span></span><br><span class="line">    <span class="keyword">if</span> (nextListeners === currentListeners) &#123;</span><br><span class="line">      nextListeners = currentListeners.slice()  <span class="comment">// 只有相同情况才保存快照</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> 什么是快照，假如现在有3个listener <code>[A,B,C]</code>, 遍历执行，当执行到<code>B</code>的时候(此时下标为1)，<code>B</code> 的内部触发了<code>unsubscribe</code> 取消订阅者<code>B</code>，导致变成了<code>[A,C]</code>,而此时下标再次变为2的时候，原本应该是<code>C</code>的下标此时变成了1，导致跳过C未执行。快照的作用是深拷贝当前listener，在深拷贝的listener上做事件subscribe与unSubscribe。不影响当前执行队列</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所以在dispatch的时候，需要明确将要发布哪些listener</span></span><br><span class="line"><span class="keyword">const</span> listeners = (currentListeners = nextListeners)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> listener = listeners[i]</span><br><span class="line">    listener()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次 <code>dispatch()</code> 调用之前都会保存一份快照。当你在正在调用监听器 <code>listener</code> 的时候订阅 <code>subscribe</code> 或者去掉订阅 <code>unsubscribe</code>，都会对当前队列<code>[A,B,C]</code>没有任何影响，你影响的只有下次 <code>dispatch</code> 后的listener。</p>
<blockquote>
<p><code>currentListeners</code> 为当前的 <code>listener</code>, <code>nextListeners</code> 为下次 <code>dispatch</code> 后才发布的订阅者集合</p>
</blockquote>
<p>我们模拟下使用场景</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cancelSub = subscribe(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(getState().shopList.length&gt;<span class="number">10</span>) cancelSub() <span class="comment">// 商品数量超过10个的时候，放弃订阅更新</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>首先，假设目前有0个商品，</p>
<ul>
<li>我们先通过<code>ensureCanMutateNextListeners</code>更新现有 <code>currentListener</code> 给 <code>nextListener</code>(下回合的<code>[listeners]</code>)，</li>
<li>将 <code>subscribe</code> 订阅的事件收集到<code>nextListeners</code>,不影响当前 <code>CurrentListener</code> 的发布更新，</li>
<li>我们得到一个<code>cancelSub:unsubscribe</code> 闭包函数，该函数可以取消订阅</li>
<li>前10次正常发布更新，</li>
<li>在第11次执行的时候，商品数量增加到了11个</li>
<li>逻辑命中 <code>cancelSub:unsubscribe</code> 函数被调用，<code>isSubscribed</code>被标记为0，表示当前事件已经被<code>unSubscribed</code>。</li>
<li>再次保存一份快照，<code>nextListener</code> 为下次 <code>dispatch</code> 后的<code>[listeners]</code>。</li>
<li>在 <code>nextListener</code> 上将当前 <code>listener</code> 移除。</li>
<li>置空 currentListeners ，清除缓存，防止污染 <code>ensureCanMutateNextListeners</code> 保存快照，使本次处理的listener被重用</li>
</ul>
<h2 id="replaceReducer-动态注入"><a href="#replaceReducer-动态注入" class="headerlink" title="replaceReducer 动态注入"></a>replaceReducer 动态注入</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算reducer，动态注入</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the nextReducer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentReducer = nextReducer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This action has a similiar effect to ActionTypes.INIT.</span></span><br><span class="line">    <span class="comment">// Any reducers that existed in both the new and old rootReducer</span></span><br><span class="line">    <span class="comment">// will receive the previous state. This effectively populates</span></span><br><span class="line">    <span class="comment">// the new state tree with any relevant data from the old one.</span></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: ActionTypes.REPLACE &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>结合路由能做到按需加载reducers，在项目工程较小的时候体验不到这种优化，但是如果工程庞大的时候，<code>initialState</code> 和 <code>dispatch</code> 其实是很耗性能的一件事，几十个 <code>Reducer</code> 包含了成百上千个 <code>switch</code> ，难道一个个去case？</p>
<p>多个<code>dispatch</code> 上千次case 的情景你可以想象一下。无从下手的性能优化或许可以在这上面帮你一把。今天就带你了解一下 <code>reducer</code> 的“按需加载”，官方称它为动态注入。</p>
<p>通常用来配合 webpack 实现 HMR <code>hot module replacement</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/store/reducers.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; connectRouter &#125; <span class="keyword">from</span> <span class="string">'connect-react-router'</span></span><br><span class="line"><span class="keyword">import</span> userReducer <span class="keyword">from</span> <span class="string">'@/store/user/reducer'</span></span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="function"><span class="params">history</span> =&gt;</span> combineReducers(&#123;</span><br><span class="line">    ...userReducer,</span><br><span class="line">    router:connectRouter(history)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/store/index.js</span></span><br><span class="line"><span class="keyword">import</span> RootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">preloadState</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(RootReducer,preloadState,enhancer)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">module</span>.hot)&#123;</span><br><span class="line">        <span class="built_in">module</span>.hot.accpet(<span class="string">'./reducers'</span>,()=&gt;&#123; <span class="comment">// 热替换 reducers.js</span></span><br><span class="line">            <span class="keyword">const</span> hotRoot = RootReducer(history) <span class="comment">// require语法引入则需要加.default</span></span><br><span class="line">            store.replaceReducer(hotRoot)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现reducer按需加载"><a href="#实现reducer按需加载" class="headerlink" title="实现reducer按需加载"></a>实现reducer按需加载</h3><p>关于路由按需加载reducer，可以参考如下思路，写了个Demo，可以在<a href="https://codesandbox.io/s/react-redux-hbu3v" target="_blank" rel="noopener">SandBoxCode</a>上尝试效果，去掉了其他代码，功能简洁，以说明思路和实现功能为主</p>
<p><img src="https://static.yuanziwen.cn/blog/reduxCode/13.png_plain" alt></p>
<ul>
<li>Home、Index等同名文件为新增的 <code>store</code> 和 <code>views</code> 关联 </li>
<li><code>injectAsyncReducer</code>封装动态替换方法，供 <code>PrivateRoute</code> 调用，</li>
<li><code>reducers.js</code> CombineReducers</li>
<li><code>ProviteRoute</code> Code Spliting 与 执行生成 <code>AsyncReducers</code> 替换动作<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/store/reducer.js 合并Reducers</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> publicState <span class="keyword">from</span> <span class="string">'store/Public'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createReducer</span>(<span class="params">asyncReducers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> combineReducers(&#123;</span><br><span class="line">   public: publicState, </span><br><span class="line">    ...asyncReducers <span class="comment">// 异步Reducer</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/store/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'../redux/index.js'</span>;</span><br><span class="line"><span class="keyword">import</span> createReducer <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configStore</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = createStore(createReducer(),initialState);</span><br><span class="line">  store.asyncReducers = &#123;&#125;; <span class="comment">//  隔离防止对store其他属性的修改</span></span><br><span class="line">  <span class="comment">// 动态替换方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">injectAsyncReducer</span>(<span class="params">store, name, asyncReducer</span>) </span>&#123;</span><br><span class="line">    store.asyncReducers[name] = asyncReducer;</span><br><span class="line">    store.replaceReducer(createReducer(store.asyncReducers));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    store,</span><br><span class="line">    injectAsyncReducer</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/router/PrivateRoute.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; lazy, Suspense &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> loadable <span class="keyword">from</span> <span class="string">'@loadable/component'</span>; <span class="comment">// Code-spliting 也可以使用Suspense+lazy</span></span><br><span class="line"><span class="keyword">import</span> &#123; Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PrivateRoute = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; injectAsyncReducer, store &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> withReducer = <span class="keyword">async</span> (name) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 规定views和store关联文件首字母大写</span></span><br><span class="line">    <span class="keyword">const</span> componentDirName = name.replace(<span class="regexp">/^\S/</span>, s =&gt; s.toUpperCase()); </span><br><span class="line">    <span class="keyword">const</span> reducer = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`../store/<span class="subst">$&#123;componentDirName&#125;</span>/index`</span>);<span class="comment">// 引入reducer</span></span><br><span class="line">    injectAsyncReducer(store, name, reducer.default);<span class="comment">// 替换操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">`../views/<span class="subst">$&#123;componentDirName&#125;</span>`</span>); <span class="comment">// 返回组件</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Switch&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Route &#123;...props&#125; exact path='/</span><span class="string">' name='</span>main<span class="string">' component=&#123;lazy(() =&gt; withReducer('</span>main<span class="string">'))&#125; /&gt;</span></span><br><span class="line"><span class="string">        &lt;Route &#123;...props&#125; exact path='</span>/home<span class="string">' name='</span>home<span class="string">' component=&#123;lazy(() =&gt; withReducer('</span>home<span class="string">'))&#125;/&gt;</span></span><br><span class="line"><span class="string">        &lt;Route &#123;...props&#125; exact path='</span>/user<span class="string">' name='</span>user<span class="string">' component=&#123;lazy(() =&gt; withReducer('</span>user<span class="string">'))&#125;/&gt;</span></span><br><span class="line"><span class="string">        &lt;Route &#123;...props&#125; exact path='</span>/shopList<span class="string">' name='</span>shopList<span class="string">' component=&#123;lazy(() =&gt; withReducer('</span>shopList<span class="string">'))&#125;/&gt;</span></span><br><span class="line"><span class="string">      &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">    &lt;/Suspense&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">export default PrivateRoute;</span></span><br></pre></td></tr></table></figure>

<p>这只是一个按需提供reducer的demo。最后的效果</p>
<p><img src="https://static.yuanziwen.cn/blog/reduxCode/6.png_plain" alt></p>
<h2 id="observable"><a href="#observable" class="headerlink" title="observable"></a>observable</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> outerSubscribe = subscribe;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      subscribe(observer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> observer !== <span class="string">'object'</span> || observer === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Expected the observer to be an object.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">observeState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (observer.next) &#123;</span><br><span class="line">            observer.next(getState()); <span class="comment">// 将数据同步返回</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        observeState();</span><br><span class="line">        <span class="keyword">const</span> unsubscribe = outerSubscribe(observeState);  </span><br><span class="line">        <span class="keyword">return</span> &#123; unsubscribe &#125;; <span class="comment">// 解绑事件</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      [$$observable]() &#123; <span class="comment">// 通过symbol-observable创建全局唯一的观察者</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是为Rxjs准备的, 用来观察对象做出相应的响应处理。</p>
<blockquote>
<p>observable原本在ReactiveX中，一个观察者(Observer)订阅一个可观察对象(Observable)。观察者对Observable发射的数据或数据序列作出响应。这种模式可以极大地简化并发操作，因为它创建了一个处于待命状态的观察者哨兵，在未来某个时刻响应Observable的通知，不需要阻塞等待Observable发射数据。</p>
</blockquote>
<p>在实际业务中并未使用到，如果有兴趣的可以参考</p>
<ul>
<li><a href="https://juejin.im/post/5bc318b25188255c5f5414e7" target="_blank" rel="noopener">更好用的 Redux</a></li>
<li><a href="https://segmentfault.com/a/1190000005051034" target="_blank" rel="noopener">RxJs 核心概念之Observable</a></li>
</ul>
<p>至此，createStore.js完结，大哥大都走过了，还有几个小菜鸡你还怕么？</p>
<h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><p><code>combineReducers</code>用来将若干个reducer合并成一个reducers，使用方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">combineReducers(&#123;</span><br><span class="line">    key:<span class="function">(<span class="params">state = &#123;&#125;, action</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;,</span><br><span class="line">    post:<span class="function">(<span class="params">state = &#123;&#125;, action</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>176行源码码大半部分全都是用来校验数据、抛错。</p>
<p>首当其冲是两个辅助函数，用来 “友好” 的抛出提示信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUndefinedStateErrorMessage</span>(<span class="params">key, action</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果任意一个 reducer 返回的state undefined 会踩到这个雷</span></span><br><span class="line">  <span class="keyword">const</span> actionType = action &amp;&amp; action.type;</span><br><span class="line">  <span class="keyword">const</span> actionDescription =</span><br><span class="line">    (actionType &amp;&amp; <span class="string">`action "<span class="subst">$&#123;<span class="built_in">String</span>(actionType)&#125;</span>"`</span>) || <span class="string">'an action'</span>;</span><br><span class="line">    <span class="comment">// 即使没有值应该返回null，而不要返回undefined</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="string">`Given <span class="subst">$&#123;actionDescription&#125;</span>, reducer "<span class="subst">$&#123;key&#125;</span>" returned undefined. `</span> +</span><br><span class="line">    <span class="string">`To ignore an action, you must explicitly return the previous state. `</span> +</span><br><span class="line">    <span class="string">`If you want this reducer to hold no value, you can return null instead of undefined.`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUnexpectedStateShapeWarningMessage</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  inputState,</span></span></span><br><span class="line"><span class="function"><span class="params">  reducers,</span></span></span><br><span class="line"><span class="function"><span class="params">  action,</span></span></span><br><span class="line"><span class="function"><span class="params">  unexpectedKeyCache</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers);</span><br><span class="line">  <span class="comment">// 辨认此次操作来源是来自内部初始化还是外部调用，大部分都是后者</span></span><br><span class="line">  <span class="keyword">const</span> argumentName = action &amp;&amp; action.type === ActionTypes.INIT  </span><br><span class="line">    ? <span class="string">'preloadedState argument passed to createStore'</span></span><br><span class="line">    : <span class="string">'previous state received by the reducer'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (reducerKeys.length === <span class="number">0</span>) &#123; <span class="comment">// 合并成空的reducers也会报错</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="string">'Store does not have a valid reducer. Make sure the argument passed '</span> +</span><br><span class="line">      <span class="string">'to combineReducers is an object whose values are reducers.'</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(inputState)) &#123; <span class="comment">// state必须是个普通对象</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="string">`The <span class="subst">$&#123;argumentName&#125;</span> has unexpected type of "`</span> +</span><br><span class="line">      &#123;&#125;.toString.call(inputState).match(<span class="regexp">/\s([a-z|A-Z]+)/</span>)[<span class="number">1</span>] +</span><br><span class="line">      <span class="string">`". Expected argument to be an object with the following `</span> +</span><br><span class="line">      <span class="string">`keys: "<span class="subst">$&#123;reducerKeys.join(<span class="string">'", "'</span>)&#125;</span>"`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 过滤 state 与 finalReducers(也就是combineReducer定义时的有效 reducers)，</span></span><br><span class="line">  <span class="comment">// 拿到 state 多余的key值,比如 combineReducer 合并2个，但最后返回了3个对象</span></span><br><span class="line">  <span class="keyword">const</span> unexpectedKeys = <span class="built_in">Object</span>.keys(inputState).filter(</span><br><span class="line">    key =&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key]</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 标记警告这个值</span></span><br><span class="line">  unexpectedKeys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    unexpectedKeyCache[key] = <span class="literal">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 辨别来源，replaceReducers表示设置此次替代Reducer，可以被忽略</span></span><br><span class="line">  <span class="keyword">if</span> (action &amp;&amp; action.type === ActionTypes.REPLACE) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 告诉你有什么值是多出来的，会被忽略掉</span></span><br><span class="line">  <span class="keyword">if</span> (unexpectedKeys.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="string">`Unexpected <span class="subst">$&#123;unexpectedKeys.length &gt; <span class="number">1</span> ? <span class="string">'keys'</span> : <span class="string">'key'</span>&#125;</span> `</span> +</span><br><span class="line">      <span class="string">`"<span class="subst">$&#123;unexpectedKeys.join(<span class="string">'", "'</span>)&#125;</span>" found in <span class="subst">$&#123;argumentName&#125;</span>. `</span> +</span><br><span class="line">      <span class="string">`Expected to find one of the known reducer keys instead: `</span> +</span><br><span class="line">      <span class="string">`"<span class="subst">$&#123;reducerKeys.join(<span class="string">'", "'</span>)&#125;</span>". Unexpected keys will be ignored.`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个辅助函数 <code>assertReducerShape</code> 用来判断初始化和随机状态下返回的是不是 <code>undefined</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertReducerShape</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(reducers).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历 reducer</span></span><br><span class="line">    <span class="keyword">const</span> reducer = reducers[key];</span><br><span class="line">    <span class="comment">// 初始化该 reducer，得到一个state值</span></span><br><span class="line">    <span class="keyword">const</span> initialState = reducer(<span class="literal">undefined</span>, &#123; <span class="attr">type</span>: ActionTypes.INIT &#125;);</span><br><span class="line">    <span class="comment">// 所以一般reducer写法都是 export default (state=&#123;&#125;,action)=&gt;&#123; return state&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果针对INIT有返回值，其他状态没有仍然是个隐患</span></span><br><span class="line">    <span class="comment">// 再次传入一个随机的 action ，二次校验。判断是否为 undefined</span></span><br><span class="line">    <span class="keyword">const</span> unknown = reducer(<span class="literal">undefined</span>, &#123; <span class="attr">type</span>: ActionTypes.PROBE_UNKNOWN_ACTION() &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化状态下 state 为 undefined =&gt; 踩雷</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">`Reducer "<span class="subst">$&#123;key&#125;</span>" returned undefined during initialization. `</span> +</span><br><span class="line">          <span class="string">`If the state passed to the reducer is undefined, you must `</span> +</span><br><span class="line">          <span class="string">`explicitly return the initial state. The initial state may `</span> +</span><br><span class="line">          <span class="string">`not be undefined. If you don't want to set a value for this reducer, `</span> +</span><br><span class="line">          <span class="string">`you can use null instead of undefined.`</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机状态下 为 undefined  =&gt; 踩雷</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> unknown === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">`Reducer "<span class="subst">$&#123;key&#125;</span>" returned undefined when probed with a random type. `</span> +</span><br><span class="line">          <span class="string">`Don't try to handle <span class="subst">$&#123;ActionTypes.INIT&#125;</span> or other actions in "redux/*" `</span> +</span><br><span class="line">          <span class="string">`namespace. They are considered private. Instead, you must return the `</span> +</span><br><span class="line">          <span class="string">`current state for any unknown actions, unless it is undefined, `</span> +</span><br><span class="line">          <span class="string">`in which case you must return the initial state, regardless of the `</span> +</span><br><span class="line">          <span class="string">`action type. The initial state may not be undefined, but can be null.`</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>辅助打野都解决了，切输出吧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers);</span><br><span class="line">  <span class="keyword">const</span> finalReducers = &#123;&#125;;<span class="comment">// 收集有效的reducer</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = reducerKeys[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个reducerKey 的 reducer是 undefined</span></span><br><span class="line">        warning(<span class="string">`No reducer provided for key "<span class="subst">$&#123;key&#125;</span>"`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// reducer必须是函数，无效的数据不会被合并进来</span></span><br><span class="line">      finalReducers[key] = reducers[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 所有可用reducer</span></span><br><span class="line">  <span class="keyword">const</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is used to make sure we don't warn about the same</span></span><br><span class="line">  <span class="comment">// keys multiple times.</span></span><br><span class="line">  <span class="keyword">let</span> unexpectedKeyCache; <span class="comment">// 配合getUnexpectedStateShapeWarningMessage辅助函数过滤掉多出来的值</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    unexpectedKeyCache = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> shapeAssertionError;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    assertReducerShape(finalReducers);<span class="comment">//校验reducers是否都是有效数据</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    shapeAssertionError = e; <span class="comment">// 任何雷都接着</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个合并后的 reducers 函数，与普通的 reducer 一样</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shapeAssertionError) &#123;</span><br><span class="line">      <span class="keyword">throw</span> shapeAssertionError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">// 开发环境下校验有哪些值是多出来的</span></span><br><span class="line">      <span class="keyword">const</span> warningMessage = getUnexpectedStateShapeWarningMessage(</span><br><span class="line">        state,</span><br><span class="line">        finalReducers,</span><br><span class="line">        action,</span><br><span class="line">        unexpectedKeyCache</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (warningMessage) &#123;</span><br><span class="line">        warning(warningMessage);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hasChanged = <span class="literal">false</span>; <span class="comment">// mark值是否被改变</span></span><br><span class="line">    <span class="keyword">const</span> nextState = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = finalReducerKeys[i]; <span class="comment">// reducerKey</span></span><br><span class="line">      <span class="keyword">const</span> reducer = finalReducers[key]; <span class="comment">// 对应的 reducer</span></span><br><span class="line">      <span class="keyword">const</span> previousStateForKey = state[key]; <span class="comment">// 改变之前的 state</span></span><br><span class="line">      <span class="comment">// 对每个reducer 做 dispatch，拿到 state 返回值</span></span><br><span class="line">      <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> nextStateForKey === <span class="string">'undefined'</span>) &#123; <span class="comment">// 如果state是undefined就准备搞事情</span></span><br><span class="line">        <span class="keyword">const</span> errorMessage = getUndefinedStateErrorMessage(key, action);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errorMessage);</span><br><span class="line">      &#125;</span><br><span class="line">      nextState[key] = nextStateForKey; <span class="comment">// 收录这个reducer</span></span><br><span class="line">      <span class="comment">// 检测是否被改变过</span></span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有值被改变，就返回原先的值，避免性能损耗</span></span><br><span class="line">    <span class="keyword">return</span> hasChanged ? nextState : state;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这部分较于简单，就直接过吧。</p>
<h2 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h2><p><code>bindActionCreators</code> 由父组件申明，传递给子组件直接使用，让子组件感受不到redux的存在，当成普通方法调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以import * 传入的</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> TodoActionCreators <span class="keyword">from</span> <span class="string">'./ActionCreators'</span></span><br><span class="line"><span class="keyword">const</span> todoAction = bindActionCreators(TodoActionCreators, dispatch) <span class="comment">//绑定TodoActionCreators上所有的action</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通状态</span></span><br><span class="line"><span class="keyword">import</span> &#123; addTodoItem, removeTodoItem &#125; <span class="keyword">from</span> <span class="string">'./ActionCreators'</span></span><br><span class="line"><span class="keyword">const</span> todoAction = bindActionCreators(&#123; addTodoItem, removeTodoItem &#125;, dispatch)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">todoAction.addTodoItem(args) <span class="comment">//直接调用</span></span><br><span class="line">todoAction.removeTodoItem(args)</span><br></pre></td></tr></table></figure>

<p>翻到源码，除去注释就只有30行不到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用apply将action进行this显示绑定</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(actionCreator.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreators</span>(<span class="params">actionCreators, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是函数直接绑定this</span></span><br><span class="line">    <span class="keyword">return</span> bindActionCreator(actionCreators, dispatch);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators !== <span class="string">'object'</span> || actionCreators === <span class="literal">null</span>) &#123; <span class="comment">// 校验 action</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">`bindActionCreators expected an object or a function, instead received <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        actionCreators === <span class="literal">null</span> ? <span class="string">'null'</span> : <span class="keyword">typeof</span> actionCreators</span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span>. `</span> +</span><br><span class="line">        <span class="string">`Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> boundActionCreators = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 如果是以import * as actions 方式引入的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> actionCreators) &#123;</span><br><span class="line">    <span class="keyword">const</span> actionCreator = actionCreators[key];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 就遍历成一个普通对象，其action继续处理this显示绑定</span></span><br><span class="line">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> boundActionCreators; <span class="comment">// 将绑定后的actions返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>在这里分享一些遇到的问题和技巧</p>
<h2 id="怎么管理大量的reducer、action、constants？"><a href="#怎么管理大量的reducer、action、constants？" class="headerlink" title="怎么管理大量的reducer、action、constants？"></a>怎么管理大量的reducer、action、constants？</h2><p>在一般中型项目中通常会遇到这种问题：<br>代码里存在大量的 <code>constants</code> 常量和 <code>actions</code> 冗余代码</p>
<p><img src="https://static.yuanziwen.cn/blog/reduxCode/7.png_plain" alt></p>
<p>然后又跑到 <code>shop/reducers</code> 又定义一遍，这点量还是少的，要是遇到大型项目就蛋疼了，<code>reducer</code> <code>action</code> <code>constants</code> 三个文件来回切，两个屏幕都不够切的。虽然可以用 <code>import * as types</code> 方式全部引入，但是在业务组件里还是得这样写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bindActionCreators <span class="keyword">from</span> <span class="string">'../redux/bindActionCreators'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shop <span class="keyword">from</span> <span class="string">'store/ShopList/actionCreators'</span>; <span class="comment">// 所有的action</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bindActionCreators(shop, dispatch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要么全部引用，你肯定不喜欢这样做，要么一个一个引用，但是嫌麻烦。孰轻孰重？</p>
<p>优雅是要靠牺牲可读性换来的，问题回归到本质，为什么要这么做呢？ 明确分工？利于查找？统一管理？协同规范？跟随主流？</p>
<p>只要利于开发，利于维护，利于协同就够了。</p>
<p>所以从业务关联的reducer入手，将 <code>reducer</code> 和 <code>action</code> 合并起来，每个业务单独作为一个 reducer 文件管理。每个 <code>reducer</code> 只针对一个业务。形式有点像“按需加载”。</p>
<p><img src="https://static.yuanziwen.cn/blog/reduxCode/8.png_plain" alt="alt"></p>
<p><code>shop&gt;store</code> 内的负责所有 <code>reducer</code> 及 <code>action</code> 的创建。每个文件单独负责一块内容业务。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; </span><br><span class="line">  ADD_SHOP_BEGIN, </span><br><span class="line">  ADD_SHOP_FAIL, </span><br><span class="line">  ADD_SHOP_SUCCESS, </span><br><span class="line">  ADD_SHOP_FINALLY</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../constants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addShopBegin = <span class="function">(<span class="params">payload</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: ADD_SHOP_BEGIN,</span><br><span class="line">  payload</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addShopSuccess = <span class="function">(<span class="params">payload</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: ADD_SHOP_SUCCESS,</span><br><span class="line">  payload</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addShopFail = <span class="function">(<span class="params">payload</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: ADD_SHOP_FAIL,</span><br><span class="line">  payload</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addShopFinally = <span class="function">(<span class="params">payload</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: ADD_SHOP_FINALLY,</span><br><span class="line">  payload</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span> (<span class="params">state = &#123; &#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newState = &#123; ...state &#125;;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">  <span class="keyword">case</span> ADD_SHOP_BEGIN:</span><br><span class="line">    newState = &#123;</span><br><span class="line">      ...newState,</span><br><span class="line">      hasLoaded: !newState.hasLoaded</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// begin doSomething</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ADD_SHOP_SUCCESS:</span><br><span class="line">    <span class="comment">// successful doSomething</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ADD_SHOP_FAIL:</span><br><span class="line">    <span class="comment">// failed doSomething</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ADD_SHOP_FINALLY:</span><br><span class="line">    <span class="comment">// whether doSomething</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的好处是不用在两个文件间来回切换，业务逻辑比较清晰，方便测试。</p>
<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p><code>shop</code> 模块子业务的 <code>actions.js</code> 则负责整合所有的 <code>action</code> 导出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; addShopBegin, addShopSuccess, addShopFail, addShopFinally &#125; <span class="keyword">from</span> <span class="string">'./store/add'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; deleteShopBegin, deleteShopSuccess, deleteShopFail, deleteShopFinally &#125; <span class="keyword">from</span> <span class="string">'./store/delete'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; changeShopBegin, changeShopSuccess, changeShopFail, changeShopFinally &#125; <span class="keyword">from</span> <span class="string">'./store/change'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; searchShopBegin, searchShopSuccess, searchShopFail, searchShopFinally &#125; <span class="keyword">from</span> <span class="string">'./store/search'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="constants"><a href="#constants" class="headerlink" title="constants"></a>constants</h3><p>仍然负责上面所有的常量管理，但只在业务子模块的<code>store</code> 内被引入</p>
<h3 id="reducers"><a href="#reducers" class="headerlink" title="reducers"></a>reducers</h3><p>整合该业务模块的所有 <code>reducer</code>，创建核心 <code>reducer</code> 进行遍历，这里核心的一点是怎么去遍历所有的reducer。上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> addShop &#125; <span class="keyword">from</span> <span class="string">'./store/add'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> removeShop &#125; <span class="keyword">from</span> <span class="string">'./store/delete'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> changeShop &#125; <span class="keyword">from</span> <span class="string">'./store/change'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> searchShop &#125; <span class="keyword">from</span> <span class="string">'./store/search'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shopReducer = [ <span class="comment">// 整合reducer</span></span><br><span class="line">  addShop, </span><br><span class="line">  removeShop, </span><br><span class="line">  changeShop, </span><br><span class="line">  searchShop</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> initialState = &#123;</span><br><span class="line">  hasLoaded: <span class="literal">false</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = initialState, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> newState = &#123; ...state &#125;; </span><br><span class="line">  <span class="comment">// 对所有reducer进行迭代。类似于compose</span></span><br><span class="line">  <span class="keyword">return</span> shopReducer.reduce(<span class="function">(<span class="params">preReducer, nextReducer</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextReducer(preReducer, action)</span><br><span class="line">          , newState);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>文件数量多的话要配合webpack的<code>optimization.splitChunks</code>进行文件分割合并，这里不做过多赘述。</p>
<h3 id="store-reducers-js"><a href="#store-reducers-js" class="headerlink" title="store/reducers.js"></a>store/reducers.js</h3><p>在全局store内的reducers直接引用就可以了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'../redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connectRouter &#125; <span class="keyword">from</span> <span class="string">'connected-react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> history <span class="keyword">from</span> <span class="string">'router/history'</span>;</span><br><span class="line"><span class="keyword">import</span> publicState <span class="keyword">from</span> <span class="string">'store/Public'</span>;</span><br><span class="line"><span class="keyword">import</span> shopOperation <span class="keyword">from</span> <span class="string">'./Shop/reducers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createReducer</span>(<span class="params">asyncReducers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> combineReducers(&#123;</span><br><span class="line">    router: connectRouter(history),</span><br><span class="line">    shop: shopOperation,</span><br><span class="line">    public: publicState,</span><br><span class="line">    ...asyncReducers<span class="comment">// 异步Reducer</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="业务组件内调用"><a href="#业务组件内调用" class="headerlink" title="业务组件内调用"></a>业务组件内调用</h3><p>业务组件内和正常调用即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; addShopBegin &#125; <span class="keyword">from</span> <span class="string">'store/Shop/actions'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'../redux/index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; changeLoaded &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Home Page&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; changeLoaded(false)&#125;&gt;changeLoaded&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function mapDispatchToProps(dispatch) &#123;</span></span><br><span class="line"><span class="regexp">  return bindActionCreators(&#123; changeLoaded: addShopBegin &#125;, dispatch);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default connect(null, mapDispatchToProps)(Home);</span></span><br></pre></td></tr></table></figure>

<h2 id="react-如何查看每个组件渲染性能"><a href="#react-如何查看每个组件渲染性能" class="headerlink" title="react 如何查看每个组件渲染性能"></a>react 如何查看每个组件渲染性能</h2><p>你可能会用chrome performance的火焰图去查看整个网站的渲染时机和性能，网上教程也一大堆。</p>
<p><img src="https://static.yuanziwen.cn/blog/reduxCode/9.png_plain" alt="alt"></p>
<ul>
<li>紫色的代表style样式计算/layout</li>
<li>黄色代表js操作</li>
<li>蓝色代表html解析</li>
<li>灰色代表其他操作</li>
<li>红色框里代表这个地方存在 强制回流 、long task、FPS低、CPU 占用过多</li>
</ul>
<p>虽然知道总体性能，但是没有更详细的组件渲染周期，你不知道有哪些组件被多次重渲染，占用主线程过长，是否存在性能。这时候，你可以点击上图左侧的Timings。</p>
<p><img src="https://static.yuanziwen.cn/blog/reduxCode/10.png_plain" alt></p>
<p>通过这个，你能知道那些组件被重渲染哪些被挂载、销毁、重建及更新。合理运用 Time Slicing + Suspense 异步渲染。</p>
<blockquote>
<p>Chrome 独有的原生Api <code>requestIdleCallback</code>。可以在告诉浏览器，当你不忙(Cpu占用较低)的时候执行这个回调函数，类似于script标签的async 。<br>如果要考虑兼容性的话还是用web Worker来做一些优先级较低的任务。</p>
</blockquote>
<p>现在 Chrome Mac 版本 React Devtools 也有自己的performance了 <a href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" target="_blank" rel="noopener">官方传送门</a></p>
<h2 id="why-did-you-update"><a href="#why-did-you-update" class="headerlink" title="why-did-you-update"></a>why-did-you-update</h2><p>用React刚开始写的组件基本不合规范，尤其是组件嵌套使用的时候，同级组件更新引起的不必要组件更新，导致无意义的 <code>render</code> ，当然，使用React Hooks的时候这个问题尤其严重，性能可行的情况下视觉看不出来差异，当组件复杂度量级化时候，性能损耗就体现出来了。</p>
<p>只需要在主文件里调用，建议加上环境限制，会有点卡</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> whyDidYouUpdate <span class="keyword">from</span> <span class="string">'why-did-you-update'</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  whyDidYouUpdate(React);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://static.yuanziwen.cn/blog/reduxCode/11.png_plain" alt="alt"></p>
<p>它会提示你前后值是否相同，是否改变过。是不是很神奇？</p>
<blockquote>
<p>其大致原理是将 <code>React.Component.prototype.componentDidUpdate</code> 覆盖为一个新的函数，在其中进行了每次渲染前后的 <code>props</code> 的深度比较，并将结果以友好直观的方式呈现给用户。但它有一个明显的缺陷——如果某一组件定义了 <code>componentDidUpdate</code> 方法， <code>why-did-you-update</code> 就失效了。<a href="https://zhuanlan.zhihu.com/p/48059589" target="_blank" rel="noopener">参考文献</a></p>
</blockquote>
<p>拿到结果，分析原因，合理使用 <code>memo/PureComponent</code> 优化纯组件，将组件进一步细分。 <code>useMemo/reselect</code> 缓存计算结果。对于一些可以异步加载的组件可以使用 <code>React.lazy</code> 或 <code>@loadable/component</code> code Spliting 。 避免不必要的 <code>render</code> 性能损耗。</p>
<p>这也是 <code>Immutable</code> 因而诞生的一点，通过不可变数据结构，避免了数据流被更改无所谓的触发changed。</p>
<p>至此 Redux 源码完整版刨析完毕。</p>
<p>由于 <code>react-redux</code> 增加了hooks等功能，后续会出另一篇文章，持续学习。共勉！</p>
<p>文中所有 <a href="https://github.com/yzw7489757/react-middleware" target="_blank" rel="noopener">源码备注仓库</a></p>
<p>参考文献</p>
<ul>
<li><a href="https://github.com/fi3ework/blog/issues/7" target="_blank" rel="noopener">通过Github Blame深入分析Redux源码</a></li>
</ul>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="blog.yuanziwen.cn">Seven</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="blog.yuanziwen.cn/2019/04/01/彻底刨析-Redux-源码/">blog.yuanziwen.cn/2019/04/01/彻底刨析-Redux-源码/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/Redux/">Redux</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2019/04/14/译-从-0-创建自定义元素/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">[译] 从 0 创建自定义元素</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2019/03/13/d3数据可视化/">
        <span class="next-text nav-default">d3数据可视化(2)——折线图篇</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'cxeaTV5BFDCxPmxoCcG9QPxf-gzGzoHsz',
        appKey: 's577OrPG5sB4Szom6mvHuI1X',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info: guest,
        pageSize:'10' || 10,
    });
  </script>

<footer id="footer" class="footer"><div class="social-links"><a href="mailto:yuanziwen7489757@gmail.com" class="iconfont icon-email" title="email"></a>
          <a href="https://juejin.im/user/59aa31a06fb9a02485103ddf" class="iconfont juejin" title="掘金"><div class="img"></div></a>
        <a href="https://github.com/yzw7489757" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <!--<span class="division">|</span>
  <span class="theme-info">
    footer.theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>-->
  <span class="power-by">
   <a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备18011257号-1</a>
  </span>
  <span class="copyright-year">&copy;2017 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Seven</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
<script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js?t=1593502596546')
    .then(function () {console.log('ServiceWorker Register Successfully.')})
    .catch(function (e) {console.error(e)});
}
</script></body>
</html>
