<!DOCTYPE html>
<html lang="zh-Hans">
  <head><meta name="generator" content="Hexo 3.9.0"><link rel="manifest" href="/manifest.json"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="转载掘金：你还是只会npm install？"><meta name="keywords" content="Seven YuanZiWen"><link rel="alternate" href="/atom.xml" title="Seven Blog"><link rel="shortcut icon" type="image/x-icon" href="https://static.yuanziwen.cn/blog/favicon.ico?v=2.11.0">
<link rel="canonical" href="blog.yuanziwen.cn/2018/03/28/转载：你还是只会npm-install/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1e4ffaffd9b2bc832b39e2b866a92c7b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>转载掘金：你还是只会npm install？ - Seven Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Seven Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Record
          </li>
      </a><a href="/music/">
        <li class="mobile-menu-item">Music(NoAuto)
          </li>
      </a><a href="/photo/">
        <li class="mobile-menu-item">Album
          </li>
      </a><a href="/book/">
        <li class="mobile-menu-item">Book
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Seven Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Record
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/music/">
            Music(NoAuto)
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/photo/">
            Album
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/book/">
            Book
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">转载掘金：你还是只会npm install？
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-28
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#npm-init"><span class="toc-text">npm init</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#npm-init-执行默认行为"><span class="toc-text">npm init 执行默认行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义-npm-init-行为"><span class="toc-text">自定义 npm init 行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#依赖包安装"><span class="toc-text">依赖包安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#package定义"><span class="toc-text">package定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安装本地包-远程git仓库包"><span class="toc-text">安装本地包/远程git仓库包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#npm-install-如何工作-——-node-modules-目录结构"><span class="toc-text">npm install 如何工作 —— node_modules 目录结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#npm-2"><span class="toc-text">npm 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npm-3-扁平结构"><span class="toc-text">npm 3 - 扁平结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npm-5-package-lock-文件"><span class="toc-text">npm 5 - package-lock 文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#依赖包版本管理"><span class="toc-text">依赖包版本管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#semver"><span class="toc-text">semver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖版本升级"><span class="toc-text">依赖版本升级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最佳实践"><span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#npm-scripts"><span class="toc-text">npm scripts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本使用"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node-modules-bin-目录"><span class="toc-text">node_modules/.bin 目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npx"><span class="toc-text">npx</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#npm-配置"><span class="toc-text">npm 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#npm-config"><span class="toc-text">npm config</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npmrc-文件"><span class="toc-text">npmrc 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node-版本约束"><span class="toc-text">node 版本约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结-npm-最佳实践"><span class="toc-text">小结 npm 最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多资料"><span class="toc-text">更多资料</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文档"><span class="toc-text">文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#延伸阅读"><span class="toc-text">延伸阅读</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.2.1/css/hint.min.css"><p><img src="https://static.yuanziwen.cn/npmInstall.png_plain" alt="alt"><br>Nodejs 社区乃至 Web 前端工程化领域发展到今天，作为 node 自带的包管理工具的 npm 已经成为每个前端开发者必备的工具。但是现实状况是，我们很多人对这个nodejs基础设施的使用和了解还停留在: 会用 <span class="codes">npm install</span> 这里（一言不合就删除整个 <span class="codes">node_modules</span> 目录然后重新 <span class="codes">install</span> 这种事你没做过吗？）<br>当然 npm 能成为现在世界上最大规模的包管理系统，很大程度上确实归功于它足够用户友好，你看即使我只会执行 install 也不必太担心出什么大岔子. 但是 npm 的功能远不止于 install 一下那么简单，这篇文章帮你扒一扒那些你可能不知道的 npm 原理、特性、技巧，以及（我认为的）最佳实践。</p>
<a id="more"></a>

<h2 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h2><p>我们都知道 <span class="codes">package.json</span> 文件是用来定义一个 <span class="codes">package</span> 的描述文件, 也知道<span class="codes">npm init</span> 命令用来初始化一个简单的<span class="codes"> package.json</span> 文件，执行该命令后终端会依次询问 <span class="codes">name</span>, <span class="codes">version</span>, <span class="codes">description</span> 等字段。</p>
<h3 id="npm-init-执行默认行为"><a href="#npm-init-执行默认行为" class="headerlink" title="npm init 执行默认行为"></a>npm init 执行默认行为</h3><p> 而如果想要偷懒步免去一直按 <span class="codes">enter</span>，在命令后追加 <span class="codes">–yes</span> 参数即可，其作用与一路下一步相同。</p>
<blockquote><p><span class="codes">-S</span>就是<span class="codes">–save</span> 包会放在<span class="codes">dependencies</span>  仅用于生产/线上环境</p>
</blockquote>
<blockquote><p><span class="codes">-D</span>就是<span class="codes">–save-dev</span> 包会放在<span class="codes">devDependencies</span>  仅用于开发环境</p>
</blockquote>

<h3 id="自定义-npm-init-行为"><a href="#自定义-npm-init-行为" class="headerlink" title="自定义 npm init 行为"></a>自定义 npm init 行为</h3><p><span class="codes">npm init</span> 命令的原理并不复杂，调用脚本，输出一个初始化的 <span class="codes">package.json</span> 文件就是了。所以相应地，定制 <span class="codes">npm init</span> 命令的实现方式也很简单，在 <span class="codes">Home</span> 目录创建一个 <span class="codes">.npm-init.js</span> 即可，该文件的 <span class="codes">module.exports</span> 即为 <span class="codes">package.json</span> 配置内容，需要获取用户输入时候，使用 <span class="codes">prompt()</span> 方法即可。<br>例如编写这样的 <span class="codes">~/.npm-init.js</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> desc = prompt(<span class="string">'description?'</span>, <span class="string">'A new package...'</span>)</span><br><span class="line"><span class="keyword">const</span> bar = prompt(<span class="string">'bar?'</span>, <span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> count = prompt(<span class="string">'count?'</span>, <span class="string">'42'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  key: <span class="string">'value'</span>,</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: bar,</span><br><span class="line">    count: count</span><br><span class="line">  &#125;,</span><br><span class="line">  name: prompt(<span class="string">'name?'</span>, process.cwd().split(<span class="string">'/'</span>).pop()),</span><br><span class="line">  version: prompt(<span class="string">'version?'</span>, <span class="string">'0.1.0'</span>),</span><br><span class="line">  description: desc,</span><br><span class="line">  main: <span class="string">'index.js'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时在 <span class="codes">~/hello</span> 目录下执行 <span class="codes">npm init</span> 将会得到这样的 <span class="codes">package.json</span>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"key"</span>: <span class="string">"value"</span>,</span><br><span class="line">  <span class="string">"foo"</span>: &#123;</span><br><span class="line">    <span class="string">"bar"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="string">"count"</span>: <span class="string">"42"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"hello"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"A new package..."</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了生成 <span class="codes">package.json</span>, 因为 <span class="codes">.npm-init.js</span> 是一个常规的模块，意味着我们可以执行随便什么 <span class="codes">node</span> 脚本可以执行的任务。例如通过 <span class="codes">fs</span> 创建 <span class="codes">README</span>, <span class="codes">.eslintrc</span> 等项目必需文件，实现项目脚手架的作用.</p>
<h2 id="依赖包安装"><a href="#依赖包安装" class="headerlink" title="依赖包安装"></a>依赖包安装</h2><p>依赖管理是 <span class="codes">npm</span> 的核心功能，原理就是执行 <span class="codes">npm install</span> 从 <span class="codes">package.json</span> 中的 <span class="codes">dependencies</span>, <span class="codes">devDependencies</span> 将依赖包安装到当前目录的 <span class="codes">./node_modules</span> 文件夹中。</p>
<h3 id="package定义"><a href="#package定义" class="headerlink" title="package定义"></a>package定义</h3><p>我们都知道要手动安装一个包时，执行 <code class="codes">npm install &lt;package&gt;</code> 命令即可。这里的第三个参数 <span class="codes">package</span> 通常就是我们所要安装的包名，默认配置下 <span class="codes">npm</span> 会从默认的源 <span class="codes">(Registry)</span> 中查找该包名对应的包地址，并下载安装。但在 <span class="codes">npm</span> 的世界里，除了简单的指定包名, <span class="codes">package</span> 还可以是一个指向有效包名的 <span class="codes">http url/git url/</span>文件夹路径。<br>阅读 <span class="codes">npm</span>的文档， 我们会发现<span class="codes">package</span> 准确的定义，只要符合以下 <span class="codes">a)</span> 到 <span class="codes">g)</span> 其中之一条件，就是一个 <span class="codes">package</span>:<table><tr><th>#</th><th>说明</th><th>例子</th></tr><tr><td>a)</td><td>一个包含了程序和描述该程序的 <span class="codes">package.json</span> 文件 的 文件夹</td><td><span class="codes">./local-module/</span></td></tr><tr><td>b)</td><td>一个包含了 <span class="codes">(a)</span> 的 <span class="codes">gzip</span> 压缩文件</td><td><span class="codes">./module.tar.gz</span></td></tr><tr><td>c)</td><td>一个可以下载得到 (b) 资源的 <span class="codes">url</span> (通常是 <span class="codes">http(s) url</span>)</td><td><span class="codes">https ://registry.npmjs.org/webpack/-/webpack-4.1.0.tgz</span></td></tr><tr><td>d)</td><td>一个格式为 <span class="codes">&lt;name&gt;</span>@<span class="codes">&lt;version&gt;</span> 的字符串，可指向 <span class="codes">npm</span> 源(通常是官方源 <span class="codes">npmjs.org</span>)上已发布的可访问 url，且该 url 满足条件 (c)</td><td><span class="codes">webpack@ 4.1.0</span></td></tr><tr><td>e)</td><td>一个格式为 <span class="codes">&lt;name&gt;</span>@<span class="codes">&lt;tag&gt;</span> 的字符串，在 npm 源上该<span class="codes">&lt;tag&gt;</span>指向某<span class="codes">&lt;version&gt; 得到<span class="codes">&lt;name&gt;</span>@<span class="codes">&lt;version&gt;</span>，后者满足条件 (d)</span></td><td><span class="codes">webpack@latest</span></td></tr><tr><td>f)</td><td>一个格式为<span class="codes">&lt;name&gt;</span> 的字符串，默认添加 <span class="codes">latest</span> 标签所得到的<span class="codes">&lt;name&gt;@latest</span> 满足条件 (e)</td><td><span class="codes">webpack</span></td></tr><tr><td>g)</td><td>一个 <span class="codes">git url</span>, 该 <span class="codes">url</span> 所指向的代码库满足条件 <span class="codes">(a)</span></td><td><span class="codes">git@ github.com:webpack/webpack.git</span></td></tr></table></p>
<h3 id="安装本地包-远程git仓库包"><a href="#安装本地包-远程git仓库包" class="headerlink" title="安装本地包/远程git仓库包"></a>安装本地包/远程git仓库包</h3><p>上面表格的定义意味着，我们在共享依赖包时，并不是非要将包发表到 npm 源上才可以提供给使用者来安装。这对于私有的不方便 <span class="codes">publish</span> 到远程源（即使是私有源），或者需要对某官方源进行改造，但依然需要把包共享出去的场景来说非常实用。<br>场景1: 本地模块引用<br>nodejs 应用开发中不可避免有模块间调用，例如在实践中经常会把需要被频繁引用的配置模块放到应用根目录；于是在创建了很多层级的目录、文件后，很可能会遇到这样的代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../../../../config.js'</span>);</span><br></pre></td></tr></table></figure>

<p>除了看上去很丑以外，这样的路径引用也不利于代码的重构。并且身为程序员的自我修养告诉我们，这样重复的代码多了也就意味着是时候把这个模块分离出来供应用内其他模块共享了。例如这个例子里的 <span class="codes">config.js</span> 非常适合封装为 <span class="codes">package</span> 放到 <span class="codes">node_modules</span> 目录下，共享给同应用内其他模块。无需手动拷贝文件或者创建软链接到 <span class="codes">node_modules</span> 目录，<span class="codes">npm</span> 有更优雅的解决方案。</p>
<p>方案：</p>
<p>1.创建 config 包:<br>新增 config 文件夹; 重命名 <span class="codes">config.js</span> 为 <span class="codes">config/index.js</span> 文件; 创建 <span class="codes">package</span> 定义 <span class="codes">config</span> 包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"config"</span>,</span><br><span class="line">    <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.1.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在应用层 <span class="codes">package</span> 文件中新增依赖项，然后执行 <span class="codes">npm install</span>; 或直接执行第 3 步</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">        <span class="string">"config"</span>: <span class="string">"file:./config"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.（等价于第 2 步）直接在应用目录执行 <span class="codes">npm install</span> <span class="codes">file:./config</span><br>此时，查看 <span class="codes">node_modules</span> 目录我们会发现多出来一个名为 <span class="codes">config</span>，指向上层 <span class="codes">config/</span> 文件夹的软链接。这是因为 <span class="codes">npm</span> 识别 <span class="codes">file: 协议的url</span>，得知这个包需要直接从文件系统中获取，会自动创建软链接到 <span class="codes">node_modules</span> 中，完成“安装”过程。<br>相比手动软链，我们既不需要关心 <span class="codes">windows</span> 和 <span class="codes">linux</span> 命令差异，又可以显式地将依赖信息固化到 <span class="codes">dependencies</span> 字段中，开发团队其他成员可以执行 <span class="codes">npm install</span> 后直接使用。</p>
<p>场景2: 私有 git 共享 package<br>有些时候，我们一个团队内会有一些代码/公用库需要在团队内不同项目间共享，但可能由于包含了敏感内容，或者代码太烂拿不出手等原因，不方便发布到源。<br>这种情况下，我们可以简单地将被依赖的包托管在私有的 <span class="codes">git</span> 仓库中，然后将该  <span class="codes">git url</span> 保存到 <span class="codes">dependencies</span> 中. <span class="codes">npm</span> 会直接调用系统的 <span class="codes">git</span> 命令从 <span class="codes">git</span> 仓库拉取包的内容到 <span class="codes">node_modules</span> 中</p>
<p>npm 支持的 git url 格式:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;protocol&gt;:<span class="comment">//[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:][/]&lt;path&gt;[#&lt;commit-ish&gt; | #semver:&lt;semver&gt;]</span></span><br></pre></td></tr></table></figure>

<p>git 路径后可以使用 # 指定特定的 git branch/commit/tag, 也可以 #semver: 指定特定的 semver range.</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git+ssh:<span class="comment">//git@github.com:npm/npm.git#v1.0.27</span></span><br><span class="line">git+ssh:<span class="comment">//git@github.com:npm/npm#semver:^5.0</span></span><br><span class="line">git+https:<span class="comment">//isaacs@github.com/npm/npm.git</span></span><br><span class="line">git:<span class="comment">//github.com/npm/npm.git#v1.0.27</span></span><br></pre></td></tr></table></figure>

<p>场景3: 开源 package 问题修复<br>使用某个 npm 包时发现它有某个严重bug，但也许最初作者已不再维护代码了，也许我们工作紧急，没有足够的时间提 <span class="codes">issue</span> 给作者再慢慢等作者发布新的修复版本到 npm 源。<br>此时我们可以手动进入 <span class="codes">node_modules</span> 目录下修改相应的包内容，也许修改了一行代码就修复了问题。但是这种做法非常不明智！</p>
<p>首先 <span class="codes">node_modules</span> 本身不应该放进版本控制系统，对 <span class="codes">node_modules</span>  文件夹中内容的修改不会被记录进 git 提交记录；其次，就算我们非要反模式，把 <span class="codes">node_modules</span> 放进版本控制中，你的修改内容也很容易在下次 team 中某位成员执行 <span class="codes">npm install</span> 或 <span class="codes">npm update</span> 时被覆盖，而这样的一次提交很可能包含了几十几百个包的更新，你自己所做的修改很容易就被淹没在庞大的 diff 文件列表中了。</p>
<p>方案:<br>最好的办法应当是 fork 原作者的 git 库，在自己所属的 repo 下修复问题后，将 dependencies 中相应的依赖项更改为自己修复后版本的 git url 即可解决问题。（Fork 代码库后，也便于向原作者提交 PR 修复问题。上游代码库修复问题后，再次更新我们的依赖配置也不迟。）</p>
<h2 id="npm-install-如何工作-——-node-modules-目录结构"><a href="#npm-install-如何工作-——-node-modules-目录结构" class="headerlink" title="npm install 如何工作 —— node_modules 目录结构"></a>npm install 如何工作 —— node_modules 目录结构</h2><p><span class="codes">npm install</span> 执行完毕后，我们可以在 <span class="codes">node_modules</span> 中看到所有依赖的包。虽然使用者无需关注这个目录里的文件夹结构细节，只管在业务代码中引用依赖包即可，但了解 <span class="codes">node_modules</span> 的内容可以帮我们更好理解 npm 如何工作，了解从 <span class="codes">npm 2</span> 到 <span class="codes">npm 5</span> 有哪些变化和改进。<br>为简单起见，我们假设应用目录为 app, 用两个流行的包 <span class="codes">webpack</span>, <span class="codes">nconf</span> 作为依赖包做示例说明。并且为了正常安装，使用了“上古” <span class="codes">npm 2</span> 时期的版本 <span class="codes">webpack @1.15.0</span>, <span class="codes">nconf @0.8.5</span>.</p>
<h3 id="npm-2"><a href="#npm-2" class="headerlink" title="npm 2"></a>npm 2</h3><p>npm 2 在安装依赖包时，采用简单的递归安装方法。执行 <span class="codes">npm install</span> 后，npm 2 依次递归安装 webpack 和 nconf 两个包到 <span class="codes">node_modules</span> 中。执行完毕后，我们会看到 ./<span class="codes">node_modules</span> 这层目录只含有这两个子目录。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node_modules/</span><br><span class="line">├── nconf/</span><br><span class="line">└── webpack/</span><br></pre></td></tr></table></figure>

<p>进入更深一层 nconf 或 webpack 目录，将看到这两个包各自的 <span class="codes">node_modules</span> 中，已经由 npm 递归地安装好自身的依赖包。包括 ./<span class="codes">node_modules/webpack/node_modules/webpack-core</span> , ./<span class="codes">node_modules/conf/node_modules/async</span> 等等。而每一个包都有自己的依赖包，每个包自己的依赖都安装在了自己的 <span class="codes">node_modules</span> 中。依赖关系层层递进，构成了一整个依赖树，这个依赖树与文件系统中的文件结构树刚好层层对应。<br>最方便的查看依赖树的方式是直接在 app 目录下执行 <span class="codes">npm ls</span> 命令。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app@<span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">├─┬ nconf@<span class="number">0.8</span><span class="number">.5</span></span><br><span class="line">│ ├── <span class="keyword">async</span>@<span class="number">1.5</span><span class="number">.2</span></span><br><span class="line">│ ├── ini@<span class="number">1.3</span><span class="number">.5</span></span><br><span class="line">│ ├── secure-keys@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│ └── yargs@<span class="number">3.32</span><span class="number">.0</span></span><br><span class="line">└─┬ webpack@<span class="number">1.15</span><span class="number">.0</span></span><br><span class="line">  ├── acorn@<span class="number">3.3</span><span class="number">.0</span></span><br><span class="line">  ├── <span class="keyword">async</span>@<span class="number">1.5</span><span class="number">.2</span></span><br><span class="line">  ├── clone@<span class="number">1.0</span><span class="number">.3</span></span><br><span class="line">  ├── ...</span><br><span class="line">  ├── optimist@<span class="number">0.6</span><span class="number">.1</span></span><br><span class="line">  ├── supports-color@<span class="number">3.2</span><span class="number">.3</span></span><br><span class="line">  ├── tapable@<span class="number">0.1</span><span class="number">.10</span></span><br><span class="line">  ├── uglify-js@<span class="number">2.7</span><span class="number">.5</span></span><br><span class="line">  ├── watchpack@<span class="number">0.2</span><span class="number">.9</span></span><br><span class="line">  └─┬ webpack-core@<span class="number">0.6</span><span class="number">.9</span></span><br><span class="line">    ├── source-list-map@<span class="number">0.1</span><span class="number">.8</span></span><br><span class="line">    └── source-map@<span class="number">0.4</span><span class="number">.4</span></span><br></pre></td></tr></table></figure>

<p>这样的目录结构优点在于层级结构明显，便于进行傻瓜式的管理:<br>1.例如新装一个依赖包，可以立即在第一层 <span class="codes">node_modules</span> 中看到子目录<br>2.在已知所需包名和版本号时，甚至可以从别的文件夹手动拷贝需要的包到 <span class="codes">node_modules</span> 文件夹中，再手动修改 <span class="codes">package</span> 中的依赖配置<br>3.要删除这个包，也可以简单地手动删除这个包的子目录，并删除 <span class="codes">package</span> 文件中相应的一行即可</p>
<p>实际上，很多人在 npm 2 时代也的确都这么实践过，的确也都可以安装和删除成功，并不会导致什么差错。<br>但这样的文件结构也有很明显的问题：<br>1.对复杂的工程, <span class="codes">node_modules</span> 内目录结构可能会太深，导致深层的文件路径过长而触发 windows 文件系统中，文件路径不能超过 260 个字符长的错误<br>2.部分被多个包所依赖的包，很可能在应用 <span class="codes">node_modules</span> 目录中的很多地方被重复安装。随着工程规模越来越大，依赖树越来越复杂，这样的包情况会越来越多，造成大量的冗余。<br>——在我们的示例中就有这个问题，webpack 和 nconf 都依赖 async 这个包，所以在文件系统中，webpack 和 nconf 的 <span class="codes">node_modules</span> 子目录中都安装了相同的 async 包，并且是相同的版本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+-------------------------------------------+</span><br><span class="line">|                   app/                    |</span><br><span class="line">+----------+------------------------+-------+</span><br><span class="line">           |                        |</span><br><span class="line">           |                        |</span><br><span class="line">+----------v------+       +---------v-------+</span><br><span class="line">|                 |       |                 |</span><br><span class="line">|  webpack@<span class="number">1.15</span><span class="number">.0</span> |       |  nconf@<span class="number">0.8</span><span class="number">.5</span>    |</span><br><span class="line">|                 |       |                 |</span><br><span class="line">+--------+--------+       +--------+--------+</span><br><span class="line">         |                         |</span><br><span class="line">   +-----v-----+             +-----v-----+</span><br><span class="line">   |<span class="keyword">async</span>@<span class="number">1.5</span><span class="number">.2</span>|             |<span class="keyword">async</span>@<span class="number">1.5</span><span class="number">.2</span>|</span><br><span class="line">   +-----------+             +-----------+</span><br></pre></td></tr></table></figure>

<h3 id="npm-3-扁平结构"><a href="#npm-3-扁平结构" class="headerlink" title="npm 3 - 扁平结构"></a>npm 3 - 扁平结构</h3><p>主要为了解决以上问题，npm 3 的 <span class="codes">node_modules</span> 目录改成了更加扁平状的层级结构。文件系统中 webpack, nconf, async 的层级关系变成了平级关系，处于同一级目录中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------+</span><br><span class="line">         |                   app/                    |</span><br><span class="line">         +-+---------------------------------------+-+</span><br><span class="line">           |                                       |</span><br><span class="line">           |                                       |</span><br><span class="line">+----------v------+    +-------------+   +---------v-------+</span><br><span class="line">|                 |    |             |   |                 |</span><br><span class="line">|  webpack@<span class="number">1.15</span><span class="number">.0</span> |    | <span class="keyword">async</span>@<span class="number">1.5</span><span class="number">.2</span> |   |  nconf@<span class="number">0.8</span><span class="number">.5</span>    |</span><br><span class="line">|                 |    |             |   |                 |</span><br><span class="line">+-----------------+    +-------------+   +-----------------+</span><br></pre></td></tr></table></figure>

<p>虽然这样一来 webpack/<span class="codes">node_modules</span> 和 nconf/<span class="codes">node_modules</span> 中都不再有 async 文件夹，但得益于 node 的模块加载机制，他们都可以在上一级 <span class="codes">node_modules</span> 目录中找到 async 库。所以 <span class="codes">webpack</span> 和 <span class="codes">nconf</span> 的库代码中 <span class="codes">require(‘async’)</span> 语句的执行都不会有任何问题。<br>这只是最简单的例子，实际的工程项目中，依赖树不可避免地会有很多层级，很多依赖包，其中会有很多同名但版本不同的包存在于不同的依赖层级，对这些复杂的情况, <span class="codes">npm 3</span> 都会在安装时遍历整个依赖树，计算出最合理的文件夹安装方式，使得所有被重复依赖的包都可以去重安装。</p>
<blockquote><p>假如 <span class="codes">package{dep}</span> 写法代表包和包的依赖，那么 <span class="codes">A{B,C}</span>, <span class="codes">B{C}</span>, <span class="codes">C{D}</span> 的依赖结构在安装之后的 <span class="codes">node_modules</span> 是这样的结构： </p>
</blockquote>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">+-- B</span><br><span class="line">+-- C</span><br><span class="line">+-- D</span><br></pre></td></tr></table></figure>

<p>这里之所以 <span class="codes">D</span> 也安装到了与 <span class="codes">B</span> <span class="codes">C</span> 同一级目录，是因为 npm 会默认会在无冲突的前提下，尽可能将包安装到较高的层级。</p>
<blockquote><p>如果是 A{B,C}, B{C,D@1}, C{D@2} 的依赖关系，得到的安装后结构是： </p>
</blockquote>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">+-- B</span><br><span class="line">+-- C</span><br><span class="line">   <span class="string">`-- D@2</span></span><br><span class="line"><span class="string">+-- D@1</span></span><br></pre></td></tr></table></figure>

<blockquote><p>PS: 与本地依赖包不同，如果我们通过 <span class="codes">npm install</span> –global 全局安装包到全局目录时，得到的目录依然是“传统的”目录结构。而如果使用 npm 3 想要得到“传统”形式的本地 <span class="codes">node_modules</span> 目录，使用 <span class="codes">npm install –global-style</span> 命令即可。 </p>
</blockquote>
<p>这里是因为，对于 <span class="codes">npm</span> 来说同名但不同版本的包是两个独立的包，而同层不能有两个同名子目录，所以其中的 <span class="codes">D@2</span> 放到了 <span class="codes">C</span> 的子目录而另一个 <span class="codes">D@1</span> 被放到了再上一层目录。<br>很明显在 <span class="codes">npm 3</span> 之后 <span class="codes">npm</span> 的依赖树结构不再与文件夹层级一一对应了。想要查看 <span class="codes">app</span> 的直接依赖项，要通过 <span class="codes">npm ls</span> 命令指定 <span class="codes">–depth</span> 参数来查看：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm ls --depth <span class="number">1</span></span><br></pre></td></tr></table></figure>

<span class="codes">

<h3 id="npm-5-package-lock-文件"><a href="#npm-5-package-lock-文件" class="headerlink" title="npm 5 - package-lock 文件"></a>npm 5 - package-lock 文件</h3><p>npm 5 发布于 2017 年也是目前最新的 npm 版本，这一版本依然沿用 npm 3 之后扁平化的依赖包安装方式，此外最大的变化是增加了 <span class="codes">package-lock.json</span> 文件。<br><span class="codes">package-lock.json</span> 的作用是锁定依赖安装结构，如果查看这个 json 的结构，会发现与 <span class="codes">node_modules</span> 目录的文件层级结构是一一对应的。<br>以依赖关系为: app{webpack} 的 ‘app’ 项目为例, 其 package-lock 文件包含了这样的片段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>:  <span class="string">"app"</span>,</span><br><span class="line">    <span class="string">"version"</span>:  <span class="string">"0.1.0"</span>,</span><br><span class="line">    <span class="string">"lockfileVersion"</span>:  <span class="number">1</span>,</span><br><span class="line">    <span class="string">"requires"</span>:  <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">        <span class="comment">// ... 其他依赖包</span></span><br><span class="line">        <span class="string">"webpack"</span>: &#123;</span><br><span class="line">            <span class="string">"version"</span>: <span class="string">"1.8.11"</span>,</span><br><span class="line">            <span class="string">"resolved"</span>: <span class="string">"https://registry.npmjs.org/webpack/-/webpack-1.8.11.tgz"</span>,</span><br><span class="line">            <span class="string">"integrity"</span>: <span class="string">"sha1-Yu0hnstBy/qcKuanu6laSYtgkcI="</span>,</span><br><span class="line">            <span class="string">"requires"</span>: &#123;</span><br><span class="line">                <span class="string">"async"</span>: <span class="string">"0.9.2"</span>,</span><br><span class="line">                <span class="string">"clone"</span>: <span class="string">"0.1.19"</span>,</span><br><span class="line">                <span class="string">"enhanced-resolve"</span>: <span class="string">"0.8.6"</span>,</span><br><span class="line">                <span class="string">"esprima"</span>: <span class="string">"1.2.5"</span>,</span><br><span class="line">                <span class="string">"interpret"</span>: <span class="string">"0.5.2"</span>,</span><br><span class="line">                <span class="string">"memory-fs"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">                <span class="string">"mkdirp"</span>: <span class="string">"0.5.1"</span>,</span><br><span class="line">                <span class="string">"node-libs-browser"</span>: <span class="string">"0.4.3"</span>,</span><br><span class="line">                <span class="string">"optimist"</span>: <span class="string">"0.6.1"</span>,</span><br><span class="line">                <span class="string">"supports-color"</span>: <span class="string">"1.3.1"</span>,</span><br><span class="line">                <span class="string">"tapable"</span>: <span class="string">"0.1.10"</span>,</span><br><span class="line">                <span class="string">"uglify-js"</span>: <span class="string">"2.4.24"</span>,</span><br><span class="line">                <span class="string">"watchpack"</span>: <span class="string">"0.2.9"</span>,</span><br><span class="line">                <span class="string">"webpack-core"</span>: <span class="string">"0.6.9"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"webpack-core"</span>: &#123;</span><br><span class="line">            <span class="string">"version"</span>: <span class="string">"0.6.9"</span>,</span><br><span class="line">            <span class="string">"resolved"</span>: <span class="string">"https://registry.npmjs.org/webpack-core/-/webpack-core-0.6.9.tgz"</span>,</span><br><span class="line">            <span class="string">"integrity"</span>: <span class="string">"sha1-/FcViMhVjad76e+23r3Fo7FyvcI="</span>,</span><br><span class="line">            <span class="string">"requires"</span>: &#123;</span><br><span class="line">                <span class="string">"source-list-map"</span>: <span class="string">"0.1.8"</span>,</span><br><span class="line">                <span class="string">"source-map"</span>: <span class="string">"0.4.4"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">                <span class="string">"source-map"</span>: &#123;</span><br><span class="line">                    <span class="string">"version"</span>: <span class="string">"0.4.4"</span>,</span><br><span class="line">                    <span class="string">"resolved"</span>: <span class="string">"https://registry.npmjs.org/source-map/-/source-map-0.4.4.tgz"</span>,</span><br><span class="line">                    <span class="string">"integrity"</span>: <span class="string">"sha1-66T12pwNyZneaAMti092FzZSA2s="</span>,</span><br><span class="line">                    <span class="string">"requires"</span>: &#123;</span><br><span class="line">                        <span class="string">"amdefine"</span>: <span class="string">"1.0.1"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//... 其他依赖包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看懂 <span class="codes">package-lock</span> 文件并不难，其结构是同样类型的几个字段嵌套起来的，主要是 <span class="codes">version</span>, <span class="codes">resolved</span>, <span class="codes">integrity</span>, <span class="codes">requires</span>, <span class="codes">dependencies</span> 这几个字段而已。</p>
<p>1.<span class="codes">version</span>, <span class="codes">resolved</span>, <span class="codes">integrity</span> 用来记录包的准确版本号、内容<span class="codes">hash</span>、安装源的，决定了要安装的包的准确“身份”信息<br>2.假设盖住其他字段，只关注文件中的 <span class="codes">dependencies</span>: {} 我们会发现，整个文件的 <span class="codes">JSON</span> 配置里的 <span class="codes">dependencies</span> 层次结构与文件系统中 <span class="codes">node_modules</span> 的文件夹层次结构是完全对照的<br>3.只关注 <span class="codes">requires</span>: {} 字段又会发现，除最外层的 <span class="codes">requires</span> 属性为 <span class="codes">true</span> 以外, 其他层的 <span class="codes">requires</span> 属性都对应着这个包的 <span class="codes">package</span> 里记录的自己的依赖项</p>
<p>因为这个文件记录了 <span class="codes">node_modules</span> 里所有包的结构、层级和版本号甚至安装源，它也就事实上提供了 “保存” <span class="codes">node_modules</span> 状态的能力。只要有这样一个 lock 文件，不管在那一台机器上执行 <span class="codes">npm install</span> 都会得到完全相同的 <span class="codes">node_modules</span> 结果。</p>
<p>这就是 package-lock 文件致力于优化的场景：在从前仅仅用 <span class="codes">package</span> 记录依赖，由于 semver range 的机制；一个月前由 A 生成的 <span class="codes">package</span> 文件，B 在一个月后根据它执行 <span class="codes">npm install</span> 所得到的 <span class="codes">node_modules</span> 结果很可能许多包都存在不同的差异，虽然 semver 机制的限制使得同一份 <span class="codes">package</span> 不会得到大版本不同的依赖包，但同一份代码在不同环境安装出不同的依赖包，依然是可能导致意外的潜在因素。</p>
<p>相同作用的文件在 <span class="codes">npm 5</span> 之前就有，称为 <span class="codes">npm shrinkwrap</span> 文件，二者作用完全相同，不同的是后者需要手动生成，而 <span class="codes">npm 5</span> 默认会在执行 <span class="codes">npm install</span> 后就生成 package-lock 文件，并且建议你提交到 <span class="codes">git/svn</span> 代码库中。</p>
<p><span class="codes">package-lock.json</span> 文件在最初 npm 5.0 默认引入时也引起了相当大的争议。在 npm 5.0 中，如果已有 <span class="codes">package-lock</span> 文件存在，若手动在 <span class="codes">package</span> 文件新增一条依赖，再执行 <span class="codes">npm install</span>, 新增的依赖并不会被安装到 <span class="codes">node_modules</span> 中, <span class="codes">package-lock.json</span> 也不会做相应的更新。这样的表现与使用者的自然期望表现不符。在 <span class="codes">npm 5.1</span> 的首个 <span class="codes">Release</span> 版本中这个问题得以修复。这个事情告诉我们，要升级，不要使用 <span class="codes">5.0</span>。</p>
<p>——但依然有反对的声音认为 <spanm class="codes">package-lock</spanm></p></span> 太复杂，对此 <span class="codes">npm</span> 也提供了禁用配置：<p></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> package-lock false</span><br></pre></td></tr></table></figure>

<h2 id="依赖包版本管理"><a href="#依赖包版本管理" class="headerlink" title="依赖包版本管理"></a>依赖包版本管理</h2><p>依赖包安装完并不意味着就万事大吉了，版本的维护和更新也很重要。这一章介绍依赖包升级管理相关知识，太长不看版本请直接跳到 [4.3 最佳实践].</p>
<h3 id="semver"><a href="#semver" class="headerlink" title="semver"></a>semver</h3><p><span class="codes">npm</span> 依赖管理的一个重要特性是采用了语义化版本 <span class="codes">(semver)</span> 规范，作为依赖版本管理方案。<br><span class="codes">semver</span> 约定一个包的版本号必须包含3个数字，格式必须为 <span class="codes">MAJOR.MINOR.PATCH</span>, 意为 主版本号.小版本号.修订版本号.</p>
<ul><li><span class="codes">MAJOR</span> 对应大的版本号迭代，做了不兼容旧版的修改时要更新 <span class="codes">MAJOR</span> 版本号</li><li><span class="codes">MINOR</span> 对应小版本迭代，发生兼容旧版API的修改或功能更新时，更新<span class="codes">MINOR版本号</span></li><li><span class="codes">PATCH</span> 对应修订版本号，一般针对修复 <span class="codes">BUG</span> 的版本号</li></ul>

<p>对于包作者（发布者），npm 要求在 <span class="codes">publish</span> 之前，必须更新版本号。<span class="codes">npm</span> 提供了 <span class="codes">npm version</span> 工具，执行 <span class="codes">npm version major|minor|patch</span> 可以简单地将版本号中相应的数字加1。</p>
<blockquote><p>如果包是一个 git 仓库，npm version 还会自动创建一条注释为更新后版本号的 git commit 和名为该版本号的 tag</p>
</blockquote>

<p>对于包的引用者来说，我们需要在 <span class="codes">dependencies</span> 中使用 <span class="codes">semver</span> 约定的 <span class="codes">semver range</span> 指定所需依赖包的版本号或版本范围。npm 提供了网站 https: //semver.npmjs.com 可方便地计算所输入的表达式的匹配范围。常用的规则示例如下表：</p>
<table><tr><th>range</th><th>含义</th><th>例子</th></tr><tr><td>^2.2.1</td><td>指定的 MAJOR 版本号下, 所有更新的版本</td><td>匹配 2.2.3, 2.3.0; 不匹配 1.0.3, 3.0.1</td></tr><tr><td>~2.2.1</td><td>指定 MAJOR.MINOR 版本号下，所有更新的版本</td><td>匹配 2.2.3, 2.2.9 ; 不匹配 2.3.0,2.4.5</td></tr><tr><td>>=2.1</td><td>版本号大于或等于 2.1.0</td><td>匹配 2.1.2, 3.1</td></tr><tr><td><=2.2< td><td>版本号小于或等于 2.2</td><td>匹配 1.0.0, 2.2.1, 2.2.11</td></=2.2<></td></tr><tr><td>1.0.0 - 2.0.0</td><td>版本号从 1.0.0 (含) 到 2.0.0 (含)</td><td>匹配 1.0.0, 1.3.4, 2.0.0</td></tr></table>
任意两条规则，通过 || 连接起来，则表示两条规则的并集:

<p>如 ^2 &gt;=2.3.1 || ^3 &gt;3.2 可以匹配:* 2.3.1, 2,8.1, 3.3.1,* 但不匹配 1.0.0, 2.2.0, 3.1.0, 4.0.0<br>PS: 除了这几种，还有如下更直观的表示版本号范围的写法:</p>
<ul><li>* 或 x 匹配所有主版本</li><li>1 或 1.x 匹配 主版本号为 1 的所有版本</li><li>1.2 或 1.2.x 匹配 版本号为 1.2 开头的所有版本</li></ul>
PPS: 在常规仅包含数字的版本号之外，semver 还允许在 MAJOR.MINOR.PATCH 后追加 - 后跟点号分隔的标签，作为预发布版本标签 - Prerelese Tags，通常被视为不稳定、不建议生产使用的版本。例如：
<ul><li>1.0.0-alpha</li><li>1.0.0-beta.1</li><li>1.0.0-rc.3</li></ul>

<p>上表中我们最常见的是 ^1.8.11 这种格式的 range, 因为我们在使用 <span class="codes">npm install</span> <package name> 安装包时，npm 默认安装当前最新版本，例如 1.8.11, 然后在所安装的版本号前加^号, 将 ^1.8.11 写入 <span class="codes">package</span> 依赖配置，意味着可以匹配 1.8.11 以上，2.0.0 以下的所有版本。</package></p>
<h3 id="依赖版本升级"><a href="#依赖版本升级" class="headerlink" title="依赖版本升级"></a>依赖版本升级</h3><p>问题来了，在安装完一个依赖包之后有新版本发布了，如何使用 npm 进行版本升级呢？——答案是简单的 <span class="codes">npm install</span> 或 <span class="codes">npm update</span>，但在不同的 npm 版本，不同的 <span class="codes">package</span>, <span class="codes">package-lock.json</span> 文件，安装/升级的表现也不同。<br>我们不妨还以 webpack 举例，做如下的前提假设:</p>
<ul><li>我们的工程项目 app 依赖 webpack</li><li>项目最初初始化时，安装了当时最新的包 webpack@1.8.0，并且 <span class="codes">package</span> 中的依赖配置为: "webpack": "^1.8.0"</li><li>当前（2018年3月） webpack 最新版本为 4.2.0, webpack 1.x 最新子版本为 1.15.0</li></ul>
如果我们使用的是 npm 3, 并且项目不含 <span class="codes">package-lock.json</span>, 那么根据 <span class="codes">node_modules</span> 是否为空，执行 <span class="codes">install/update</span> 的结果如下 (node 6.13.1, npm 3.10.10 环境下试验):
<table class="tables"><tr style="height:100px;word-wrap: break-word;word-break: normal; "><th style="width:40px;">#</th><th><span class="codes">package</span>(BEFORE)</th><th><span class="codes">node_modules</span>(BEFORE)</th><th>    command(npm3)</th><th><span class="codes">package</span>(AFTER)</th><th><span class="codes">node_modules</span>(AFTER)</th></tr><tr><td>a)</td><td>webpack:^1.8.0</td><td>webpack@1.8.0</td><td>install</td><td>webpack:^1.8.0</td><td>webpack@1.8.0</td></tr><tr><td>b)</td><td>webpack:^1.8.0    </td><td>空</td><td>install</td><td>webpack:^1.8.0</td><td>webpack@1.15.0</td></tr><tr><td>c)</td><td>webpack:^1.8.0</td><td>webpack@1.8.0</td><td>update</td><td>webpack:^1.8.0</td><td>webpack@1.15.0</td></tr><tr><td>d)</td><td>webpack:^1.8.0</td><td>空</td><td>update</td><td>webpack:^1.8.0</td><td>webpack@1.15.0</td></tr></table>
根据这个表我们可以对 npm 3 得出以下结论：
<ul><li>如果本地 <span class="codes">node_modules</span> 已安装，再次执行 install 不会更新包版本, 执行 update 才会更新; 而如果本地 <span class="codes">node_modules</span> 为空时，执行 <span class="codes">install/update</span> 都会直接安装更新包;</li><li><span class="codes">npm update</span> 总是会把包更新到符合 <span class="codes">package</span> 中指定的 semver 的最新版本号——本例中符合 ^1.8.0 的最新版本为 1.15.0</li><li>一旦给定 <span class="codes">package</span>, 无论后面执行 <span class="codes">npm install</span> 还是 update, <span class="codes">package</span> 中的 webpack 版本一直顽固地保持 一开始的 ^1.8.0 岿然不动</li></ul>
这里不合理的地方在于，如果最开始团队中第一个人安装了 webpack@1.8.0, 而新加入项目的成员, checkout 工程代码后执行 <span class="codes">npm install</span> 会安装得到不太一样的 1.15.0 版本。虽然 semver 约定了小版本号应当保持向下兼容（相同大版本号下的小版本号）兼容，但万一有不熟悉不遵循此约定的包发布者，发布了不兼容的包，此时就可能出现因依赖环境不同导致的 bug。
下面由 npm 5 带着 <span class="codes">package-lock.json</span> 闪亮登场，执行 <span class="codes">install/update</span> 的效果是这样的 (node 9.8.0, npm 5.7.1 环境下试验):
<blockquote><p>下表为表述简单，省略了包名 webpack, install 简写 i, update 简写为 up</p>
</blockquote>
<table><tr><th>#</th><th><span class="codes">package</span> (BEFORE)</th><th><span class="codes">node_modules</span> (BEFORE)</th><th>package-lock (BEFORE)</th><th>command    </th><th><span class="codes">package</span> (AFTER)</th><th><span class="codes">node_modules</span> (AFTER)</th></tr><tr><td>a)</td><td><span class="codes">^1.8.0</span></td><td>@1.8.0</td><td>@1.8.0</td><td><span class="codes">i</span></td><td><span class="codes">^1.8.0</span></td><td>@1.8.0</td></tr><tr><td>b)</td><td><span class="codes">^1.8.0</span></td><td>空</td><td>@1.8.0</td><td><span class="codes">i</span></td><td><span class="codes">^1.8.0</span></td><td>@1.8.0</td></tr><tr><td>c)</td><td><span class="codes">^1.8.0</span></td><td>@1.8.0</td><td>@1.8.0</td><td><span class="codes">up</span></td><td><span class="codes">^1.15.0</span></td><td>@1.15.0</td></tr><tr><td>d)</td><td><span class="codes">^1.8.0</span></td><td>空</td><td>@1.8.0</td><td><span class="codes">up</span></td><td><span class="codes">^1.8.0</span></td><td>@1.15.0</td></tr><tr><td>e)</td><td><span class="codes">^1.15.0</span></td><td>@1.8.0 (旧)</td><td>@1.15.0</td><td><span class="codes">i</span></td><td><span class="codes">^1.15.0</span></td><td>@1.15.0</td></tr><tr><td>f)</td><td><span class="codes">^1.15.0</span></td><td>@1.8.0 (旧)</td><td>@1.15.0</td><td><span class="codes">up</span></td><td><span class="codes">^1.15.0</span></td><td>@1.15.0</td></tr></table>
与 npm 3 相比，在安装和更新依赖版本上主要的区别为：
<ul><li>无论何时执行 install, npm 都会优先按照 package-lock 中指定的版本来安装 webpack; 避免了 npm 3 表中情形 b) 的状况;</li><li>无论何时完成安装/更新, package-lock 文件总会跟着 <span class="codes">node_modules</span> 更新 —— (因此可以视 package-lock 文件为 <span class="codes">node_modules</span> 的 JSON 表述)</li><li>已安装 <span class="codes">node_modules</span> 后若执行 <span class="codes">npm update</span>，<span class="codes">package</span> 中的版本号也会随之更改为 ^1.15.0</li></ul>
由此可见 npm 5.1 使得 <span class="codes">package</span> 和 <span class="codes">package-lock.json</span> 中所保存的版本号更加统一，解决了 npm 之前的各种问题。只要遵循好的实践习惯，团队成员可以很方便地维护一套应用代码和 <span class="codes">node_modules</span> 依赖都一致的环境。
皆大欢喜。

<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>总结起来，在 2018 年 (node 9.8.0, npm 5.7.1) 时代，我认为的依赖版本管理应当是:</p>
<ul><li>使用 npm: >=5.1 版本, 保持 <span class="codes">package-lock.json</span> 文件默认开启配置</li><li>初始化：第一作者初始化项目时使用 <span class="codes">npm install</span> <package> 安装依赖包, 默认保存 ^X.Y.Z 依赖 range 到 <span class="codes">package</span>中; 提交 <span class="codes">package</span>, <span class="codes">package-lock.json</span>, 不要提交 <span class="codes">node_modules</span> 目录</package></li><li>初始化：项目成员首次 checkout/clone 项目代码后，执行一次 <span class="codes">npm install</span> 安装依赖包</li><li>不要手动修改 <span class="codes">package-lock.json</span></li><li>升级依赖包:<ul><li>升级小版本: 本地执行 <span class="codes">npm update</span> 升级到新的小版本</li><li>升级大版本: 本地执行 <span class="codes">npm install</span> &lt;package-name&gt;@&lt;version&gt; 升级到新的大版本</li><li>也可手动修改 <span class="codes">package</span> 中版本号为要升级的版本(大于现有版本号)并指定所需的 semver, 然后执行 <span class="codes">npm install</span></li><li>本地验证升级后新版本无问题后，提交新的 <span class="codes">package</span>, <span class="codes">package-lock.json</span> 文件</li></ul></li>降级依赖包:<ul><li>正确: <span class="codes">npm install</span> <package-name>@<old-version> 验证无问题后，提交 <span class="codes">package</span> 和 <span class="codes">package-lock.json</span> 文件</old-version></package-name></li><li>错误: 手动修改 <span class="codes">package</span> 中的版本号为更低版本的 semver, 这样修改并不会生效，因为再次执行 <span class="codes">npm install</span> 依然会安装 <span class="codes">package-lock.json</span> 中的锁定版本</li></ul><li><ul><li>Plan A: npm uninstall &lt;package&gt; 并提交 <span class="codes">package</span> 和 <span class="codes">package-lock.json</span></li><li>Plan B: 把要卸载的包从 <span class="codes">package</span> 中 <span class="codes">dependencies</span> 字段删除, 然后执行 <span class="codes">npm install</span> 并提交 <span class="codes">package</span> 和 <span class="codes">package-lock.json</span></li><ul></ul></ul></li><li>任何时候有人提交了 <span class="codes">package</span>, <span class="codes">package-lock.json</span> 更新后，团队其他成员应在 svn update/git pull 拉取更新后执行 <span class="codes">npm install</span> 脚本安装更新后的依赖包</li></ul>
<span style="text-decoration:line-through">恭喜你终于可以跟 rm -rf <span class="codes">node_modules</span> && <span class="codes">npm install</span> 这波操作说拜拜了（其实并不会）</span>

<h2 id="npm-scripts"><a href="#npm-scripts" class="headerlink" title="npm scripts"></a>npm scripts</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>npm scripts 是 npm 另一个很重要的特性。通过在 <span class="codes">package</span> 中 scripts 字段定义一个脚本，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">        <span class="string">"echo"</span>: <span class="string">"echo HELLO WORLD"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就可以通过 <span class="codes">npm run echo</span> 命令来执行这段脚本，像在 shell 中执行该命令 echo <span class="codes">HELLO WORLD</span> 一样，看到终端输出 <span class="codes">HELLO WORLD</span>.</p>
<p>—— npm scripts 的基本使用就是这么简单，它提供了一个简单的接口用来调用工程相关的脚本。关于更详细的相关信息，可以参考阮一峰老师的文章 <a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener">npm script 使用指南 (2016年10月)</a>.<br>简要总结阮老师文章内容：<br>1.<span class="codes">npm run</span> 命令执行时，会把 ./<span class="codes">node_modules/.bin/</span> 目录添加到执行环境的 PATH 变量中，因此如果某个命令行包未全局安装，而只安装在了当前项目的 <span class="codes">node_modules</span> 中，通过 <span class="codes">npm run</span> 一样可以调用该命令。</p>
<p>2.执行 <span class="codes">npm</span> 脚本时要传入参数，需要在命令后加 <span class="codes">–</span> 标明, 如 <span class="codes">npm run test – –grep=”pattern”</span> 可以将 <span class="codes">–grep=”pattern”</span> 参数传给 <span class="codes">test</span> 命令</p>
<p>3.<span class="codes">npm</span> 提供了 <span class="codes">pre</span> 和 <span class="codes">post</span> 两种钩子机制，可以定义某个脚本前后的执行脚本</p>
<p>4.运行时变量：在 <span class="codes">npm run</span> 的脚本执行环境内，可以通过环境变量的方式获取许多运行时相关信息，以下都可以通过 process.env 对象访问获得：</p>
<ul><li><span class="codes">npm_lifecycle_event</span> - 正在运行的脚本名称</li><li><span class="codes">npm_package_&lt;key&gt;</span> - 获取当前包 <span class="codes">package</span> 中某个字段的配置值：如 <span class="codes"> npm_package_name</span> 获取包名</li><li><span class="codes">npm_package_&lt;key&gt;_&lt;sub-key&gt;- package</span> 中嵌套字段属性：如 <span class="codes">npm_pacakge_dependencies_webpack</span> 可以获取到 <span class="codes">package</span> 中的 <span class="codes">dependencies</span>.<span class="codes">webpack</span> 字段的值，即 <span class="codes">webpack</span> 的版本号</li></ul>

<h3 id="node-modules-bin-目录"><a href="#node-modules-bin-目录" class="headerlink" title="node_modules/.bin 目录"></a><span class="codes">node_modules</span>/.bin 目录</h3><p>上面所说的 <span class="codes">node_modules/.bin</span> 目录，保存了依赖目录中所安装的可供调用的命令行包。<br>何谓命令行包？例如 <span class="codes">webpack</span> 就属于一个命令行包。如果我们在安装 webpack 时添加 <span class="codes">–global</span> 参数，就可以在终端直接输入 <span class="codes">webpack</span> 进行调用。但如果不加 <span class="codes">–global</span> 参数，我们会在 <span class="codes">node_modules/.bin</span> 目录里看到名为 <span class="codes">webpack</span> 的文件，如果在终端直接输入 <span class="codes">./node_modules/.bin/webpack</span> 命令，一样可以执行。<br>这是因为 <span class="codes">webpack</span> 在 <span class="codes">package</span> 文件中定义了 <span class="codes">bin</span> 字段为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"bin"</span>: &#123;</span><br><span class="line">        <span class="string">"webpack"</span>: <span class="string">"./bin/webpack.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bin 字段的配置格式为: <span class="codes">&lt;command&gt;</span>: <span class="codes">&lt;file&gt;</span>, 即 命令名: 可执行文件. <span class="codes">npm</span> 执行 <span class="codes">install</span> 时，会分析每个依赖包的 <span class="codes">package</span> 中的 bin 字段，并将其包含的条目安装到 <span class="codes">./node_modules/.bin</span> 目录中，文件名为 <span class="codes">&lt;command&gt;</span>。而如果是全局模式安装，则会在 npm 全局安装路径的 bin 目录下创建指向 &lt;file&gt; 名为 &lt;command&gt; 的软链。因此，./<span class="codes">node_modules/.bin/webpack</span> 文件在通过命令行调用时，实际上就是在执行 node <span class="codes">./node_modules/.bin/webpack.js</span> 命令。<br>正如上一节所说，npm run 命令在执行时会把 <span class="codes">./node_modules/.bin</span> 加入到 PATH 中，使我们可直接调用所有提供了命令行调用接口的依赖包。所以这里就引出了一个最佳实践：</p>
<blockquote><p>将项目依赖的命令行工具安装到项目依赖文件夹中，然后通过 <span class="codes">npm scripts</span> 调用；而非全局安装</p>
</blockquote>
<p>举例而言 <span class="codes">webpack</span> 作为前端工程标配的构建工具，虽然我们都习惯了全局安装并直接使用命令行调用，但不同的项目依赖的 <span class="codes">webpack</span> 版本可能不同，相应的 <span class="codes">webpack.</span><span class="codes">config.js</span> 配置文件也可能只兼容了特定版本的 <span class="codes">webpack</span>. 如果我们仅全局安装了最新的 <span class="codes">webpack 4.x</span> 并使用 <span class="codes">webpack</span> 命令调用，在一个依赖 <span class="codes">webpack 3.x</span> 的工程中就会无法成功执行构建。<br>但如果这类工具总是本地安装，我们要调用一个命令，要手动添加 <span class="codes">./node_modules/.bin</span> 这个长长的前缀，未免也太麻烦了，我们 <span class="codes">nodejs</span> 开发者都很懒的。于是 <span class="codes">npm</span> 从5.2 开始自带了一个新的工具 <span class="codes">npx</span>.</p>
<h3 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h3><p> npx 的使用很简单，就是执行 <span class="codes">npx &lt;command&gt;</span> 即可，这里的 <span class="codes">&lt;command&gt;</span> 默认就是 <span class="codes">./node_modules</span> 目录中安装的可执行脚本名。例如上面本地安装好的 <span class="codes">webpack</span> 包，我们可以直接使用 <span class="codes">npx webpack</span> 执行即可。<br>除了这种最简单的场景, <span class="codes">npm cli</span> 团队开发者 Kat Marchán 还在这篇文章中介绍了其他几种 <span class="codes">npx</span> 的神奇用法:  <a href="https://link.juejin.im/?target=https%3A%2F%2Fbit.ly%2F2uzuIHv" target="_blank" rel="noopener">Introducing npx: an npm package runner</a>, 国内有位开发者 robin.law 将原文翻译为中文 <a href="https://link.juejin.im/?target=https%3A%2F%2Frobin-front.github.io%2F2017%2F07%2F14%2Fintroducing-npx-an-npm-package-runner%2F" target="_blank" rel="noopener">npx是什么，为什么需要npx?</a>.<br>有兴趣的可以戳链接了解，懒得点链接的，看总结：</p>
<p>场景a) 一键执行远程 npm 源的二进制包<br>除了在 package 中执行 <span class="codes">./node_modules/.bin</span> 中已安装的命令, 还可以直接指定未安装的二进制包名执行。例如我们在一个没有 <span class="codes">package</span> 也没有 <span class="codes">node_modules</span> 的目录下，执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx cowsay hello</span><br></pre></td></tr></table></figure>

<p>npx 将会从 <span class="codes">npm</span> 源下载 <span class="codes">cowsay</span> 这个包（但并不安装）并执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> _______</span><br><span class="line">&lt; hello &gt;</span><br><span class="line"> -------</span><br><span class="line">        \   ^__^</span><br><span class="line">         \  (oo)\_______</span><br><span class="line">            (__)\       )\/\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br></pre></td></tr></table></figure>

<p>这种用途非常适合 1. 在本地简单测试或调试 npm 源上这些二进制包的功能；2. 调用 <span class="codes">create-react-app</span> 或 <span class="codes">yeoman</span> 这类往往每个项目只需要使用一次的脚手架工具</p>
<p>PS: 此处有彩蛋，执行这条命令试试:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx workin-hard</span><br></pre></td></tr></table></figure>

<p>场景b) 一键执行 GitHub Gist<br>还记得前面提到的 [2.1 package定义] 么，<span class="codes">npm install</span> <package> 可以是包含了有效 <span class="codes">package</span> 的 <span class="codes">git url</span>.<br>刚好 <span class="codes">GitHub Gist</span> 也是 git 仓库 的一种，集合 <span class="codes">npx</span> 就可以方便地将简单的脚本共享给其他人，拥有该链接的人无需将脚本安装到本地工作目录即可执行。将 <span class="codes">package</span> 和 需执行的二进制脚本上传至 <span class="codes">gist</span>, 在运行 <span class="codes">npx &lt;gist url&gt;</span> 就可以方便地执行该 <span class="codes">gist</span> 定义的命令。<br>原文作者 <span class="codes">Kat Marchán 提供了这个示例 gist, 执行：</span></package></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx https:<span class="comment">//gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32</span></span><br></pre></td></tr></table></figure>

<p>可得到一个来自 <span class="codes">GitHubGist</span> 的 <span class="codes">HELLO WORLD</span> 问候。<br>场景c) 使用不同版本 <span class="codes">node</span> 执行命令<br>将 <span class="codes">npx</span> 与 <span class="codes">Aria Stewart</span> 创建的 <span class="codes">node 包 (https: //<a href="http://www.npmjs.com/package/node" target="_blank" rel="noopener">www.npmjs.com/package/node</a>)</span> 结合，可以实现在一行命令中使用指定版本的 <span class="codes">node</span> 执行命令。<br>例如先后执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx node@<span class="number">4</span> -e <span class="string">"console.log(process.version)"</span></span><br><span class="line">npx node@<span class="number">6</span> -e <span class="string">"console.log(process.version)"</span></span><br></pre></td></tr></table></figure>

<p>将分别输出 <spanm class="codes">v4.8.7 和 <span class="codes">v6.13.0</span>.</spanm></p>
<p>往常这种工作是由 <span class="codes">nvm</span> 这类 <span class="codes">node</span> 版本管理工具来做的，但 <span class="codes">npx node@4</span> 这种方式免去 <span class="codes">nvm</span> 手动切换配置的步骤，更加简洁简单。</p>
<h2 id="npm-配置"><a href="#npm-配置" class="headerlink" title="npm 配置"></a>npm 配置</h2><h3 id="npm-config"><a href="#npm-config" class="headerlink" title="npm config"></a>npm config</h3><p><span class="codes">npm config</span> 命令进行 <span class="codes">npm</span> 相关配置，通过 <span class="codes">npm config ls -l</span> 可查看 <span class="codes">npm</span> 的所有配置，包括默认配置。<span class="codes">npm</span> 文档页为每个配置项提供了详细的说明 <span class="codes">https: //docs.npmjs.com/misc/config</span> .<br>修改配置的命令为 <span class="codes">npm config set &lt;key&gt; &lt;value&gt;</span>, 我们使用相关的常见重要配置:</p>
<ul><li><span class="codes">proxy</span>, <span class="codes">https-proxy</span>: 指定 <span class="codes">npm</span> 使用的代理</li><li><span class="codes">registry</span> 指定 npm 下载安装包时的源，默认为 <span class="codes">https://registry.npmjs.org/</span> 可以指定为私有 <span class="codes">Registry 源</span></li><li><span class="codes">package-lock</span> 指定是否默认生成 <span class="codes">package-lock</span> 文件，建议保持默认 <span class="codes">true</span></li><li><span class="codes">save true/false</span> 指定是否在 <span class="codes">npm install</span> 后保存包为 <span class="codes">dependencies</span>, <span class="codes">npm 5</span> 起默认为 <span class="codes">true</span></li></ul>

<p>删除指定的配置项命令为 <span class="codes">npm config delete &lt;key&gt;</span>.</p>
<h3 id="npmrc-文件"><a href="#npmrc-文件" class="headerlink" title="npmrc 文件"></a>npmrc 文件</h3><p>除了使用 <span class="codes">CLI</span> 的 <span class="codes">npm config</span> 命令显示更改 <span class="codes">npm</span> 配置，还可以通过 <spanm class="codes">npmrc 文件直接修改配置。</spanm></p>
<p>这样的 <span class="codes">npmrc</span> 文件优先级由高到低包括：</p>
<ul><li>工程内配置文件: <span class="codes">/path/to/my/project/.npmrc</span></li><li>用户级配置文件: <span class="codes">~/.npmrc</span></li><li>全局配置文件: <span class="codes">$PREFIX/etc/npmrc</span> (即<span class="codes">npm config get globalconfig</span> 输出的路径)</li><li><span class="codes">npm</span>内置配置文件: <span class="codes">/path/to/npm/npmrc</span></li></ul>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxy = http:<span class="comment">//proxy.example.com/</span></span><br><span class="line">https-proxy = http:<span class="comment">//proxy.example.com/</span></span><br><span class="line">registry = http:<span class="comment">//registry.example.com/</span></span><br></pre></td></tr></table></figure>

<p>因为项目级 <span class="codes">.npmrc</span> 文件的作用域只在本项目下，所以在非本目录下，这些配置并不生效。对于使用笔记本工作的开发者，可以很好地隔离公司的工作项目、在家学习研究项目两种不同的环境。<br>将这个功能与 <span class="codes">~/.npm-init.js</span> 配置相结合，可以将特定配置的 <span class="codes">.npmrc</span> 跟 <span class="codes">.gitignore</span>, <span class="codes">README</span> 之类文件一起做到 <span class="codes">npm init</span> 脚手架中，进一步减少手动配置。</p>
<h3 id="node-版本约束"><a href="#node-版本约束" class="headerlink" title="node 版本约束"></a>node 版本约束</h3><p>虽然一个项目的团队都共享了相同的代码，但每个人的开发机器可能安装了不同的 <span class="codes">node</span> 版本，此外服务器端的也可能与本地开发机不一致。</p>
<p>这又是一个可能带来不一致性的因素 —— 但也不是很难解决，声明式约束+脚本限制即可。</p>
<p>声明：通过 <span class="codes">package</span> 的 <span class="codes">engines</span> 属性声明应用运行所需的版本运行时要求。例如我们的项目中使用了 <span class="codes">async</span>, <span class="codes">await</span> 特性，查阅兼容性表格得知最低支持版本为 <span class="codes">7.6.0</span>，因此指定 <span class="codes">engines</span> 配置为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"engines"</span>: &#123; <span class="string">"node"</span>: <span class="string">"&gt;=7.6.0"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强约束(可选)：在 <span class="codes">npm</span> 中以上字段内容仅作为建议字段使用，若要在私有项目中添加强约束，需要自己写脚本钩子，读取并解析 <span class="codes">engines</span> 字段的 <span class="codes">semver range</span> 并与运行时环境做对比校验并适当提醒。</p>
<h2 id="小结-npm-最佳实践"><a href="#小结-npm-最佳实践" class="headerlink" title="小结 npm 最佳实践"></a>小结 npm 最佳实践</h2><ul><li>使用 npm-init 初始化新项目</li><li>统一项目配置: 需团队共享的 <span class="codes">npm config</span> 配置项，固化到 <spanm class="codes">.npmrc 文件中</spanm></li><li>统一运行环境，统一 <span class="codes">package</span>，统一 <span class="codes">package-lock</span> 文件</li><li>合理使用多样化的源安装依赖包: <span class="codes">npm install &lt;git url&gt;|&lt;local file&gt;</span> </li><li>使用 <span class="codes">npm: >=5.2</span> 版本</li><li>使用 <span class="codes">npm scripts</span> 与 <span class="codes">npx (npm: >=5.2)</span> 脚本管理应用相关脚本</li></ul>

<h2 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h2><ul><li>npm team 成员 Ashley Williams 在 2016 年 Node.js Live 上的 talk: You Don't Know npm, 当时还没有 npm 5<ul><li>YouTube 视频链接: [Node.js Live (Paris) - Ashley Williams, You Don't Know npm](https://www.youtube.com/watch?v=hopWbVKmiVQ&t=537s)</li><li>演讲用的 slides:[the ag_deck](http://ashleygwilliams.github.io/you-dont-know-npm/)</li></ul></li><li>这篇 2015 年的文章介绍了如何使用把本地模块打包到 <span class="codes">node_modules</span> 依赖中: [Build modular application with npm local modules](https://link.juejin.im/?target=https%3A%2F%2Fbit.ly%2F2DLnaCd)</li><li>一篇很好的介绍 <span class="codes">package-lock.json</span> 的文章: [Everything you wanted to know about <span class="codes">package-lock.json</span>](https://link.juejin.im/?target=https%3A%2F%2Fbit.ly%2F2Fiok9Z)</li><li>阮一峰 [npm scripts 使用指南](http://ruanyifeng.com/blog/2016/10/npm_scripts.html)</li><li>Kat Marchán 介绍npx:<ul><li></li>原文 [Introducing npx: an npm package runner](https://link.juejin.im/?target=http%3A%2F%2Ft.cn%2FRKIYHBA)<li>中文 [npx是什么，为什么需要npx?](https://robin-front.github.io/2017/07/14/introducing-npx-an-npm-package-runner/)</li></ul></li></ul>


<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>npm 官方文档, 无中文翻译</p>
<ul><li>[package.json 文件](https://link.juejin.im/?target=https%3A%2F%2Fdocs.npmjs.com%2Ffiles%2Fpackage.json)</li><li>[npm config 配置](https://link.juejin.im/?target=https%3A%2F%2Fdocs.npmjs.com%2Fmisc%2Fconfig)</li><li>[npm semver 计算器](https://link.juejin.im/?target=https%3A%2F%2Fsemver.npmjs.com)</li><li>[node_modules 目录扁平化](https://link.juejin.im/?target=https%3A%2F%2Fdocs.npmjs.com%2Fcli%2Finstall)</li></ul>

<p>yarn 中文文档，虽然是 npm 竞争者但兼容 package.json 和 node_modules 目录，因此这两部分一样可参考：</p>
<ul><li>[package.json - 中文](https://link.juejin.im/?target=https%3A%2F%2Fyarnpkg.com%2Fzh-Hans%2Fdocs%2Fpackage-json)</li><li>[依赖与版本 - 中文](https://yarnpkg.com/zh-Hans/docs/<span class="codes">dependencies</span>)</li></ul>

<h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p>sam boyer 《所以你想开发一个包管理系统》，从无关特定语言的角度，介绍一个包管理系统的方方面面: <a href="https://link.juejin.im/?target=https%3A%2F%2Fbit.ly%2F2G36U1e" target="_blank" rel="noopener">So you want to write a package manager</a></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="blog.yuanziwen.cn">Seven</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="blog.yuanziwen.cn/2018/03/28/转载：你还是只会npm-install/">blog.yuanziwen.cn/2018/03/28/转载：你还是只会npm-install/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/Npm/">Npm</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2018/04/16/前端通用代码规范/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">前端通用代码规范</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2018/02/24/this-apply-find-all/">
        <span class="next-text nav-default">this apply find all</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'cxeaTV5BFDCxPmxoCcG9QPxf-gzGzoHsz',
        appKey: 's577OrPG5sB4Szom6mvHuI1X',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info: guest,
        pageSize:'10' || 10,
    });
  </script>

<footer id="footer" class="footer"><div class="social-links"><a href="mailto:yuanziwen7489757@gmail.com" class="iconfont icon-email" title="email"></a>
          <a href="https://juejin.im/user/59aa31a06fb9a02485103ddf" class="iconfont juejin" title="掘金"><div class="img"></div></a>
        <a href="https://github.com/yzw7489757" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <!--<span class="division">|</span>
  <span class="theme-info">
    footer.theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>-->
  <span class="power-by">
   <a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备18011257号-1</a>
  </span>
  <span class="copyright-year">&copy;2017 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Seven</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
<script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js?t=1593502174043')
    .then(function () {console.log('ServiceWorker Register Successfully.')})
    .catch(function (e) {console.error(e)});
}
</script></body>
</html>
