<!DOCTYPE html>
<html lang="zh-Hans">
  <head><meta name="generator" content="Hexo 3.9.0"><link rel="manifest" href="/manifest.json"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Vue源码剖析——render、patch、updata、vnode"><meta name="keywords" content="Seven YuanZiWen"><link rel="alternate" href="/atom.xml" title="Seven Blog"><link rel="shortcut icon" type="image/x-icon" href="https://static.yuanziwen.cn/blog/favicon.ico?v=2.11.0">
<link rel="canonical" href="blog.yuanziwen.cn/2018/08/02/Vue源码剖析——render、patch、updata、vnode/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1e4ffaffd9b2bc832b39e2b866a92c7b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>Vue源码剖析——render、patch、updata、vnode - Seven Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Seven Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Record
          </li>
      </a><a href="/music/">
        <li class="mobile-menu-item">Music(NoAuto)
          </li>
      </a><a href="/photo/">
        <li class="mobile-menu-item">Album
          </li>
      </a><a href="/book/">
        <li class="mobile-menu-item">Book
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Seven Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Record
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/music/">
            Music(NoAuto)
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/photo/">
            Album
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/book/">
            Book
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">Vue源码剖析——render、patch、updata、vnode
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-08-02
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#flow前置"><span class="toc-text">flow前置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#项目架构"><span class="toc-text">项目架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#目录结构"><span class="toc-text">目录结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从入口开始"><span class="toc-text">从入口开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整体流程"><span class="toc-text">整体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解释一下各类词汇"><span class="toc-text">解释一下各类词汇</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#挂载"><span class="toc-text">挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译RenderFn"><span class="toc-text">编译RenderFn</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#怎么进行patch？"><span class="toc-text">怎么进行patch？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#updateChildren"><span class="toc-text">updateChildren</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vnode"><span class="toc-text">Vnode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#compileToFunctions（template编译成render"><span class="toc-text">compileToFunctions（template编译成render)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML转RenderFn"><span class="toc-text">HTML转RenderFn</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#将renderFn编译Vnode"><span class="toc-text">将renderFn编译Vnode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#createElement"><span class="toc-text">createElement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-Vue"><span class="toc-text">new Vue</span></a></li></ol>
    </div>
  </div><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.2.1/css/hint.min.css"><h2 id="flow前置"><a href="#flow前置" class="headerlink" title="flow前置"></a>flow前置</h2><p><img src="https://static.yuanziwen.cn/blog/Vue/poster.png_plain" alt><br>在<code>Vue</code>源码里，尤大采用了<code>Flow</code>作为静态类型检查，<code>Flow</code>是<code>facebook</code>出品的静态类型检查工具。</p>
<a id="more"></a>
<p>为什么要用<code>Flow</code>？<br>众所周知，<code>JavaScript</code>是弱类型的语言。</p>
<p>所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型，如果一个语言可以隐式转换它的所有类型，那么它的变量、表达式等在参与运算时，即使类型不正确，也能通过隐式转换来得到正确地类型，这对使用者而言，就好像所有类型都能进行所有运算一样，所以<code>Javascript</code>被称作弱类型。</p>
<p>可能在初期的时候，这个特点有时候用着很爽，但当你在一个较大的项目中的时候，就会发现这个特性不是一般的麻烦，同事往往不太清楚你所写的函数到底要哪种类型的参数，而且代码重构的时候也很麻烦。</p>
<p>于是基于这个需求有了<code>Typescript</code>和<code>Flow</code>的产生，但是<code>TypeScript</code>学习成本较大，一般来说不会为了一些便利去学习一门语言，所以<code>Facebook</code>在四年前开源了<a href="https://flow.org/" target="_blank" rel="noopener">Flow</a>。</p>
<p><code>Vue</code>为什么要用<code>Flow</code>而不用<code>Typescript</code>开发框架呢？<a href="https://www.zhihu.com/question/46397274/answer/101193678" target="_blank" rel="noopener">尤雨溪知乎的回答是这样的</a>。</p>
<p>具体怎么用，可以到这学习查看中文文档。本文主要讲Vue源码技巧，不会过多解释Flow。</p>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p>Vue.js 是一个典型的 MVVM框架，核心思想是数据驱动和组件化。DOM是数据的一种自然映射，在Vue中只需要修改数据即可达到DOM更新的目的。组件化是将页面上每一个独立的功能块或者交互模块视作一个组件，把页面看做是容器，从而实现<code>搭积木式</code>的开发方式。<br>把源码download到本地我们看下目录结构</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="https://static.yuanziwen.cn/blog/Vue/1.png_plain" alt></p>
<p>Vue源码目录分工明确。整个目录大致分为</p>
<ul>
<li><code>benchmarks</code>:处理大量数据时测试Demo</li>
<li><code>dist</code>:各环境所需的版本包</li>
<li><code>examples</code>:用Vue实现的一些实用Demo</li>
<li><code>flow</code>: 数据类型检测配置</li>
<li><code>packages</code>: 特定环境运行需要单独安装的插件</li>
<li><code>src</code>: 整个源码的核心。</li>
<li><code>script</code>: npm脚本配置文件</li>
<li><code>test</code>: 测试用例</li>
<li><code>types</code>: 新版typescript配置</li>
</ul>
<p>核心代码都在<code>src</code>目录下，其中包含实例化、数据响应式处理、模板编译、事件中心、全局配置等等都在这个目录下。</p>
<h2 id="从入口开始"><a href="#从入口开始" class="headerlink" title="从入口开始"></a>从入口开始</h2><p>从编译器,找到根目录下的<code>package.json</code>文件,可以看到在<code>script</code>里有一个<code>dev</code>，这个文件生成了<code>rollup</code>打包器的配置，<br><img src="https://static.yuanziwen.cn/blog/Vue/2.png_plain" alt></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rollup -w -c scripts/config.js --environment TARGET:web-full-dev</span><br></pre></td></tr></table></figure>

<p><code>rollup</code>表示它使用了<code>rollup</code>打包器，<code>-w</code>表示<code>watch</code>监听文件变化，<code>c</code>表示<code>config</code>使用配置文件来打包，如果后面没有指定文件就默认指定<code>rollup.config.js</code>,再后面表示指定<code>scripts/config.js</code>配置rollup，<code>--environment</code>表示设置环境变量，后面携带参数<code>TARGET:web-full-dev</code>表示环境变量名和值，我们再到<code>scripts/config.js</code>，可以看到环境变量参数已经带过来并且触发了<code>genConfig()</code>函数<br><img src="https://static.yuanziwen.cn/blog/Vue/3.png_plain" alt><br>那<code>genConfig()</code>做了什么</p>
<p><img src="https://static.yuanziwen.cn/blog/Vue/4.png_plain" alt><br>其他的隐藏暂时不看，首先<code>const opts = builds[name]</code>在<code>builds</code>变量查找到配置。定义了入口文件和输出配置，如果定义了运行环境，就储存到该字段。<br><img src="https://static.yuanziwen.cn/blog/Vue/5.png_plain" alt><br>然后在这个文件里找到<code>web-full-dev</code>对应的配置是这样的：它主要申明了入口<code>entry</code>和模块定义<code>format</code>、输出<code>dest</code>、环境名称<code>env</code>，rollup编译<code>alias</code>，框架信息<code>banner</code>，入口是<code>web/entry-runtime-with-compiler.js</code>,<br>但是在当前目录并没有<code>web</code>文件夹，那怎么找呢？在上面我们可以看到有一个<code>resolve()</code>路径代理函数</p>
<p><img src="https://static.yuanziwen.cn/blog/Vue/6.png_plain" alt><br>利用<code>split</code>切割传入的文件名匹配引入的<code>alias</code>配置、最终定位到<code>src/platforms/web/entry-runtime-with-compiler.js</code>，找到Vue在这储存了<code>$mount</code>的方法并且新申明了一个<code>$mount</code>的方法,利用储存的<code>mount</code>方法在底部再次进行挂载处理并将结果返回。为什么要重新申明，查阅资料后知道原来<code>runtime-only</code>版本并没有后申明的<code>$mount</code>这部分的处理，这样的做就可以在保持原有函数的基础上进行复用，这一点值得我们去学习。</p>
<blockquote>
<p>不轻易修改原有逻辑，但是可以将原有的函数储存起来，再重新声明。</p>
</blockquote>
<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>先看大概的整体流程</p>
<ul>
<li>首次渲染，执行<code>compileToFunctions()</code>将模板template解析成renderFn（render函数）,如果renderFn已存在就跳过此部</li>
<li>将renderFn通过<code>vm._render()</code>编译成Vnode，在读取其中变量的同时，<code>Watcher</code>通过<code>Object.defindProperty()</code>的<code>get</code>方法收集依赖到dep,开始监听</li>
<li>执行<code>updataComponent()</code>，首先到vdom的<code>patch()</code>方法会将<code>vnode</code>渲染成真实DOM</li>
<li>将DOM挂载到节点上，等待data发生改变</li>
<li><code>data</code>属性发生变化，首先查看收集的依赖中是否存在该data值的引用，不存在就不管，存在则触发<code>Object.defindProperty()</code>的<code>set</code>方法修改值并且执行<code>_updata</code> 进行 <code>patch()</code> 和<code>updataComponent()</code>进行组件更新</li>
</ul>
<p><img src="https://static.yuanziwen.cn/blog/Vue/7.png_plain" alt></p>
<p> 大致分为</p>
<p>esm 完整构建 ：包含模板编译器，渲染过程 HTML字符串 → render函数 → VNode → 真实DOM节点</p>
<p>runtime-only 运行时构建 ：不包含模板编译器，渲染过程 render函数 → VNode → 真实DOM节点</p>
<p><img src="https://static.yuanziwen.cn/blog/Vue/8.png_plain" alt><br>runtime-only版本是没有template=&gt;render这一步的，不带模板编译器。</p>
<h3 id="解释一下各类词汇"><a href="#解释一下各类词汇" class="headerlink" title="解释一下各类词汇"></a>解释一下各类词汇</h3><ol>
<li><code>template</code> 模板 ：Vue的模板基于纯HTML，基于Vue的模板语法，还是可以按照以前HTML式写结构。</li>
<li>AST 抽象语法树： <code>Abstract Syntax Tree</code> 的简称，主要做三步<ol><li>parse:Vue使用HTML的<code>Parser</code>将HTML模板解析为AST</li><li>optimizer:对AST进行一些优化static静态节点的标记处理，提取最大的静态树，当`_update`更新界面时，会有一个patch的过程，diff算法会直接跳过静态节点，从而减少了patch的过程，优化了patch的性能,方便直接跳过Diff。</li><li>generateCode:根据 AST 生成 <code>render</code> 函数</li></ol></li>
<li>renderFn 渲染函数 ：渲染函数是用来生成Virtual DOM(vdom)的。Vue推荐使用模板来构建我们的应用界面，在底层实现中Vue会将模板编译成renderFn函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制</li>
<li>Virtual DOM (vdom，也称为VNode)：虚拟DOM树，Vue的Virtual DOM Patching算法是基于 Snabbdom 的实现，并在些基础上作了很多的调整和改进。只能通过RenderFn执行`vm._render()`生成，patch的目标都是Vnode，并且每个Vnode在全局都是唯一的</li>
<li>patch：在上面vdom已经说到这个，但还是要说一句，patch是整个virtaul-dom当中最为核心的方法，主要功能是对旧vnode和新vnode进行diff的过程，最后生成新的DOM节点通过`updataComponent()`方法重新渲染，vue对此做了相当多的性能优化</li>
<li>Watcher (观察者)：每个Vue组件都有一个对应的 Watcher ，这个 Watcher 将会在组件 render 的时候收集组件所依赖的数据，并在依赖有更新的时候，触发组件`vm._updata`调用`patch()`进行diff，重新渲染DOM。</li>
</ol>




<p>不扯废话，开撸</p>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p><img src="https://static.yuanziwen.cn/blog/Vue/9.png_plain" alt><br>新挂载$mount的这个方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>key?:value</code>  (key: value|void);</p>
</blockquote>
<p><code>el?:string|Element</code>是flow的语法，表示传入的el字符串可以是<code>string</code>和<code>Element</code>以及void类型——<code>undefined</code>类型，<code>hydrating?: boolean</code>同样，必须是布尔类型和<code>undefined</code>。</p>
<blockquote>
<p><code>key:?value</code> (key: value|void|null);</p>
</blockquote>
<p>表示该<code>key</code>必须为<code>value</code>或者<code>undefined</code>以及<code>null</code>类型。</p>
<blockquote>
<p><code>function():value</code>  (:value)<br><code>:Component</code>表示函数返回值必须为<code>Component</code>类型。</p>
</blockquote>
<blockquote>
<p> <code>function(key:value1|value2)</code> (key:value1|value2)<br>表示<code>key</code>必须为<code>value1</code>或者是<code>value2</code>类型。</p>
</blockquote>
<h3 id="编译RenderFn"><a href="#编译RenderFn" class="headerlink" title="编译RenderFn"></a>编译RenderFn</h3><p><code>el = el &amp;&amp; query(el)</code>对传入的<code>el</code>元素节点做了确认，如果传入的节点容器没有找到的便警告并且return一个<code>createElement(&#39;div&#39;)</code>新的div。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断传入的标签如果是body或者是页面根节点</span></span><br><span class="line"><span class="comment">//就警告禁止挂载在页面根节点上，因为挂载会替换该节点。最后返回该节点</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options;    </span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;    <span class="comment">//如果接受的值已经有写好的RenderFn，则不用进行任何操作,如果render不存在，就进入此逻辑将模板编译成renderFn</span></span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">        ...   <span class="comment">//有template就使用idToTemplate()解析,最终返回该节点的innerHTML</span></span><br><span class="line">      &#125; <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;<span class="comment">//如果模板取到的第一个字符是#</span></span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) &#123;<span class="comment">//开发环境并且解析模板失败的报错：警告模板为空或者未找到</span></span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="keyword">this</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        <span class="comment">//如果有节点类型，判定是普通节点，也返回innerHTML</span></span><br><span class="line">        template = template.innerHTML  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//没有template就警告该模板无效</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">        <span class="comment">//如果是节点的话，获取html模板片段,getOuterHTML()对传入的el元素做了兼容处理，最终目的是拿到节点的outerHTML</span></span><br><span class="line">        <span class="comment">//getOuterHTML()可以传入DOM节点，CSS选择器，HTML片段</span></span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">     <span class="comment">//编译HTML生成renderFn，赋给options,vm.$options.render此时发生变化</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        <span class="comment">//开始标记</span></span><br><span class="line">        mark(<span class="string">'compile'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*  compileToFunctions()主要是将getOuterHTML获取的模板编译成RenderFn函数，该函数的具体请往后翻看</span></span><br><span class="line"><span class="comment">       *  具体步骤之后再说，编译大致主要分成三步 </span></span><br><span class="line"><span class="comment">       *  1.parse：将 html 模板解析成抽象语法树(AST)。</span></span><br><span class="line"><span class="comment">       *  2.optimizer：对 AST 做优化处理。</span></span><br><span class="line"><span class="comment">       *  3.generateCode：根据 AST 生成 render 函数。</span></span><br><span class="line"><span class="comment">       */</span> </span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      &#125;, <span class="keyword">this</span>)</span><br><span class="line">      options.render = render;  <span class="comment">//最后将解析的renderFn 赋值给当前实例</span></span><br><span class="line">      options.staticRenderFns = staticRenderFns <span class="comment">//编译的配置</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        <span class="comment">//结束标记</span></span><br><span class="line">        mark(<span class="string">'compile end'</span>)</span><br><span class="line">        <span class="comment">//根据mark()编译过程计算耗时差，用于到控制台performance查看阶段渲染性能</span></span><br><span class="line">        measure(<span class="string">`vue <span class="subst">$&#123;<span class="keyword">this</span>._name&#125;</span> compile`</span>, <span class="string">'compile'</span>, <span class="string">'compile end'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//最后返回之前储存的mount()方法进行挂载，如果此前renderFn存在就直接进行此步骤</span></span><br><span class="line">    <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最重要的就是<code>compileToFunctions()</code>将template编译成RenderFn,该方法请通过目录跳转查看。</p>
<p><img src="https://static.yuanziwen.cn/blog/Vue/10.png_plain" alt><br>本段代码对<code>template</code>的多种写法做兼容处理，最终取到<code>renderFn</code>，过程中顺带进行性能埋点等辅助功能。<br>最后<code>return mount.call(...)</code>这个在</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./runtime/index'</span></span><br></pre></td></tr></table></figure>

<p>编译的过程比较复杂，之后再说。到这发现Vue的原型方法并不是在这建立的，我们需要到上一级<br><code>src/platforms/runtime/index.js</code>,</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置了一些全局的方法</span></span><br><span class="line">Vue.config.mustUseProp = mustUseProp </span><br><span class="line">Vue.config.isReservedTag = isReservedTag </span><br><span class="line">Vue.config.isReservedAttr = isReservedAttr</span><br><span class="line">Vue.config.getTagNamespace = getTagNamespace</span><br><span class="line">Vue.config.isUnknownElement = isUnknownElement</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装平台的指令和组件</span></span><br><span class="line">extend(Vue.options.directives, platformDirectives)</span><br><span class="line">extend(Vue.options.components, platformComponents)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果在浏览器里，证明不是服务端渲染，添加__patch__方法</span></span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载$mount方法。</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">//必须在浏览器环境才返回该节点，runtime-only版本会直接运行到这</span></span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hydrating</code>这个传参可以全局性的理解为，服务端渲染，默认false。<br>最后进行<code>mountComponent(this, el, hydrating)</code>其实就是对组件进行一个<code>update</code>和<code>watcher</code>的过程。具体看下<code>mountComponent</code>做了什么。找到<code>src/core/instance/lifecycle.js</code>，这个文件负责为实例添加生命周期类函数.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean </span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el  <span class="comment">//首先将vm.$el将传入的el做缓存,$el现在为真实的node</span></span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    <span class="comment">//因为最后只认renderFn，如果没有的话，就创建一个空节点Vnode</span></span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;<span class="comment">//开发环境下</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">'#'</span>) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         （如果定义了template但是template首位不是'#'）或者（没有传入element），就会警告当前使用的是runtime-only版本，</span></span><br><span class="line"><span class="comment">         默认不带编译功能，如果需要编译的话，则需要更换构建版本，下面类似</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warn(<span class="comment">//挂载组件失败：template或者renderFn未定义</span></span><br><span class="line">          <span class="string">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在挂载之前为当前实例初始化beforMount生命周期</span></span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 声明了一个 updateComponent 方法，这个是将要被 Watcher实例调用的更新组件的方法。</span></span><br><span class="line">  <span class="comment">// 根据性能的对比配置不同的更新方法,</span></span><br><span class="line">  <span class="comment">// performance+mark可以用于分析Vue组件在不同阶段中花费的时间，进而知道哪里可以优化。</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent </span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//获取组件标记</span></span><br><span class="line">      <span class="keyword">const</span> name = vm._name</span><br><span class="line">      <span class="keyword">const</span> id = vm._uid</span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">      mark(startTag);<span class="comment">//标记开始节点</span></span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render();<span class="comment">//生成一个Vnode</span></span><br><span class="line">      mark(endTag);<span class="comment">//标记结束节点</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">//做performance命名'vue $&#123;name&#125; render'，这样就可以在proformance中查看应用程序的运行状况、渲染性能，最后删除标记和度量</span></span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag);</span><br><span class="line">     </span><br><span class="line">      mark(startTag);</span><br><span class="line">      vm._update(vnode, hydrating);</span><br><span class="line">     </span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个渲染watcher函数</span></span><br><span class="line">    <span class="comment">// vm._render()里会调用render函数，并返回一个VNode，在生成VNode的过程中，会动态计算getter,同时推入到dep里面进行数据监听，每次数据更新后都出触发当前实例的_updata进行组件更新</span></span><br><span class="line">    <span class="comment">// _update()方法会将新vnode和旧vnode进行diff比较，最后完成dom的更新工作,该方法请往下移步</span></span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 新建一个_watcher对象，将监听目标推入dep，vm实例上挂载的_watcher主要是为了更新DOM调用当前vm的_watcher 的 update 方法。用来强制更新。为什么叫强制更新呢？</span></span><br><span class="line"><span class="comment">   * vue里面有判断，如果newValue == oldValue， 那么就不触发watcher更新视图了</span></span><br><span class="line"><span class="comment">   * vm：当前实例</span></span><br><span class="line"><span class="comment">   * updateComponent：用来将vnode更新到之前的dom上</span></span><br><span class="line"><span class="comment">   * noop：无效函数，可以理解为空函数</span></span><br><span class="line"><span class="comment">   * &#123;before()&#123;...&#125;&#125;：配置，如果该实例已经挂载了，就配置beforeUpdate生命周期钩子函数</span></span><br><span class="line"><span class="comment">   * true：主要是用来判断是哪个watcher的。因为computed计算属性和如果你要在options里面配置watch了同样也是使用了 new Watcher ，加上这个用以区别这三者</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> )</span><br><span class="line">  hydrating = <span class="literal">false</span>  <span class="comment">//关闭服务端渲染，服务端渲染只有created()和beforeCreate()</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的具体作用就是挂载节点，并对data做响应式处理。<br>至于为什么会有个判断语句来根据条件声明 <code>updateComponent</code>方法，其实从 performance 可以看出，其中一个方法是用来测试<code>render</code> 和 <code>update</code> 性能的。便于在<code>Chrome=&gt;performance</code>中查看渲染性能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark</span><br></pre></td></tr></table></figure>

<p>首先判断当前的环境和是否配置支持<code>performance</code>，然后调用<code>mark</code>和<code>measure</code>方法，其中<code>mark</code>封装了一个方法,具体的API可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark" target="_blank" rel="noopener">MDN performance</a>,给当前元素做一个标记，然后返回一个具体的时间点，主要功能是性能埋点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">//判断当前浏览器runtime是否支持performace</span></span><br><span class="line">  <span class="keyword">const</span> perf = inBrowser &amp;&amp; <span class="built_in">window</span>.performance</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    perf &amp;&amp;</span><br><span class="line">    perf.mark &amp;&amp;</span><br><span class="line">    perf.measure &amp;&amp;</span><br><span class="line">    perf.clearMarks &amp;&amp;</span><br><span class="line">    perf.clearMeasures</span><br><span class="line">  ) &#123;</span><br><span class="line">    mark = <span class="function"><span class="params">tag</span> =&gt;</span> perf.mark(tag);<span class="comment">//标记该节点</span></span><br><span class="line">    measure = <span class="function">(<span class="params">name, startTag, endTag</span>) =&gt;</span> &#123;</span><br><span class="line">      perf.measure(name, startTag, endTag)</span><br><span class="line">      <span class="comment">//作性能埋点后，删除所有的标记和度量</span></span><br><span class="line">      perf.clearMarks(startTag)</span><br><span class="line">      perf.clearMarks(endTag)</span><br><span class="line">      perf.clearMeasures(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于刚才的<code>vm._update()</code>在上面<code>lifecyle.js</code>已经定义了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//首先接收vnode</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.$el;<span class="comment">//真实的dom节点</span></span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm._vnode;<span class="comment">//之前旧的vnode</span></span><br><span class="line">    <span class="keyword">const</span> prevActiveInstance = activeInstance;<span class="comment">// null</span></span><br><span class="line">    activeInstance = vm;<span class="comment">//获取当前的实例</span></span><br><span class="line">    vm._vnode = vnode;<span class="comment">//当前新的vnode </span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">      <span class="comment">// 如果需要diff的旧vnode不存在，就无法进行__patch__</span></span><br><span class="line">      <span class="comment">// 因此需要用新的vnode创建一个真实的dom节点</span></span><br><span class="line">      vm.$el = vm.__patch__(</span><br><span class="line">                        vm.$el, <span class="comment">//真实的dom节点</span></span><br><span class="line">                        vnode,  <span class="comment">//传入的vnode</span></span><br><span class="line">                        hydrating, <span class="comment">//是否服务端渲染</span></span><br><span class="line">                        <span class="literal">false</span> <span class="comment">/* removeOnly是一个只用于 &lt;transition-group&gt; 的特殊标签，确保移除元素过程中保持一个正确的相对位置。 */</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果需要diff的prevVnode存在，那么首先对prevVnode和vnode进行diff</span></span><br><span class="line">      <span class="comment">// 并将需要的更新的dom操作已patch的形式打到prevVnode上，并完成真实dom的更新工作</span></span><br><span class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    activeInstance = prevActiveInstance;<span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果存在真实的dom节点</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">      <span class="comment">//就将之前的__vue__清空，再挂载新的</span></span><br><span class="line">      prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将更新后的vm挂载到的vm__vue__上缓存</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前实例的$vnode与父组件的_vnode相同，也要更新其$el</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">      vm.$parent.$el = vm.$el</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h2 id="怎么进行patch？"><a href="#怎么进行patch？" class="headerlink" title="怎么进行patch？"></a>怎么进行patch？</h2><p><code>__patch__</code>是整个整个<code>virtaul-dom</code>当中最为核心的方法了，主要功能是对<code>prevVnode(旧vnode)</code>和<code>新vnode</code>进行<code>diff</code>的过程，经过<code>patch</code>比对，最后生成新的真实dom节点更新改变部分的视图。<br>在<code>/packages/factory.js</code>里，定义了<code>patch()</code>，代码过多，只摘取重要部分，目前清楚流程即可，vue2.0+是参考<a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">snabbdom</a>建立的patch虚拟dom算法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用到的参数，oldVnode：旧的vnode、vnode：新的vnode、hydrating：服务端渲染、removeOnly：避免误操作</span></span><br><span class="line">    <span class="comment">//当新的vnode不存在，并且旧的vnode存在时，直接返回旧的vnode，不做patch</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode)) &#123; invokeDestroyHook(oldVnode); &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> insertedVnodeQueue = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果旧的vnode不存在</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">      <span class="comment">//就创建一个新的节点</span></span><br><span class="line">      createElm(vnode, insertedVnodeQueue, parentElm, refElm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//获取旧vnode的节点类型</span></span><br><span class="line">      <span class="keyword">var</span> isRealElement = isDef(oldVnode.nodeType);</span><br><span class="line">      <span class="comment">// 如果不是真实的dom节点并且属性相同</span></span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// 对oldVnode和vnode进行diff，并对oldVnode打patch</span></span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);</span><br><span class="line">      &#125; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后返回新vnode的节点内容</span></span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">这是一个基本的patch，它的目标转到`</span>/src/core/vdom/patch.js<span class="string">`的`</span>patchVnode()<span class="string">`,</span></span><br><span class="line"><span class="string">并且通过`</span>sameVnode()<span class="string">`可以预先比对`</span>旧vnode<span class="string">`和`</span>新vnode<span class="string">`两者的基础属性，这个方法决定了接下来是否需要对`</span>oldVnode<span class="string">`和`</span>vnode<span class="string">`进行`</span>diff<span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> js</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp;</span><br><span class="line">    a.tag === b.tag &amp;&amp;</span><br><span class="line">    a.isComment === b.isComment &amp;&amp;</span><br><span class="line">    isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">    sameInputType(a, b)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当基本属性相同的情况下才认为这个<code>2个vnode</code>只是局部发生了更新，然后才会对这<code>2个vnode</code>进行diff，如果<code>2个vnode</code>的基本属性存在不一致的情况，那么就会直接跳过<code>diff</code>的过程，进而依据<code>vnode</code>新建一个<code>真实</code>的dom，同时删除老的节点。<br>首次渲染的时候，<code>oldVnode</code>并不存在，所以直接进行<code>domcreateElm(vnode, insertedVnodeQueue, parentElm, refElm);</code>创建一个新的节点，相反，存在<code>oldVnode</code>，当<code>oldVnode</code>和<code>vnode</code>都存在且<code>sameVnode(oldVnode, vnode)</code>2个节点的基本属性相同，那么就进入了2个节点的diff过程。</p>
<p>在<code>/src/core/vdom/patch.js</code>里定义里patchVnode函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 比较新旧vnode节点，根据不同的状态对dom做合理的更新操作（添加，移动，删除）整个过程还会依次调用prepatch,update,postpatch等钩子函数，在编译阶段生成的一些静态子树</span></span><br><span class="line"><span class="comment">    * 在这个过程中由于不会改变而直接跳过比对，动态子树在比较过程中比较核心的部分就是当新旧vnode同时存在children，通过updateChildren方法对子节点做更新，</span></span><br><span class="line"><span class="comment">    * @param oldVnode 旧vnode</span></span><br><span class="line"><span class="comment">    * @param vnode    新vnode</span></span><br><span class="line"><span class="comment">    * @param insertedVnodeQueue  空数组，用于生命周期 inserted 阶段，记录下所有新插入的节点以备调用</span></span><br><span class="line"><span class="comment">    * @param removeOnly 是一个只用于 &lt;transition-group&gt; 的特殊标签，确保移除元素过程中保持一个正确的相对位置。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class="line">    <span class="comment">// 异步占位</span></span><br><span class="line">    <span class="keyword">if</span> (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode.isAsyncPlaceholder = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果新vnode和旧vnode都是静态节点，key相同，或者新vnode是一次性渲染或者克隆节点，那么直接替换该组件实例并返回</span></span><br><span class="line">    <span class="keyword">if</span> (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">      isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">      vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">    ) &#123;</span><br><span class="line">      vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以往下翻去看vnode的例子，data是节点属性，包含class style attr和指令等</span></span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">const</span> data = vnode.data</span><br><span class="line">    <span class="comment">// 如果组件实例存在属性并且存在prepatch钩子函数就更新attrs/style/class/events/directives/refs等属性</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;</span><br><span class="line">      i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">    <span class="keyword">const</span> ch = vnode.children</span><br><span class="line">    <span class="comment">//如果新的vnode带有节点属性，isPatchable返回是否含有组件实例的tag标签，两者满足</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">      <span class="comment">// cbs保存了hooks钩子函数: 'create', 'activate', 'update', 'remove', 'destroy'</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">      <span class="comment">// 取出cbs保存的update钩子函数，依次调用，更新attrs/style/class/events/directives/refs等属性</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果vnode没有文本节点</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">      <span class="comment">//如果旧vnode和新vnode的子节点都存在</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="comment">// 如果子节点不同，updateChildren就对子节点进行diff</span></span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">        <span class="comment">//如果只存在新vnode</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">        <span class="comment">// 先将旧节点的文本清空</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">        <span class="comment">// 然后将vnode的children放进去</span></span><br><span class="line">        addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">        <span class="comment">// 如果只存在旧vnode</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">        <span class="comment">// 就删除elm下的oldchildren</span></span><br><span class="line">        removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 如果只有旧vnode的文本内容</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">        <span class="comment">// 直接清空内容</span></span><br><span class="line">        nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果是两者文本内容不同</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">      <span class="comment">// 直接更新vnode的文本内容</span></span><br><span class="line">      nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新完毕后，执行 data.hook.postpatch 钩子，表明 patch 完毕</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>通过比对新旧vnode节点属性、子元素、节点类型和内容等多种方式进行patch，过程中使用hooks更新节点属性。<br>理一下逻辑<br>源码中添加了一些注释便于理解，来理一下逻辑。 </p>
<ol>
<li>如果两个vnode相等，不需要 patch。 </li>
<li>如果是异步占位，执行 <code>hydrate</code> 方法或者定义 <code>isAsyncPlaceholder</code> 为 true，然后退出。 </li>
<li>如果两个vnode都为静态，不用更新，所以将以前的 <code>componentInstance</code> 实例传给当前 vnode。 退出patch</li>
<li>执行 <code>prepatch</code> 钩子。 </li>
<li>依次遍历调用 update 回调，执行 <code>update</code>钩子。更新attrs/style/class/events/directives/refs等属性。</li>
<li>如果两个 vnode 都有 children，且 vnode 没有 text 文本内容、两个 vnode 不相等，执行 <code>updateChildren</code> 方法。这是虚拟 DOM 的关键。 </li>
<li>如果新 vnode 有 children，而老的没有，清空文本，并添加 vnode 节点。 </li>
<li>如果老 vnode 有 children，而新的没有，清空文本，并移除 vnode 节点。 </li>
<li>如果两个 vnode 都没有 children，老 vnode 有 text ，新 vnode 没有 text ，则清空 DOM 文本内容。 </li>
<li>如果老 vnode 和新 vnode 的 text 不同，更新 DOM 元素文本内容。 </li>
<li>调用 <code>postpatch</code> 钩子告知patch完毕。</li>
</ol>
<h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><p>这个有点绕</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @ parentElm 父元素</span></span><br><span class="line"><span class="comment">     * @ oldCh  旧子节点</span></span><br><span class="line"><span class="comment">     * @ newCh  新子节点</span></span><br><span class="line"><span class="comment">     * @ insertedVnodeQueue 记录下所有新插入的节点以备调用</span></span><br><span class="line"><span class="comment">     * @ removeOnly 是仅由&lt;transition-group&gt;使用的特殊标志，在离开过渡期间，确保删除的元素保持正确的相对位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>  <span class="comment">//oldStartIdx =&gt; 旧头索引</span></span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span>   <span class="comment">//newStartIdx =&gt; 新头索引</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span> <span class="comment">//oldEndIdx =&gt; 旧尾索引</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>] <span class="comment">// 旧首索引节点，第一个</span></span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx] <span class="comment">// 旧尾索引节点，最后一个</span></span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span> <span class="comment">//newEndIdx =&gt; 新尾索引</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>] <span class="comment">// 新首索引节点，第一个</span></span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx] <span class="comment">// 新首索引节点，最后一个</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以理解为</span></span><br><span class="line">    <span class="comment">// 1. 旧子节点数组的 startIndex, endIndex, startNode, endNode</span></span><br><span class="line">    <span class="comment">// 2. 新子节点数组的 startIndex, endIndex, startNode, endNode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line">    <span class="comment">//可以进行移动</span></span><br><span class="line">    <span class="keyword">const</span> canMove = !removeOnly  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">//首先会检测新子节点有没有重复的key</span></span><br><span class="line">      checkDuplicateKeys(newCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果旧首索引节点和新首索引节点相同</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        <span class="comment">//对旧头索引节点和新头索引节点进行diff更新， 从而达到复用节点效果</span></span><br><span class="line">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">        <span class="comment">//旧头索引向后</span></span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        <span class="comment">//新头索引向后</span></span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">                <span class="comment">//如果旧尾索引节点和新尾索引节点相似，可以复用</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">        <span class="comment">//旧尾索引节点和新尾索引节点进行更新</span></span><br><span class="line">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">        <span class="comment">//旧尾索引向前</span></span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        <span class="comment">//新尾索引向前</span></span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">        <span class="comment">/*  有一种情况，如果</span></span><br><span class="line"><span class="comment">          * 旧【5，1，2，3，4】</span></span><br><span class="line"><span class="comment">          * 新【1，2，3，4，5】，那岂不是要全删除替换一遍 5-&gt;1,1-&gt;2...?</span></span><br><span class="line"><span class="comment">          * 即便有key，也会出现[5,1,2,3,4]=&gt;[1,5,2,3,4]=&gt;[1,2,5,3,4]...这样太耗费性能了</span></span><br><span class="line"><span class="comment">          * 其实我们只需要将5插入到最后一次操作即可</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 对旧首索引和新尾索引进行patch</span></span><br><span class="line">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">        <span class="comment">// 旧vnode开始插入到真实DOM中，旧首向右移，新尾向左移</span></span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">        <span class="comment">// 同上中可能，旧尾索引和新首也存在相似可能</span></span><br><span class="line">        <span class="comment">// 对旧首索引和新尾索引进行patch</span></span><br><span class="line">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">        <span class="comment">// 旧vnode开始插入到真实DOM中，新首向左移，旧尾向右移</span></span><br><span class="line">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果上面的判断都不通过，我们就需要key-index表来达到最大程度复用了</span></span><br><span class="line">         <span class="comment">//如果不存在旧节点的key-index表，则创建</span></span><br><span class="line">        <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">         <span class="comment">//找到新节点在旧节点组中对应节点的位置</span></span><br><span class="line">        idxInOld = isDef(newStartVnode.key)? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">          <span class="comment">//如果新节点在旧节点中不存在，就创建一个新元素，我们将它插入到旧首索引节点前（createElm第4个参数）</span></span><br><span class="line">        <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果旧节点有这个新节点</span></span><br><span class="line">          vnodeToMove = oldCh[idxInOld]</span><br><span class="line">            <span class="comment">// 将新节点和新首索引进行比对，如果类型相同就进行patch</span></span><br><span class="line">          <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">            <span class="comment">// 然后将旧节点组中对应节点设置为undefined,代表已经遍历过了，不在遍历，否则可能存在重复插入的问题</span></span><br><span class="line">            oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">            <span class="comment">// 如果不存在group群体偏移，就将其插入到旧首节点前</span></span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 类型不同就创建节点，并将其插入到旧首索引前（createElm第4个参数）</span></span><br><span class="line">            <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新首往后移一位</span></span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当旧首索引大于旧尾索引时，代表旧节点组已经遍历完，将剩余的新Vnode添加到最后一个新节点的位置后</span></span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="comment">//如果新节点组先遍历完，那么代表旧节点组中剩余节点都不需要，所以直接删除</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vnode"><a href="#Vnode" class="headerlink" title="Vnode"></a>Vnode</h2><p>在<code>/src/core/vdom/vnode.js</code>中有定义Vnode属性</p>
<figure class="highlight js"><figcaption><span>js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: ?Array&lt;VNode&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions,</span><br><span class="line">    asyncFactory?: Function</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag <span class="comment">//标签属性</span></span><br><span class="line">    <span class="keyword">this</span>.data = data  <span class="comment">//渲染成真实DOM后，节点上到class attr style 事件等...</span></span><br><span class="line">    <span class="keyword">this</span>.children = children <span class="comment">//子节点，也上vnode</span></span><br><span class="line">    <span class="keyword">this</span>.text = text  <span class="comment">// 文本</span></span><br><span class="line">    <span class="keyword">this</span>.elm = elm  <span class="comment">//对应着真实的dom节点</span></span><br><span class="line">    <span class="keyword">this</span>.ns = <span class="literal">undefined</span> <span class="comment">//当前节点的namespace（命名空间）</span></span><br><span class="line">    <span class="keyword">this</span>.context = context <span class="comment">//编译的作用域</span></span><br><span class="line">    <span class="keyword">this</span>.fnContext = <span class="literal">undefined</span> <span class="comment">// 函数化组件上下文</span></span><br><span class="line">    <span class="keyword">this</span>.fnOptions = <span class="literal">undefined</span> <span class="comment">// 函数化组件配置项</span></span><br><span class="line">    <span class="keyword">this</span>.fnScopeId = <span class="literal">undefined</span> <span class="comment">// 函数化组件ScopeId</span></span><br><span class="line">    <span class="keyword">this</span>.key = data &amp;&amp; data.key  <span class="comment">//只有绑定数据下存在，在diff的过程中可以提高性能</span></span><br><span class="line">    <span class="keyword">this</span>.componentOptions = componentOptions <span class="comment">// 通过vue组件生成的vnode对象，若是普通dom生成的vnode，则此值为空</span></span><br><span class="line">    <span class="keyword">this</span>.componentInstance = <span class="literal">undefined</span>  <span class="comment">//当前组件实例</span></span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="literal">undefined</span> <span class="comment">// vnode、组件的占位节点</span></span><br><span class="line">    <span class="keyword">this</span>.raw = <span class="literal">false</span>    <span class="comment">//是否为原生HTML或只是普通文本</span></span><br><span class="line">    <span class="keyword">this</span>.isStatic = <span class="literal">false</span>  <span class="comment">//静态节点标识 || keep-alive</span></span><br><span class="line">    <span class="keyword">this</span>.isRootInsert = <span class="literal">true</span>    <span class="comment">// 是否作为根节点插入</span></span><br><span class="line">    <span class="keyword">this</span>.isComment = <span class="literal">false</span>  <span class="comment">// 是否为注释节点</span></span><br><span class="line">    <span class="keyword">this</span>.isCloned = <span class="literal">false</span>  <span class="comment">//是否为克隆节点</span></span><br><span class="line">    <span class="keyword">this</span>.isOnce = <span class="literal">false</span>    <span class="comment">//是否为v-once节点</span></span><br><span class="line">    <span class="keyword">this</span>.asyncFactory = asyncFactory <span class="comment">// 异步工厂方法</span></span><br><span class="line">    <span class="keyword">this</span>.asyncMeta = <span class="literal">undefined</span> <span class="comment">//异步Meta</span></span><br><span class="line">    <span class="keyword">this</span>.isAsyncPlaceholder = <span class="literal">false</span> <span class="comment">//是否为异步占位</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//容器实例向后兼容的别名</span></span><br><span class="line">  <span class="keyword">get</span> child (): Component | void &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他属性不重要，最主要的上tag、data、children、key、text这几个属性。<br>VNode可以具体氛围以下几类</p>
<ul>
<li>TextVNode 文本节点。</li>
<li>ElementVNode 普通元素节点。</li>
<li>ComponentVNode 组件节点。</li>
<li>EmptyVNode 没有内容的注释节点。</li>
<li>CloneVNode 克隆节点，可以是以上任意类型的节点，唯一的区别在于isCloned属性为true<br>我们先定义一个vnode<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    tag: <span class="string">'div'</span></span><br><span class="line">    data: &#123;</span><br><span class="line">        id: <span class="string">'app'</span>,</span><br><span class="line">        class: 'test'</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">        &#123;</span><br><span class="line">            tag: <span class="string">'span'</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;,</span><br><span class="line">            text: <span class="string">'this is test'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>每一层对象都是一个节点。vnode</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag:<span class="string">'标签1'</span>,</span><br><span class="line">    attrs:&#123;</span><br><span class="line">        属性key1:属性value1,</span><br><span class="line">        属性key2:属性value2,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    children:[</span><br><span class="line">        &#123;</span><br><span class="line">            tag:<span class="string">'子标签1'</span>,</span><br><span class="line">            attrs:&#123;</span><br><span class="line">                子属性key1:子属性value1,</span><br><span class="line">                子属性key2:子属性value2,</span><br><span class="line">                ...</span><br><span class="line">            &#125;,</span><br><span class="line">            children:[</span><br><span class="line">                &#123;</span><br><span class="line">                    ....</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            tag:<span class="string">'子标签2'</span>,</span><br><span class="line">            attrs:&#123;</span><br><span class="line">                子属性key1:子属性value1,</span><br><span class="line">                子属性key2:子属性value2,</span><br><span class="line">                ...</span><br><span class="line">            &#125;,</span><br><span class="line">            children:[</span><br><span class="line">                &#123;</span><br><span class="line">                    ....</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以嵌套递归的方式产生最后渲染成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"test"</span>&gt;</span><br><span class="line">    &lt;span&gt;<span class="keyword">this</span> is test&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<p>Vue组件树建立起来的整个VNode树是唯一的。这意味着，手写render函数不能组件化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myVnode = createElement(<span class="string">'p'</span>, <span class="string">'hi'</span>)</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</span><br><span class="line">    myVnode, myVnode</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="compileToFunctions（template编译成render"><a href="#compileToFunctions（template编译成render" class="headerlink" title="compileToFunctions（template编译成render)"></a>compileToFunctions（template编译成render)</h2><p>首先在<code>/src/platforms/web/compiler/index.js</code>有定义<code>compileToFunctions()</code>方法，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置编译的选项，不设置则使用默认配置，配置项比较多</span></span><br><span class="line"><span class="keyword">import</span> &#123; baseOptions &#125; <span class="keyword">from</span> <span class="string">'./options'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createCompiler &#125; <span class="keyword">from</span> <span class="string">'compiler/index'</span></span><br><span class="line"><span class="comment">// 通过模板导入配置生成AST和Render</span></span><br><span class="line"><span class="keyword">const</span> &#123; compile, compileToFunctions &#125; = createCompiler(baseOptions)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; compile, compileToFunctions &#125;</span><br></pre></td></tr></table></figure>

<p>先看导入的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> baseOptions: CompilerOptions = &#123;</span><br><span class="line">  expectHTML: <span class="literal">true</span>,</span><br><span class="line">  modules,</span><br><span class="line">  directives,</span><br><span class="line">  isPreTag,</span><br><span class="line">  isUnaryTag,</span><br><span class="line">  mustUseProp,</span><br><span class="line">  canBeLeftOpenTag,</span><br><span class="line">  isReservedTag,</span><br><span class="line">  getTagNamespace,</span><br><span class="line">  staticKeys: genStaticKeys(modules)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到定义了<code>compile</code>和<code>compileToFunctions</code>,前者是AST语法树，后者是是编译好的renderFn</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">'./parser/index'</span> <span class="comment">// 将 HTML template解析为AST</span></span><br><span class="line"><span class="keyword">import</span> &#123; optimize &#125; <span class="keyword">from</span> <span class="string">'./optimizer'</span>  <span class="comment">// 对AST优化标记处理，提取最大的静态树</span></span><br><span class="line"><span class="keyword">import</span> &#123; generate &#125; <span class="keyword">from</span> <span class="string">'./codegen/index'</span> <span class="comment">// 根据 AST 生成 render 函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; createCompilerCreator &#125; <span class="keyword">from</span> <span class="string">'./create-compiler'</span> <span class="comment">//允许创建使用替代编译器，在这只使用默认部件导出默认编译器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createCompiler = createCompilerCreator(<span class="function"><span class="keyword">function</span> <span class="title">baseCompile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CompiledResult</span> </span>&#123;</span><br><span class="line">  <span class="comment">// parseHTML 的过程，导入配置，将template去掉空格，解析成AST ，最后返回AST元素对象</span></span><br><span class="line">  <span class="keyword">const</span> ast = parse(template.trim(), options)</span><br><span class="line">  <span class="built_in">console</span>.log(ast)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 默认开始优化标记处理，否则不进行优化</span></span><br><span class="line">  <span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">    optimize(ast, options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拿到最终的code。里面包含renderFn和静态renderFn</span></span><br><span class="line">  <span class="keyword">const</span> code = generate(ast, options)</span><br><span class="line">  <span class="built_in">console</span>.log(code.render)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//抛出</span></span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    ast, </span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>createCompilerCreator()</code>接受一个函数参数，<code>createCompiler</code>用以创建编译器，返回值是<code>compile</code>以及<code>compileToFunctions</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createCompilerCreator</span> (<span class="params">baseCompile: Function</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createCompiler</span> (<span class="params">baseOptions: CompilerOptions</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">compile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">      template: string,<span class="regexp">//</span>模板</span></span></span><br><span class="line"><span class="function"><span class="params">      options?: CompilerOptions <span class="regexp">//</span> 编译配置</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>): <span class="title">CompiledResult</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将finalOptions的隐式原型__proto__指向baseOptions对象</span></span><br><span class="line">      <span class="keyword">const</span> finalOptions = <span class="built_in">Object</span>.create(baseOptions) </span><br><span class="line">      <span class="keyword">const</span> errors = []</span><br><span class="line">      <span class="keyword">const</span> tips = []</span><br><span class="line">      </span><br><span class="line">      finalOptions.warn = <span class="function">(<span class="params">msg, tip</span>) =&gt;</span> &#123;</span><br><span class="line">        (tip ? tips : errors).push(msg)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果导入了配置就将配置进行合并  </span></span><br><span class="line">      <span class="keyword">if</span> (options) &#123;</span><br><span class="line">        <span class="comment">// 合并分支模块</span></span><br><span class="line">        <span class="keyword">if</span> (options.modules) &#123;</span><br><span class="line">          finalOptions.modules =</span><br><span class="line">            (baseOptions.modules || []).concat(options.modules)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并自定义指令</span></span><br><span class="line">        <span class="keyword">if</span> (options.directives) &#123;</span><br><span class="line">          finalOptions.directives = extend(</span><br><span class="line">            <span class="built_in">Object</span>.create(baseOptions.directives || <span class="literal">null</span>),</span><br><span class="line">            options.directives</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并其他配置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> options) &#123;</span><br><span class="line">          <span class="keyword">if</span> (key !== <span class="string">'modules'</span> &amp;&amp; key !== <span class="string">'directives'</span>) &#123;</span><br><span class="line">            finalOptions[key] = options[key]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将传入的函数执行，传入模板和配置项,得到编译结果</span></span><br><span class="line">      <span class="keyword">const</span> compiled = baseCompile(template, finalOptions)</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        errors.push.apply(errors, detectErrors(compiled.ast))</span><br><span class="line">      &#125;</span><br><span class="line">      compiled.errors = errors</span><br><span class="line">      compiled.tips = tips</span><br><span class="line">      <span class="keyword">return</span> compiled</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      compile,</span><br><span class="line">      compileToFunctions: createCompileToFunctionFn(compile)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在<code>compile()</code>层级执行完毕后，将抛出编译函数</p>
<p><img src="https://static.yuanziwen.cn/blog/Vue/11.png_plain" alt></p>
<p><code>compile</code>是一个编译器，它会将传入的<code>template</code>转换成对应的<code>AST</code>树、<code>renderFn</code>以及<code>staticRenderFns</code>函数</p>
<p><code>compileToFunctions</code>,通过执行<code>createCompileToFunctionFn(compile)</code>得到，<code>createCompileToFunctionFn()</code>是带缓存的编译器，同时<code>staticRenderFns</code>以及<code>renderFn</code>会被转换成<code>Funtion对象</code>。最终将编译</p>
<p>不同平台有一些不同的<code>options</code>，所以<code>createCompiler</code>会根据平台区分传入一个<code>baseOptions</code>，会与<code>compile</code>本身传入的<code>options</code>进行合并得到最终的<code>finalOptions</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createCompileToFunctionFn</span> (<span class="params">compile: Function</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 声明缓存器</span></span><br><span class="line">  <span class="keyword">const</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">compileToFunctions</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    options?: CompilerOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">CompiledFunctionResult</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 合并配置</span></span><br><span class="line">    options = extend(&#123;&#125;, options)</span><br><span class="line">    <span class="keyword">const</span> warn = options.warn || baseWarn</span><br><span class="line">    <span class="keyword">delete</span> options.warn</span><br><span class="line">    <span class="comment">//开发环境下尝试检测CSP，类似于用户浏览器设置，需要放宽限制否则无法进行编译，一般情况下可以忽略</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">// detect possible CSP restriction</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'return 1'</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.toString().match(<span class="regexp">/unsafe-eval|CSP/</span>)) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">'It seems you are using the standalone build of Vue.js in an '</span> +</span><br><span class="line">            <span class="string">'environment with Content Security Policy that prohibits unsafe-eval. '</span> +</span><br><span class="line">            <span class="string">'The template compiler cannot work in this environment. Consider '</span> +</span><br><span class="line">            <span class="string">'relaxing the policy to allow unsafe-eval or pre-compiling your '</span> +</span><br><span class="line">            <span class="string">'templates into render functions.'</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有缓存的时候优先读取缓存的结果，并且返回 ，</span></span><br><span class="line">    <span class="keyword">const</span> key = options.delimiters</span><br><span class="line">      ? <span class="built_in">String</span>(options.delimiters) + template</span><br><span class="line">      : template</span><br><span class="line">    <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有缓存结果则直接编译 </span></span><br><span class="line">    <span class="keyword">const</span> compiled = compile(template, options)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查编译错误/提示 </span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (compiled.errors &amp;&amp; compiled.errors.length) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Error compiling template:\n\n<span class="subst">$&#123;template&#125;</span>\n\n`</span> +</span><br><span class="line">          compiled.errors.map(<span class="function"><span class="params">e</span> =&gt;</span> <span class="string">`- <span class="subst">$&#123;e&#125;</span>`</span>).join(<span class="string">'\n'</span>) + <span class="string">'\n'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compiled.tips &amp;&amp; compiled.tips.length) &#123;</span><br><span class="line">        compiled.tips.forEach(<span class="function"><span class="params">msg</span> =&gt;</span> tip(msg, vm))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将代码转换成功能 </span></span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> fnGenErrors = []</span><br><span class="line">    <span class="comment">// 将render转换成Funtion对象</span></span><br><span class="line">    res.render = createFunction(compiled.render, fnGenErrors)</span><br><span class="line">    <span class="comment">// 将staticRenderFns全部转化成Funtion对象</span></span><br><span class="line">    res.staticRenderFns = compiled.staticRenderFns.map(<span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createFunction(code, fnGenErrors)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查函数生成错误。只在编译器本身存在错误时才会发生,作者主要用于codegen开发使用</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((!compiled.errors || !compiled.errors.length) &amp;&amp; fnGenErrors.length) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Failed to generate render function:\n\n`</span> +</span><br><span class="line">          fnGenErrors.map(<span class="function">(<span class="params">&#123; err, code &#125;</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;err.toString()&#125;</span> in\n\n<span class="subst">$&#123;code&#125;</span>\n`</span>).join(<span class="string">'\n'</span>),</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后存放在缓存中，下一次用可以进行读取</span></span><br><span class="line">    <span class="keyword">return</span> (cache[key] = res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://static.yuanziwen.cn/blog/Vue/12.png_plain" alt><br>这里有一点很有意思，</p>
<p><code>const cache = Object.create(null)</code></p>
<p>为什么不直接<code>const cache = {}</code>呢？我们感受下</p>
<p><img src="https://static.yuanziwen.cn/blog/Vue/13.png_plain" alt><br>最直观的感受就是隐式原型<strong>proto</strong>在null上面没有，首先<code>const cache = {}</code>会继承<code>Object.prototype</code>上所有的原型方法。而null不会，另一个使用<code>Object.create(null)</code>的理由是，使用<code>for..in</code>循环的时候会遍历对象原型链上的属性，使用<code>Object.create(null)</code>就不必再对属性进行检查了，当然，我们也可以直接使用Object.keys[]。除非你想你需要一个非常干净且高度可定制的对象当作数据字典或者想节省<code>hasOwnProperty</code>的一些性能损失。</p>
<h2 id="HTML转RenderFn"><a href="#HTML转RenderFn" class="headerlink" title="HTML转RenderFn"></a>HTML转RenderFn</h2><p>我们先写点代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script&gt;</span></span><br><span class="line"><span class="regexp">      var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">        el:'#app',</span></span><br><span class="line"><span class="regexp">        template:`</span></span><br><span class="line"><span class="regexp">          &lt;div @click="changeName()"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/</span>span&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">              &lt;li v-<span class="keyword">for</span>=<span class="string">"(item,index) in like"</span> :key=<span class="string">"index"</span>&gt;&#123;&#123;item&#125;&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/u</span>l&gt;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;`,</span></span><br><span class="line"><span class="regexp">        data:&#123;</span></span><br><span class="line"><span class="regexp">          name:'Seven',</span></span><br><span class="line"><span class="regexp">          like:['旅游','电影','滑雪']</span></span><br><span class="line"><span class="regexp">        &#125;,methods:&#123;</span></span><br><span class="line"><span class="regexp">          changeName()&#123;</span></span><br><span class="line"><span class="regexp">            this.name = 'Floyd'</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;)</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p>我们先看下他的AST语法树,</p>
<p><img src="https://static.yuanziwen.cn/blog/Vue/14.png_plain" alt></p>
<p>可能你看的有点头晕，没事，我们无需关心这个，抽象，能让你看懂了还叫抽象？<br>我们再看下render函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>)&#123;<span class="keyword">return</span> _c(<span class="string">'div'</span>,&#123;<span class="attr">on</span>:&#123;<span class="string">"click"</span>:<span class="function"><span class="keyword">function</span>(<span class="params">$event</span>)</span>&#123;changeName()&#125;&#125;&#125;,[_c(<span class="string">'span'</span>,[_v(_s(name))]),_v(<span class="string">" "</span>),_c(<span class="string">'ul'</span>,_l((like),<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;<span class="keyword">return</span> _c(<span class="string">'li'</span>,&#123;<span class="attr">key</span>:index&#125;,[_v(_s(item))])&#125;))])&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便大家看清楚结构，费会劲手动格式化以下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> _c(<span class="string">'div'</span>, </span><br><span class="line">                &#123;</span><br><span class="line">                  on: &#123;</span><br><span class="line">                    <span class="string">"click"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">$event</span>) </span>&#123;</span><br><span class="line">                      changeName()</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;, </span><br><span class="line">                [</span><br><span class="line">                  _c(<span class="string">'span'</span>, [ _v(_s(name)) ]), </span><br><span class="line">                  _v(<span class="string">" "</span>), </span><br><span class="line">                  _c(<span class="string">'ul'</span>, </span><br><span class="line">                      _l( (like), <span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">                      <span class="keyword">return</span> _c(<span class="string">'li'</span>, </span><br><span class="line">                                  &#123;</span><br><span class="line">                                    key: index</span><br><span class="line">                                  &#125;, </span><br><span class="line">                                  [</span><br><span class="line">                                    _v( _s(item) )</span><br><span class="line">                                  ]</span><br><span class="line">                                )</span><br><span class="line">                    &#125;)</span><br><span class="line">                  )</span><br><span class="line">                ]</span><br><span class="line">              )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可能有些人想着更看不懂，没事，这个逻辑可以看懂的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_c(</span><br><span class="line">    <span class="string">'标签名'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        on:&#123;<span class="comment">//绑定</span></span><br><span class="line">            属性<span class="number">1</span>:值,</span><br><span class="line">            属性<span class="number">2</span>:值,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="comment">//子节点</span></span><br><span class="line">       _c(</span><br><span class="line">            <span class="string">'标签名'</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                on:&#123;<span class="comment">//绑定</span></span><br><span class="line">                    子属性<span class="number">1</span>:值,</span><br><span class="line">                    子属性<span class="number">2</span>:值,</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            [</span><br><span class="line">                <span class="comment">//子标签...</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="将renderFn编译Vnode"><a href="#将renderFn编译Vnode" class="headerlink" title="将renderFn编译Vnode"></a>将renderFn编译Vnode</h3><p>由于使用的with(this)语法，函数内有所变量都依赖于this变量，<code>_c</code>等同与<code>this._c</code>等同与<code>vm._c</code>，我们打印下<code>vm._c</code></p>
<blockquote>
<p>在<b>JavaScript语言精粹</b>一书中提到，尽量不要在你的函数内使用<code>with()</code>语法,它可能会让你的应用程序无法调试。但是尤雨溪这么使用，使用闭包将其封装在了函数内，无需担心外泄。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ƒ (a, b, c, d) &#123; <span class="keyword">return</span> createElement(vm, a, b, c, d, <span class="literal">false</span>); &#125;</span><br><span class="line"></span><br><span class="line">/src/core/instance/render.js定义该方法</span><br><span class="line"><span class="comment">// 将 createElement 函数绑定到这个实例上以便在其中获得renderFn上下文。</span></span><br><span class="line">vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>指向<code>createElement()</code>函数，它又指向<code>_createElement()</code>，该函数定义在<code>/src/core/vdom/create-element.js</code>。最终返回的是一个Vnode。该函数定义可以在本文目录里跳转查看<br>其他的函数我们可以在 <code>/rc/core/instance/render-helper/index.js</code>里找到相关定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">installRenderHelpers</span> (<span class="params">target: any</span>) </span>&#123;</span><br><span class="line">  target._o = markOnce   <span class="comment">// v-once静态组件</span></span><br><span class="line">  target._n = toNumber   <span class="comment">// 判断是否数字，先parse再isNAN</span></span><br><span class="line">  target._s = toString   <span class="comment">// 需解析的文本，之前在parser阶段已经有所修饰</span></span><br><span class="line">  target._l = renderList <span class="comment">//  v-for节点</span></span><br><span class="line">  target._t = renderSlot <span class="comment">// slot节点</span></span><br><span class="line">  target._q = looseEqual <span class="comment">//  检测两个变量是否相等</span></span><br><span class="line">  target._i = looseIndexOf <span class="comment">// 检测数组中是否包含与目标变量相等的项</span></span><br><span class="line">  target._m = renderStatic <span class="comment">// 渲染静态内容</span></span><br><span class="line">  target._f = resolveFilter <span class="comment">// filters处理</span></span><br><span class="line">  target._k = checkKeyCodes <span class="comment">// 从config配置中检查eventKeyCode是否存在</span></span><br><span class="line">  target._b = bindObjectProps <span class="comment">// 合并v-bind指令到VNode中</span></span><br><span class="line">  target._v = createTextVNode  <span class="comment">// 创建文本节点</span></span><br><span class="line">  target._e = createEmptyVNode <span class="comment">// 注释节点</span></span><br><span class="line">  target._u = resolveScopedSlots <span class="comment">// 处理ScopedSlots</span></span><br><span class="line">  target._g = bindObjectListeners <span class="comment">// 处理事件绑定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SIMPLE_NORMALIZE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> ALWAYS_NORMALIZE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wrapper function for providing a more flexible interface</span></span><br><span class="line"><span class="comment">// without getting yelled at by flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag,</span></span></span><br><span class="line"><span class="function"><span class="params">  data,</span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  normalizationType,</span></span></span><br><span class="line"><span class="function"><span class="params">  alwaysNormalize</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 兼容不传data的情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data) || isPrimitive(data)) &#123;</span><br><span class="line">    normalizationType = children;</span><br><span class="line">    children = data;</span><br><span class="line">    data = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果alwaysNormalize是true</span></span><br><span class="line">  <span class="comment">// 那么normalizationType应该设置为常量ALWAYS_NORMALIZE的值</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = ALWAYS_NORMALIZE;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// 调用_createElement创建虚拟节点</span></span><br><span class="line">  <span class="keyword">return</span> _createElement(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag,</span></span></span><br><span class="line"><span class="function"><span class="params">  data,</span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  normalizationType</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 如果存在data.__ob__，说明data是被Observer观察的数据</span></span><br><span class="line"><span class="comment">    * 不能用作虚拟节点的data</span></span><br><span class="line"><span class="comment">    * 需要抛出警告，并返回一个空节点</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 被监控的data不能被用作vnode渲染的数据的原因是：data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef((data).__ob__)) &#123;</span><br><span class="line">    <span class="string">"development"</span> !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">"Avoid using observed data object as vnode data: "</span> + (<span class="built_in">JSON</span>.stringify(data)) + <span class="string">"\n"</span> +</span><br><span class="line">      <span class="string">'Always create fresh vnode data objects in each render!'</span>,</span><br><span class="line">      context</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当组件的is属性被设置为一个false的值</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(data.is)) &#123;</span><br><span class="line">    tag = data.is;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Vue将不会知道要把这个组件渲染成什么,所以渲染一个空节点</span></span><br><span class="line">  <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果key是原始值，就警告key不能是原始值，必须string或者是number类型的值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"development"</span> !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key)</span><br><span class="line">  ) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">'Avoid using non-primitive value as key, '</span> +</span><br><span class="line">        <span class="string">'use string/number value instead.'</span>,</span><br><span class="line">        context</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 作用域插槽</span></span><br><span class="line">    <span class="comment">// 如果子元素是数组并且第一个是renderFn，就将其转移到scopedSlots</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children) &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> children[<span class="number">0</span>] === <span class="string">'function'</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    data = data || &#123;&#125;;</span><br><span class="line">    data.scopedSlots = &#123; <span class="attr">default</span>: children[<span class="number">0</span>] &#125;;</span><br><span class="line">    children.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据normalizationType的值，选择不同的处理方法</span></span><br><span class="line">  <span class="keyword">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">    children = normalizeChildren(children);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">    children = simpleNormalizeChildren(children);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> vnode, ns;</span><br><span class="line">  <span class="comment">//如果标签名是string类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> Ctor;</span><br><span class="line">    <span class="comment">// 取到如果当前有自己的vnode和命名空间 或者 获取标签名的命名空间</span></span><br><span class="line">    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag);</span><br><span class="line">    <span class="comment">// 判断是否为保留标签</span></span><br><span class="line">    <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">       <span class="comment">// 如果是保留标签,就创建一个这样的vnode</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      );<span class="comment">// 如果不是保留标签，那么我们将尝试从vm实例的components上查找是否有这个标签的定义，自定义组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(Ctor = resolveAsset(context.$options, <span class="string">'components'</span>, tag))) &#123;</span><br><span class="line">        <span class="comment">//  如果找到了这个标签的定义，就以此创建虚拟组件节点</span></span><br><span class="line">      vnode = createComponent(Ctor, data, context, children, tag);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 保底方案，正常创建一个vnode</span></span><br><span class="line">      <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">      <span class="comment">// parent normalizes children</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    <span class="comment">// 当tag不是字符串的时候，就是组件的构造类，直接创建</span></span><br><span class="line">    vnode = createComponent(tag, data, context, children);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果vnode是数组，直接返回。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">              <span class="comment">//如果有vnode</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(vnode)) &#123;</span><br><span class="line">     <span class="comment">// 如果有namespace，就应用下namespace，然后返回vnode</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(ns)) &#123; applyNS(vnode, ns); &#125;</span><br><span class="line">    <span class="comment">// 如果定义了数据，就将其深度遍历，针对于class或者是style</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) &#123; registerDeepBindings(data); &#125;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//保底创建空VNode</span></span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程图看下</p>
<p><img src="https://static.yuanziwen.cn/blog/Vue/15.png_plain" alt></p>
<h2 id="new-Vue"><a href="#new-Vue" class="headerlink" title="new Vue"></a>new Vue</h2><p>找到<code>src/core/instance/index.js</code></p>
<p><img src="https://static.yuanziwen.cn/blog/Vue/16.png_plain" alt><br>创建Vue函数，并且检测当前是不是开发环境，如果Vue不是通过new实例化的将警告。然后初始化<code>this._init(options)</code>。为什么(this instanceof Vue)这一句可以判断是否使用了new操作符？</p>
<p>已new来调用构造函数会经历4个步骤：</p>
<ul>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（因此this 就指向了这个新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象。<br>而<code>instanceof</code>用来检测Vue构造函数的<code>prototype</code>是否存在于<code>this</code>的原型链上，换句话说，如果使用<code>new</code>实例化的时候，<code>this</code>就指向了这个新创建的对象，这时<code>this instanceof Vue</code>这句话的意思就是判断新创建的对象是否是Vue类型的，也就相当于判断新实例对象的<code>constructor</code>是否是Vue构造函数。</li>
</ul>
<p>未完待续…</p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="blog.yuanziwen.cn">Seven</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="blog.yuanziwen.cn/2018/08/02/Vue源码剖析——render、patch、updata、vnode/">blog.yuanziwen.cn/2018/08/02/Vue源码剖析——render、patch、updata、vnode/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/Vue/">Vue</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2018/12/19/设计模式/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">JavaScript设计模式</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2018/07/24/一次性搞懂JvaScript执行机制/">
        <span class="next-text nav-default">一次性搞懂JvaScript执行机制</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'cxeaTV5BFDCxPmxoCcG9QPxf-gzGzoHsz',
        appKey: 's577OrPG5sB4Szom6mvHuI1X',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info: guest,
        pageSize:'10' || 10,
    });
  </script>

<footer id="footer" class="footer"><div class="social-links"><a href="mailto:yuanziwen7489757@gmail.com" class="iconfont icon-email" title="email"></a>
          <a href="https://juejin.im/user/59aa31a06fb9a02485103ddf" class="iconfont juejin" title="掘金"><div class="img"></div></a>
        <a href="https://github.com/yzw7489757" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <!--<span class="division">|</span>
  <span class="theme-info">
    footer.theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>-->
  <span class="power-by">
   <a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备18011257号-1</a>
  </span>
  <span class="copyright-year">&copy;2017 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Seven</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
<script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js?t=1593502596546')
    .then(function () {console.log('ServiceWorker Register Successfully.')})
    .catch(function (e) {console.error(e)});
}
</script></body>
</html>
