<!DOCTYPE html>
<html lang="zh-Hans">
  <head><meta name="generator" content="Hexo 3.9.0"><link rel="manifest" href="/manifest.json"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="一次性搞懂JvaScript执行机制"><meta name="keywords" content="Seven YuanZiWen"><link rel="alternate" href="/atom.xml" title="Seven Blog"><link rel="shortcut icon" type="image/x-icon" href="https://static.yuanziwen.cn/blog/favicon.ico?v=2.11.0">
<link rel="canonical" href="blog.yuanziwen.cn/2018/07/24/一次性搞懂JvaScript执行机制/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1e4ffaffd9b2bc832b39e2b866a92c7b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>一次性搞懂JvaScript执行机制 - Seven Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Seven Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Record
          </li>
      </a><a href="/logs/">
        <li class="mobile-menu-item">Log
          </li>
      </a><a href="/music/">
        <li class="mobile-menu-item">Music
          </li>
      </a><a href="/photo/">
        <li class="mobile-menu-item">Album
          </li>
      </a><a href="/book/">
        <li class="mobile-menu-item">Book
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Seven Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Record
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/logs/">
            Log
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/music/">
            Music
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/photo/">
            Album
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/book/">
            Book
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">一次性搞懂JvaScript执行机制
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-07-24
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-怎么执行的？"><span class="toc-text">JavaScript 怎么执行的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#执行机制——事件循环（Event-Loop）"><span class="toc-text">执行机制——事件循环（Event Loop）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任务队列"><span class="toc-text">任务队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步任务"><span class="toc-text">同步任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步任务"><span class="toc-text">异步任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AJAX怎么算"><span class="toc-text">AJAX怎么算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Job-Queue是什么"><span class="toc-text">Job Queue是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异步任务分为宏任务和微任务"><span class="toc-text">异步任务分为宏任务和微任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#process-nextTick"><span class="toc-text">process.nextTick</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#process-nextTick-callback"><span class="toc-text">process.nextTick(callback)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-observe"><span class="toc-text">Object.observe</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结："><span class="toc-text">总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-Worker"><span class="toc-text">Web Worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-Worker和Service-Worker的区别"><span class="toc-text">Web Worker和Service Worker的区别</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.2.1/css/hint.min.css"><p><img src="https://user-gold-cdn.xitu.io/2018/7/21/164b8954d3b097d4?imageView2/1/w/1304/h/734/q/85/format/webp/interlace/1" alt></p>
<a id="more"></a>
<p>你是否遭受到这样的恐吓？</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/21/164b88d86197ea52?imageslim" alt></p>
<p>你是否有过每个表达式前面都console一遍值去找执行顺序？</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/21/164b891f2a16b558?imageslim" alt></p>
<p>看了很多js执行机制的文章似乎都是似懂非懂，到技术面问的时候，理不清思绪。总结了众多文章的例子和精华，希望能帮到你们</p>
<h2 id="JavaScript-怎么执行的？"><a href="#JavaScript-怎么执行的？" class="headerlink" title="JavaScript 怎么执行的？"></a>JavaScript 怎么执行的？</h2><h3 id="执行机制——事件循环（Event-Loop）"><a href="#执行机制——事件循环（Event-Loop）" class="headerlink" title="执行机制——事件循环（Event Loop）"></a>执行机制——事件循环（Event Loop）</h3><p>通常所说的 <code>JavaScript Engine</code>（JS引擎）负责执行一个个 <code>chunk （可以理解为事件块）</code>的程序，每个 <code>chunk</code> 通常是以 function 为单位，一个 <code>chunk</code> 执行完成后，才会执行下一个 <code>chunk</code>。下一个 <code>chunk</code> 是什么呢？取决于当前 <code>Event Loop Queue</code> (事件循环队列）中的队首。</p>
<p>通常听到的<code>JavaScript Engine</code> 和<code>JavaScript runtime</code> 是什么？</p>
<p><code>Javascript Engine</code>  ：Js引擎，负责解释并编译代码，让它变成能交给机器运行的代码（<code>runnable commands</code>）<br><code>Javascript runtime</code> ：Js运行环境，主要提供一些对外调用的接口 。比如浏览器环境：<code>window</code>、 <code>DOM</code>。还有<code>Node.js</code>环境：<code>require</code> 、<code>export</code><br><code>Event Loop Queue</code> （事件循环队列）中存放的都是消息，每个消息关联着一个函数，<code>JavaScript Engine</code> （以下简称JS引擎）就按照队列中的消息顺序执行它们，也就是执行 <code>chunk</code>。</p>
<p>例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>当JS引擎执行的时候，可以分为3步<code>chunk</code></p>
<p>由 <code>setTimeout</code> 启动定时器<code>（1000毫秒）</code>执行<br>1.执行完毕后，得到机会将 <code>callback</code> 放入 <code>Event Loop Queue</code><br>2.此 <code>callback</code> 执行<br>3.每一步都是一个<code>chunk</code>，可以发现，第2步，得到机会很重要，所以说即使延迟<code>1000ms</code>也不一定准的原因。因为如果有其他任务在前面，它至少要等其他消息对应的程序都完成后才能将<code>callback</code>推入队列，后面我们会举个🌰</p>
<p>像这个一个一个执行chunk的过程就叫做<code>Event Loop</code>（事件循环）。</p>
<p>按照阮老师的说法：</p>
<blockquote><p> 总体角度：主线程执行的时候产生栈(<code>stack</code>)和堆(<code>heap</code>)，栈中的代码负责调用各种API，在任务队列中加入事件(click，load，done），只要栈中的代码执行完毕后，就会去读取任务队列，依次执行那些事件所对应的回调函数。<br>执行的机制流程 </p>
</blockquote>

<blockquote><p>同步直接进入主线程执行，如果是异步的，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。 </p>
</blockquote>

<p>我们都知道，JS引擎 对 <code>JavaScript</code> 程序的执行是单线程的，为了防止同时去操作一个数据造成冲突或者是无法判断，但是 JavaScript Runtime（整个运行环境）并不是单线程的；而且几乎所有的异步任务都是并发的，例如多个 <code>Job Queue</code>、<code>Ajax、Timer、I/O(Node)</code>等等。</p>
<p>而<code>Node.js</code>会略有不同，在<code>node.js</code>启动时，创建了一个类似<code>while(true)</code>的循环体，每次执行一次循环体称为一次tick，每个tick的过程就是查看是否有事件等待处理，如果有，则取出事件极其相关的回调函数并执行，然后执行下一次tick。<code>node</code>的<code>Event Loop</code>和浏览器有所不同。<code>Event Loop</code>每次轮询：先执行完主代码，期中遇到异步代码会交给对应的队列，然后先执行完所有<code>nextTick()</code>，然后在执行其它所有微任务。</p>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>任务队列<code>task queue</code>中有微任务队列和宏任务队列</p>
<p>1.微任务队列只有一个<br>2.宏任务可以有若干个<br>根据目前，我们先大概画个草图<br><img src="https://user-gold-cdn.xitu.io/2018/7/20/164b5e53520eb34a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>具体部分后面会讲，那先说说同步和异步</p>
<p>执行机制——同步任务(<code>synchronous</code>)和异步任务(<code>asynchronous</code>)<br>事件分为同步和异步</p>
<h3 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h3><p>同步任务直接进入主线程进行执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">    sub++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sub);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>会点编程的都知道，在打印出<code>sub</code>的值之前，系统是不会打印出2的。按照先进先出的顺序执行<code>chunk</code>。</p>
<p>如果是<code>Execution Context Stack</code>（执行上下文堆栈）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>从执行顺序上，首先<code>log(&#39;a&#39;)</code>入栈，然后<code>console.log(&#39;a&#39;)</code>再入栈，执行<code>console.log(&#39;a&#39;)</code>出栈，<code>log(&#39;a&#39;)</code>再出栈。</p>
<h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>异步任务必须指定回调函数，所谓”回调函数”（<code>callback</code>），就是那些会被主线程挂起来的代码。异步任务进入<code>Event Table</code>后，当指定的事情完成了，就将异步任务加入<code>Event Queue</code>，等待主线程上的任务完成后，就执行<code>Event Queue</code>里的异步任务，也就是执行对应的回调函数。<br>指定的事情可以是<code>setTimeout</code>的<code>time</code>🌰</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    value = <span class="number">2</span>;</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(value);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>从这个例子很容易理解，即使设置时间再短，<code>setTimeout</code>还是要等主线程执行完再执行，导致引用还是最初的<code>value</code>值</p>
<p>🌰</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'task1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="built_in">console</span>.log(<span class="string">'task2'</span>) &#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">1000000000</span>;i++) &#123;</span><br><span class="line">    sub++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sub);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'task3'</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2018/7/19/164b21c9884820c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>分析一下</p>
<p><code>task1</code>进入主线程立即执行<br><code>task2</code>进入<code>Event Table</code>，注册完事件<code>setTimeout</code>后进入<code>Event Queue</code>，等待主线程执行完毕<br><code>sub</code>赋值后进入<code>for</code>循环自增，主线程一直被占用<br>计算完毕后打印出<code>sub</code>，主线程继续<code>chunk</code><br><code>task3</code>进入主线程立即执行<br>主线程队列已清空，到<code>Event Queue</code>中执行任务，打印<code>task2</code><br>不管<code>for</code>循环计算多久，只要主线程一直被占用，就不会执行<code>Event Queue</code>队列里的任务。除非主线任务执行完毕。所有我们通常说的<code>setTimeout</code>的<code>time</code>是不标准的，准确的说，应该是大于等于这个<code>time</code></p>
<p>来个🌰体验一下结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sub = <span class="number">0</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">setTime</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> start = (<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf();<span class="comment">//开始时间</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'执行开始'</span>,start)</span><br><span class="line">	setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123; </span><br><span class="line">	   <span class="built_in">console</span>.log(<span class="string">'定时器结束'</span>,sub,(<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf()-start);<span class="comment">//计算差异</span></span><br><span class="line">	&#125;,<span class="number">0</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">1000000000</span>;i++) &#123;</span><br><span class="line">    sub++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'执行结束'</span>)</span><br></pre></td></tr></table></figure>

<p>实际上，延迟会远远大于预期，达到了<code>3004</code>毫秒<br><img src="https://user-gold-cdn.xitu.io/2018/7/20/164b5c2b6d8077cd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>最后的计算结果是根据浏览器的运行速度和电脑配置差异而定，这也是<code>setTimeout</code>最容易被坑的一点。</p>
<h3 id="AJAX怎么算"><a href="#AJAX怎么算" class="headerlink" title="AJAX怎么算"></a>AJAX怎么算</h3><p>那<code>ajax</code>怎么算，作为日常使用最多的一种异步，我们必须搞清楚它的运行机制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">'xxx.com?user=123'</span>,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'success'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>)</span><br><span class="line">&#125;,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure>

<p>答案是不肯定的，可能是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">timeout</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<p>也有可能是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">success</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>

<p>前两步没有疑问，都是作为同步函数执行，问题原因出在<code>ajax</code>身上</p>
<p>前面我们说过，异步任务必须有<code>callback</code>，<code>ajax</code>的<code>callback</code>是<code>success</code>()，也就是只有当请求成功后，触发了对应的<code>callback success</code>()才会被放入任务队列(<code>Event Queue</code>)等待主线程执行。而在请求结果返回的期间，后者的<code>setTimeout</code>很有可能已经达到了指定的条件(执行<code>100</code>毫秒延时完毕）将它的回调函数放入了任务队列等主线程执行。这时候可能<code>ajax</code>结果仍未返回…</p>
<p><code>Promise</code>的执行机制<br>再加点料</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'执行开始'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timeout'</span>) </span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'进入'</span>)</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Promise执行完毕'</span>) )</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'执行结束'</span>);</span><br></pre></td></tr></table></figure>

<p>先别继续往下看，假设你是浏览器，你会怎么运行，自我思考十秒钟<br><img src="https://user-gold-cdn.xitu.io/2018/7/19/164b2786a4e323af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>这里要注意，严格的来说，<code>Promise</code> 属于 <code>Job Queue</code>，只有<code>then</code>才是异步。</p>
<h2 id="Job-Queue是什么"><a href="#Job-Queue是什么" class="headerlink" title="Job Queue是什么"></a>Job Queue是什么</h2><p><code>Job Queue</code>是<code>ES6</code>新增的概念。</p>
<p><code>Job Queue</code>和<code>Event Loop Queue</code>有什么区别？</p>
<p><code>JavaScript runtime</code>（<code>JS</code>运行环境）可以有多个<code>Job Queue</code>，但是只能有一个<code>Event Loop Queue</code>。<br><code>JS</code>引擎将当前<code>chunk</code>执行完会优先执行所有<code>Job Queue</code>，再去执行<code>Event Loop Queue</code>。<br><code>Promise</code> 中的一个个 <code>then</code> 就是一种 <code>Job Queue</code>。<br>分析流程：</p>
<blockquote>
<p>遇到同步任务，进入主线程直接执行，打印出”执行开始”<br>遇到<code>setTimeout</code>异步任务放入<code>Event Table</code>执行，满足条件后放入<code>Event Queue</code>的宏任务队列等待主线程执行<br>执行<code>Promise</code>，放入<code>Job Queue</code>优先执行，执行同步任务打印出”进入”<br>返回<code>resolve</code>()触发<code>then</code>回调函数，放入<code>Event Queue</code>微任务队列等待主线程执行<br>执行同步任务打印出”执行结束”<br>主线程清空，到<code>Event Queue</code>的微任务队列取出任务开始执行。打印出”<code>Promise</code>执行完毕”<br>微任务队列清空，到宏任务队列取出任务执行，打印出”<code>timeout</code>“<br>🌰 Plus</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"setTimeout"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"A1"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"A2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"B1"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"B2"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"B3"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br></pre></td></tr></table></figure>

<p>打印结果<br><img src="https://user-gold-cdn.xitu.io/2018/7/20/164b73a4c094b64c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>运用刚刚说说的，分析一遍</p>
<blockquote>
<p><code>setTimeout</code>异步任务，到<code>Event Table</code>执行完毕后将<code>callback</code>放入<code>Event Queue</code>宏任务队列等待主线程执行<br><code>Promise</code> 放入<code>Job Queue</code>优先进入主线程执行，返回<code>resolve</code>()，触发<code>A1 then</code>回调函数放入微任务队列中等待主线程执行<br>到第二个<code>Promise</code>，同上，放入<code>Job Queue</code>执行，将<code>B1 then</code>回调函数放入微任务队列<br>执行同步函数，直接进入主线程执行，打印出”<code>end</code>“<br>无同步任务，开始从<code>task Queue</code> 也就是 <code>Event Queue</code>里取出异步任务开始执行<br>首先取出队首的<code>A1 then</code>()回调函数开始执行，打印出”<code>A1</code>“，返回<code>promise</code>触发<code>A2 then</code>()回调函数，添加到微任务队首。此时队首是<code>B1 then</code>()<br>从微任务队首取出<code>B1 then</code>回调函数，开始执行，返回<code>promise</code>触发<code>B2 then</code>()回调函数，添加到微任务队首，此时队首是<code>A2 then</code>()，再取出<code>A2 then</code>()执行，这次没有回调<br>继续到微任务队首拿回调执行，重复轮询打印出<code>B2</code>和<code>B3</code>。<br>微任务执行完毕，到宏任务队首取出<code>setTimeout</code>的回调函数放入主线程执行，打印出”<code>setTimeout</code>“。<br>这样的话，<code>Promise</code>应该是搞懂了，但是微任务和宏任务？很多人对这个可能有点陌生，但是看完这个应该对这两者区别有所了解</p>
</blockquote>
<h3 id="异步任务分为宏任务和微任务"><a href="#异步任务分为宏任务和微任务" class="headerlink" title="异步任务分为宏任务和微任务"></a>异步任务分为宏任务和微任务</h3><blockquote>
<p>宏任务（macrotasks）： setTimeout, setInterval, setImmediate(node.js), I/O, UI rendering<br>微任务（microtasks）：process.nextTick(node.js), Promises, Object.observe, MutationObserver<br>先看一下具有特殊性的API：</p>
</blockquote>
<h4 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h4><p><code>node</code>方法,<code>process.nextTick</code>可以把当前任务添加到执行栈的尾部，也就是在下一次<code>Event Loop</code>（主线程读取”任务队列”）之前执行。也就是说，它指定的任务一定会发生在所有异步任务之前。和<code>setTimeout</code>(<code>fn</code>,<code>0</code>)很像。</p>
<h4 id="process-nextTick-callback"><a href="#process-nextTick-callback" class="headerlink" title="process.nextTick(callback)"></a>process.nextTick(callback)</h4><p><code>setImmediate</code><br><code>Node.js0.8</code>以前是没有<code>setImmediate</code>的，在当前”任务队列”的尾部添加事件，官方称<code>setImmediate</code>指定的回调函数，类似于<code>setTimeout</code>(<code>callback</code>,<code>0</code>)，会将事件放到下一个事件循环中，所以也会比<code>nextTick</code>慢执行，有一点——需要了解<code>setImmediate</code>和<code>nextTick</code>的区别。<code>nextTick</code>虽然异步执行，但是不会给其他<code>io</code>事件执行的任何机会，而<code>setImmediate</code>是执行于下一个<code>event loop</code>。总之<code>process.nextTick</code>()的优先级高于<code>setImmediate</code></p>
<p><code>setImmediate</code>(<code>callback</code>)<br><code>MutationObserver</code><br>一定发生在<code>setTimeout</code>之前，你可以把它看成是<code>setImmediate</code>。<code>MutationObserver</code>是一个构造器，接受一个<code>callback</code>参数，用来处理节点变化的回调函数，返回两个参数</p>
<p><code>mutations</code>：节点变化记录列表（<code>sequence</code>&lt;<code>MutationRecord</code>&gt;）<br><code>observer</code>：构造<code>MutationObserver</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observe = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations,observer</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// code...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在这不说过多，可以去了解下具体用法</p>
<h4 id="Object-observe"><a href="#Object-observe" class="headerlink" title="Object.observe"></a>Object.observe</h4><p><code>Object.observe</code>方法用于为对象指定监视到属性修改时调用的回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.observe(obj, <span class="function"><span class="keyword">function</span>(<span class="params">changes</span>)</span>&#123;</span><br><span class="line">   changes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">change</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(change,change.oldValue);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>什么情况下才会触发？</p>
<blockquote>
<p>原始<code>JavaScript</code>对象中的变化<br>当属性被添加、改变、或者删除时的变化<br>当数组中的元素被添加或者删除时的变化<br>对象的原型发生的变化<br>来个大🌰</p>
</blockquote>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>任务优先级</p>
<p><code>同步任务</code> &gt;&gt;&gt;  <code>process.nextTick</code> &gt;&gt;&gt; <code>微任务(ajax/callback)</code> &gt;&gt;&gt; <code>setTimeout</code> = <code>宏任务</code> ??? <code>setImmediate</code></p>
<p><code>setImmediate</code>是要等待下一次事件轮询，也就是本次结束后执行，所以需要画???</p>
<p>没有把<code>Promise</code>的<code>Job Queue</code>放进去是因为可以当成同步任务来进行处理。要明确的一点是，它是严格按照这个顺序去执行的，每次执行都会把以上的流程走一遍，都会再次轮询走一遍，然后把处理对应的规则。</p>
<p>拿个别人的🌰加点料，略微做一下修改，给大家分析一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line"></span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>); <span class="comment">//添加了1000ms</span></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//添加setImmediate函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'13'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>第一遍Event Loop </p>
<p>走到<code>1</code>的时候，同步任务直接打印<br>遇到<code>setTimeout</code>，进入<code>task</code> 执行<code>1000ms</code>延迟，此时未达到，不管它，继续往下走。<br>遇到<code>process.nextTick</code>，放入执行栈队尾（将于异步任务执行前执行）。<br>遇到<code>Promise</code> 放入 <code>Job Queue</code>，<code>JS</code>引擎当前无<code>chunk</code>，直接进入主线程执行，打印出<code>7</code><br>触发<code>resolve</code>()，将<code>then 8</code> 放入微任务队列等待主线程执行，继续往下走<br>遇到<code>setTimeout</code>，执行完毕，将<code>setTimeout 9</code> 的 <code>callback</code> 其放入宏任务队列<br>遇到<code>setImmediate</code>，将其<code>callback</code>放入<code>Event Table</code>，等待下一轮<code>Event Loop</code>执行<br>第一遍完毕  <code>1</code>、<code>7</code></p>
<p>当前队列<br><img src="https://user-gold-cdn.xitu.io/2018/7/22/164c0a26b166efb3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>Number two  Ready Go！</p>
<p>无同步任务，准备执行异步任务，<code>JS</code>引擎一看:”嘿！好家伙，还有个<code>process</code>“，然后取出<code>process.nextTick</code>的回调函数执行，打印出<code>6</code><br>再继续去微任务队首取出<code>then 8</code>，打印出<code>8</code>。<br>微任务队列清空了，就到宏任务队列取出<code>setTimeout 9 callback</code>执行，打印出<code>9</code><br>继续往下执行，又遇到<code>process.nextTick 10</code>，放入<code>Event Queue</code>等待执行<br>遇到<code>Promise</code> ，将<code>callback</code> 放入 <code>Job Queue</code>，当前无<code>chunk</code>，执行打印出 <code>11</code><br>触发<code>resolve</code>()，添加回调函数<code>then 12</code>，放入微任务队列<br>本次<code>Event Loop</code>还没有结束，同步任务执行完毕，目前任务队列</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/22/164c0a296b316562?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>再取出<code>process.nextTick 10</code>，打印出<code>10</code><br>去微任务队列，取出<code>then 12</code> 执行，打印出<code>12</code><br>本次<code>Event Loop</code>轮询结束 ，取出<code>setImmediate</code>打印出<code>13</code>。<br>第二遍轮询完毕，打印出了 <code>6</code>、<code>8</code>、<code>9</code>、<code>11</code>、<code>10</code>、<code>12</code>、<code>13</code></p>
<p>当前没有任务了，过了大概<code>1000ms</code>，之前的<code>setTimeout</code> 延迟执行完毕了，放入宏任务</p>
<p><code>setTimeout</code>进入主线程开始执行。<br>遇到同步任务，直接执行，打印出<code>2</code><br>遇到<code>process.nextTick</code>，<code>callback</code>放入<code>Event Queue</code>，等待同步任务执行完毕<br>遇到<code>Promise</code>，<code>callback</code>放入<code>Job Queue</code>，当前无<code>chunk</code>，进入主线程执行，打印出<code>4</code><br>触发<code>resolve</code>()， 将<code>then 5</code>放入微任务队列<br>同步执行完毕，先看下目前的队列</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/22/164c09f3c4025fc8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>剩下的就很轻松了</p>
<p>取出<code>process.nextTick 3 callback</code>执行，打印出<code>3</code><br>取出微任务 <code>then 5</code>，打印出 <code>5</code><br><code>over</code><br>总体打印顺序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>emmm…可能需要多看几遍消化一下。</p>
<h3 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h3><p>现在有了<code>Web Worker</code>，它是一个独立的线程，但是仍未改变原有的单线程，<code>Web Worker</code>只是个额外的线程，有自己的内存空间（栈、堆）以及 <code>Event Loop Queue</code>。要与这样的不同的线程通信，只能通过 <code>postMessage</code>。一次 <code>postMessage</code> 就是在另一个线程的 <code>Event Loop Queue</code> 中加入一条消息。说到<code>postMessage</code>可能有些人会联想到<code>Service Work</code>，但是他们是两个截然不同</p>
<h3 id="Web-Worker和Service-Worker的区别"><a href="#Web-Worker和Service-Worker的区别" class="headerlink" title="Web Worker和Service Worker的区别"></a>Web Worker和Service Worker的区别</h3><p><code>Service Worker</code>:<br>处理网络请求的后台服务。完美的离线情况下后台同步或推送通知的处理方案。不能直接与<code>DOM</code>交互。通信（页面和<code>Service Worker</code>之间）得通过<code>postMessage</code>方法 ，有另一篇文章是关于本地储存，其中运用到页面离线访问<code>Service Work of</code>  <code>Google PWA</code>，有兴趣的可以看下</p>
<p><code>Web Worker</code>:<br>模仿多线程，允许复杂的脚本在后台运行，所以它们不会阻止其他脚本的运行。是保持您的<code>UI</code>响应的同时也执行处理器密集型功能的完美解决方案。不能直接与<code>DOM</code>交互。通信必须通过<code>postMessage</code>方法 </p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="blog.yuanziwen.cn">Seven</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="blog.yuanziwen.cn/2018/07/24/一次性搞懂JvaScript执行机制/">blog.yuanziwen.cn/2018/07/24/一次性搞懂JvaScript执行机制/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/JavaScript/">JavaScript</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2018/08/02/Vue源码剖析——render、patch、updata、vnode/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Vue源码剖析——render、patch、updata、vnode</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2018/07/01/vue源码——snabbdom虚拟DOM/">
        <span class="next-text nav-default">vue源码——snabbdom虚拟DOM（转载）</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'cxeaTV5BFDCxPmxoCcG9QPxf-gzGzoHsz',
        appKey: 's577OrPG5sB4Szom6mvHuI1X',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info: guest,
        pageSize:'10' || 10,
    });
  </script>

<footer id="footer" class="footer"><div class="social-links"><a href="mailto:yuanziwen7489757@gmail.com" class="iconfont icon-email" title="email"></a>
          <a href="https://juejin.im/user/59aa31a06fb9a02485103ddf" class="iconfont juejin" title="掘金"><div class="img"></div></a>
        <a href="https://github.com/yzw7489757" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <!--<span class="division">|</span>
  <span class="theme-info">
    footer.theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>-->
  <span class="power-by">
   <a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备18011257号-1</a>
  </span>
  <span class="copyright-year">&copy;2017 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Seven</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
<script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js?t=1624262701310')
    .then(function () {console.log('ServiceWorker Register Successfully.')})
    .catch(function (e) {console.error(e)});
}
</script></body>
</html>
