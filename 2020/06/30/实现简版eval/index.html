<!DOCTYPE html>
<html lang="zh-Hans">
  <head><meta name="generator" content="Hexo 3.9.0"><link rel="manifest" href="/manifest.json"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="实现简版eval"><meta name="keywords" content="Seven YuanZiWen"><link rel="alternate" href="/atom.xml" title="Seven Blog"><link rel="shortcut icon" type="image/x-icon" href="https://static.yuanziwen.cn/blog/favicon.ico?v=2.11.0">
<link rel="canonical" href="blog.yuanziwen.cn/2020/06/30/实现简版eval/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1e4ffaffd9b2bc832b39e2b866a92c7b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>实现简版eval - Seven Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Seven Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Record
          </li>
      </a><a href="/logs/">
        <li class="mobile-menu-item">Log
          </li>
      </a><a href="/music/">
        <li class="mobile-menu-item">Music
          </li>
      </a><a href="/photo/">
        <li class="mobile-menu-item">Album
          </li>
      </a><a href="/book/">
        <li class="mobile-menu-item">Book
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Seven Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Record
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/logs/">
            Log
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/music/">
            Music
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/photo/">
            Album
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/book/">
            Book
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">实现简版eval
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-06-30
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#技术背景"><span class="toc-text">技术背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#技术目标"><span class="toc-text">技术目标</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#方案"><span class="toc-text">方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AST"><span class="toc-text">AST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态机"><span class="toc-text">状态机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作"><span class="toc-text">准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运算顺序"><span class="toc-text">运算顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行过程"><span class="toc-text">执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行上下文"><span class="toc-text">执行上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用类型"><span class="toc-text">引用类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现"><span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概览"><span class="toc-text">概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管理状态"><span class="toc-text">管理状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#状态简化"><span class="toc-text">状态简化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#梳理简化后的状态"><span class="toc-text">梳理简化后的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利于运算"><span class="toc-text">利于运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂数据声明"><span class="toc-text">复杂数据声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用"><span class="toc-text">引用</span></a></li></ol>
    </li></div>
  </div><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.2.1/css/hint.min.css"><p><img src="https://static.yuanziwen.cn/blog/eval/1.png_plain" alt></p>
<h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p>表单域能力逻辑需要一层安全层过滤能力，预防传入的表单协议含有敏感数据或者调用原生能力造成 XSS 攻击。</p>
<h3 id="技术目标"><a href="#技术目标" class="headerlink" title="技术目标"></a>技术目标</h3><p>轻量体积，符合 eval 同步运算结果，可定制规则、过滤关键词、运算符，剔除冗余能力(原型链、Symbol、继承)，屏蔽原生能力，自成体系，定位是计算表达式且具备执行一定长度下符合脚本规则的能力。</p>
<a id="more"></a>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><p>有现成的社区开源库: espree、acorn、babylon 等，根据 Parse-API 规范实现，很快就否决，这几个库本身的定位就是为了遵循规范，定制规则不便 —— 比如+的优先级比-高,var 声明提高到全局作用域。</p>
<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>有限状态机（Finite-state machine）是一个模型，用来表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型，因为它的状态是“有限的”，所以可以模拟世界上大部分事物。</p>
<p>例如<a href="http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm" target="_blank" rel="noopener">TCP 协议状态机</a>。</p>
<p><img src="https://static.yuanziwen.cn/blog/eval/2.png_plain" alt></p>
<p>看起来比较绕，但在代码中很常见。e.g. 某个字符串内存在 <code>abc</code>;</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasFirstCode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) === <span class="string">"a"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> hasSecondCode(str.substr(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hasFirstCode(str.substr(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasSecondCode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) === <span class="string">"b"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> hasThirdCode(str.substr(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hasFirstCode(str); <span class="comment">// fix aabc</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasThirdCode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) === <span class="string">"c"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hasFirstCode(str);</span><br><span class="line">&#125;</span><br><span class="line">hasFirstCode(<span class="string">"fabc"</span>); <span class="comment">// true</span></span><br><span class="line">hasFirstCode(<span class="string">"aabc"</span>); <span class="comment">// true</span></span><br><span class="line">hasFirstCode(<span class="string">"cbc"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>其状态如下</p>
<p><img src="https://static.yuanziwen.cn/blog/eval/3.png_plain" alt></p>
<p>状态机可归纳为 4 个要素，</p>
<ul>
<li>现态，即当前现有状态。</li>
<li>条件，当满足某个条件，触发某个动作或执行一次状态的迁移。</li>
<li>动作，条件满足后执行的动作，非必需<ul>
<li>可以不执行任何动作，直接迁移到新状态。</li>
<li>当动作执行完毕后可以迁移到新的状态，也可以仍旧保持原状态。</li>
</ul>
</li>
<li>次态，条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”。</li>
</ul>
<p>状态的阶段：</p>
<ul>
<li>“现态”和“条件”是因。</li>
<li>“动作”和“次态”是果。</li>
</ul>
<p>状态机一般分为三种类型：</p>
<ul>
<li><p>Moore 型状态机：下一状态只由当前状态决定，即次态=f(现态，输入),与 Mealy 一致，不同的是输出=f（现态）,输出只与当前的状态有关，输入只决定状态机内部的状态改变，不影响最终的输出。输出$\Delta$依赖于现态$\mathrm{Q}$</p>
<blockquote>
<p>$\lambda = \mathrm{Q} \to \Delta $</p>
</blockquote>
</li>
<li><p>Mealy 型状态机：下一状态不但与当前状态有关，还与当前输入值有关，即次态=f(现态，输入) 与 Moore 一致，不同的是输出=f（现态，输入），输出$\Delta$依赖于现态$\mathrm{Q}$和输入 $\Sigma$</p>
<blockquote>
<p>$\lambda = \mathrm{Q} \times \Sigma \to \Delta $</p>
</blockquote>
</li>
</ul>
<p>因为 Moore 输出是固定故平常很少使用到，大多数使用的都是 Mealy 型状态机，本文就状态机实现。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>熟悉一些基本点</p>
<h3 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h3><p>运算符的权重根据以下表进行：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>. <a href></a></td>
<td>成员属性访问、数组下标、函数调用以及表达式分组</td>
</tr>
<tr>
<td>++ – - ~ ! delete new typeof void</td>
<td>一元运算符、返回数据类型、new 操作符、未定义值</td>
</tr>
<tr>
<td>* / %</td>
<td>乘法、除法、取模+ -加法、减法、字符串拼接</td>
</tr>
<tr>
<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
<td>移位</td>
</tr>
<tr>
<td>&lt; &lt;= &gt; &gt;= instanceof</td>
<td>小于、小于等于、大于、大于等于、instanceof</td>
</tr>
<tr>
<td>== != === !==</td>
<td>等于、不等于、严格相等、非严格相等</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
</tr>
<tr>
<td>?:</td>
<td>条件（三目运算符）</td>
</tr>
<tr>
<td>= OP =</td>
<td>赋值、连续赋值、运算赋值加等，减等，除等，幂等，模等，按位*等</td>
</tr>
<tr>
<td>,</td>
<td>多重求值</td>
</tr>
</tbody></table>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>Js 引擎执行过程分为三个阶段</p>
<ul>
<li>语法分析, 检查语法错误。</li>
<li>预编译，简单理解就是在内存中开辟一些空间，存放一些变量与函数。</li>
<li>执行阶段，也就是解释执行。</li>
</ul>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>上下文也称作用域，执行上下文又分为：GO（Global Object）初始化执行和 AO（Activity Object）运行时执行。</p>
<p>GO 是全局上下文，全局环境初始化生成。</p>
<p>AO 则负责动态作用域，JavaScript 采用的词法作用域(lexical scoping)，也就是静态作用域，与之相对应的便是在执行态的动态作用域。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>JavaScript 基础类型不不做解释了，引用类型也就是复杂类型是读写是根据栈[stack]内存中保存了指向堆[Heap]内存中的引用指针，真实的值是存在堆中的。<br>例如<code>var foo = { bar: 1}</code>转化以下伪代码:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">heap<span class="number">.0</span>x0012ffad = &#123; bar: <span class="number">1</span>&#125;;</span><br><span class="line">stack[Symbol(foo)] = <span class="number">0x0012ffad</span>;</span><br></pre></td></tr></table></figure>

<p>解析<code>var n = 1</code> 在 JavaScript 是怎样执行。</p>
<p>V8 是将声明和赋值分开处理的，其解析成<code>var n; n = 1;</code>, <code>n = 1</code>还是在原处，相当于拆散了，为了处理声明提升，在每层作用域都会维护一个独立的声明作用域（<code>variables_</code> 表），这样运行时就可以从声明作用域中递归查找变量。</p>
<p>首先是初始化 GO，<code>var n</code>，查看当前 scope 是否存在变量<code>n</code>,由于<code>Parser::Declare</code> 提升放到该层的作用域内。存在则跳过该声明，继续解析。</p>
<p>然后进行的是 LHS(Left-Hand-Side)查询。将右侧 RHS 查找源值（读操作）赋值（写操作）给左侧变量。从宽泛的定义上可以理解成 LHS 是引用查询，RHS 是根据引用或值查找源值 —— 例如函数传参<code>fn(n)</code> 和 运算<code>a+b</code>;</p>
<p>在 JavaScript 里，我们无法通过正常办法拿到引用地址，但是可以通过一些取巧的方式取到。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>既然使用状态机，词法解析与“编译”保持同步。</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>不需要一次性解析全部的代码，故分为解析阶段和运算阶段。</p>
<ol>
<li>解析阶段包括词法解析(生成 token-stream)、语法校验 (甄别符合规范预期) 和语义分析 (根据关系生成指令供解算)，语法校验稍前于词法解析，作为词法解析的前置行为，功能耦合的同时也将部分词法解析器的压力分担掉；两者具有各自的类型规范，词法解析得到 Token 与 Instruction 指令，用于第二步运算。</li>
<li>运算阶段代替的是解释执行，结合传入的定义变量与配置进行运算，得到结果，在每层运算周期中含有 scope 和 global 两个作用域环境，这样即可以模拟作用域。</li>
</ol>
<blockquote>
<p>Token，词法分析是将字符序列转换为 Token 序列的过程生成的过程，Token 概括了序列内每个标记的类型、值和其他信息。</p>
</blockquote>
<blockquote>
<p>Instruction，根据当前 Token 的“现态”去进行“条件”的匹配完成“动作”得到“次态”生成的产物，说白了就是语义分析后得到的指令。</p>
</blockquote>
<p>首先必须拿到 token，例如 <code>var a = 1 + 1</code> 的解析代码</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> token = [];</span><br><span class="line"><span class="keyword">const</span> Instruction = [];</span><br><span class="line"><span class="keyword">const</span> expression = <span class="string">`var a = 1 + 1`</span>;</span><br><span class="line"><span class="keyword">let</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// -------Token Type</span></span><br><span class="line"><span class="keyword">const</span> TOKEN_VAR = <span class="string">"token_VAR"</span>; <span class="comment">// 赋值操作符</span></span><br><span class="line"><span class="keyword">const</span> TOKEN_NAME = <span class="string">"token_name"</span>; <span class="comment">// 名称</span></span><br><span class="line"><span class="keyword">const</span> TOKEN_NUMBER = <span class="string">"token_number"</span>; <span class="comment">// 数字</span></span><br><span class="line"><span class="keyword">const</span> TOKEN_OPERATOR = <span class="string">"token_operator"</span>; <span class="comment">// 操作符</span></span><br><span class="line"><span class="comment">// -------Token</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newToken</span>(<span class="params"><span class="keyword">type</span>, value, pos</span>) </span>&#123;</span><br><span class="line">  token.push(</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(<span class="literal">null</span>), &#123;</span><br><span class="line">      <span class="keyword">type</span>,</span><br><span class="line">      value,</span><br><span class="line">      pos,</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p === expression.length - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (isWhiteSpace()) &#123;</span><br><span class="line">    <span class="keyword">return</span> next();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isVariable() || isOperator() || isNumber() || isName()) &#123;</span><br><span class="line">    <span class="keyword">return</span> next();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`Unexpected identifier`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWhiteSpace</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> matchWS = <span class="regexp">/^(\t|\n|\r|\s)/</span>.exec(expression.substr(p).charAt(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">if</span> (matchWS &amp;&amp; matchWS[<span class="number">1</span>]) &#123;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isVariable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// match variable ident</span></span><br><span class="line">  <span class="keyword">const</span> word = expression.substr(p).match(<span class="regexp">/\b\w*\b/</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">"const"</span>, <span class="string">"var"</span>, <span class="string">"let"</span>].includes(word)) &#123;</span><br><span class="line">    newToken(TOKEN_VAR, word, p);</span><br><span class="line">    p += word.length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> first = expression.charAt(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span> (first === <span class="string">"_"</span> || first === <span class="string">"$"</span> || <span class="regexp">/^[a-zA-Z]/</span>.test(first)) &#123;</span><br><span class="line">    result = <span class="regexp">/^((_|$)?[0-9a-zA-Z|$|_]&#123;1,&#125;)/</span>.exec(expression.substr(p));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    result === <span class="literal">undefined</span> ||</span><br><span class="line">    result === <span class="literal">null</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> result[<span class="number">1</span>] !== <span class="string">"string"</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [, result] = result;</span><br><span class="line">  p += result.length;</span><br><span class="line">  newToken(TOKEN_NAME, result, p);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="regexp">/(^([1-9]\d*(\.\d+)|(\d*(\.\d+)?)))/</span>.exec(</span><br><span class="line">    expression.substr(p)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; result[<span class="number">1</span>]) &#123;</span><br><span class="line">    newToken(TOKEN_NUMBER, result[<span class="number">1</span>], p);</span><br><span class="line">    p += result[<span class="number">1</span>].length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOperator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="regexp">/^((\+\+)|(\-\-)|(\|\|)|(\&amp;\&amp;)|(\=\=)|(\!\=)|(\&gt;\=)|(\&lt;\=)|(\+)|(\-)|(\!)|(\~)|(\*)|(\/)|(\=)|(\;))/</span>.exec(</span><br><span class="line">    expression.substr(p)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; result[<span class="number">1</span>]) &#123;</span><br><span class="line">    newToken(TOKEN_OPERATOR, result[<span class="number">1</span>], p);</span><br><span class="line">    p += result[<span class="number">1</span>].length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">next();</span><br></pre></td></tr></table></figure>

<p><img src="https://static.yuanziwen.cn/blog/eval/4.png_plain" alt><br>此时的状态取到的 tokenize</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;<span class="attr">type</span>: <span class="string">"token_var"</span>, <span class="attr">value</span>: <span class="string">"var"</span>, <span class="attr">pos</span>: <span class="number">3</span>&#125;</span><br><span class="line">  &#123;<span class="attr">type</span>: <span class="string">"token_name"</span>, <span class="attr">value</span>: <span class="string">"a"</span>, <span class="attr">pos</span>: <span class="number">5</span>&#125;</span><br><span class="line">  &#123;<span class="attr">type</span>: <span class="string">"token_operator"</span>, <span class="attr">value</span>: <span class="string">"="</span>, <span class="attr">pos</span>: <span class="number">6</span>&#125;</span><br><span class="line">  &#123;<span class="attr">type</span>: <span class="string">"token_number"</span>, <span class="attr">value</span>: <span class="string">"1"</span>, <span class="attr">pos</span>: <span class="number">9</span>&#125;</span><br><span class="line">  &#123;<span class="attr">type</span>: <span class="string">"token_operator"</span>, <span class="attr">value</span>: <span class="string">"+"</span>, <span class="attr">pos</span>: <span class="number">10</span>&#125;</span><br><span class="line">  &#123;<span class="attr">type</span>: <span class="string">"token_number"</span>, <span class="attr">value</span>: <span class="string">"1"</span>, <span class="attr">pos</span>: <span class="number">13</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>光取到 tokenize 没用，还必须进行语义分析，分析 tokenize 序列之间的关系，分析它们到底要做什么。</p>
<p>比如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">type</span>: <span class="string">"token_var"</span>, <span class="attr">value</span>: <span class="string">"var"</span>, <span class="attr">pos</span>: <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">"token_name"</span>, <span class="attr">value</span>: <span class="string">"a"</span>, <span class="attr">pos</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>var</code> 标识针对性较强，除了声明没其它用途；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">type</span>: <span class="string">"token_operator"</span>, <span class="attr">value</span>: <span class="string">"="</span>, <span class="attr">pos</span>: <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<p>运算符的针对性相对于弱一些，但难点是几十种运算符的优先级和状态管理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">type</span>: <span class="string">"token_number"</span>, <span class="attr">value</span>: <span class="string">"1"</span>, <span class="attr">pos</span>: <span class="number">9</span>&#125;</span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">"token_operator"</span>, <span class="attr">value</span>: <span class="string">"+"</span>, <span class="attr">pos</span>: <span class="number">10</span>&#125;</span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">"token_number"</span>, <span class="attr">value</span>: <span class="string">"1"</span>, <span class="attr">pos</span>: <span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure>

<p>只看这三条的确能得到结果，但并不是最终结果，因为可能是这样的</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+&#123;type: "token_operator", value: "-", pos: 8&#125;</span></span><br><span class="line"> &#123;type: "token_number", value: "1", pos: 9&#125;</span><br><span class="line"> &#123;type: "token_operator", value: "+", pos: 10&#125;</span><br><span class="line"> &#123;type: "token_number", value: "1", pos: 13&#125;</span><br><span class="line"><span class="addition">+&#123;type: "token_operator", value: "*", pos: 14&#125;</span></span><br><span class="line"><span class="addition">+&#123;type: "token_number", value: "2", pos: 15&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，就需要管理状态。</p>
<h3 id="管理状态"><a href="#管理状态" class="headerlink" title="管理状态"></a>管理状态</h3><p>怎么去管理状态？将这个问题分解成若干个问题。</p>
<ul>
<li>如何将状态简化。</li>
<li>如何梳理简化后的状态。</li>
<li>怎样的状态利于逻辑运算的。</li>
</ul>
<h4 id="状态简化"><a href="#状态简化" class="headerlink" title="状态简化"></a>状态简化</h4><p>例如将<code>~1+2-3*4%5</code>转化成</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> - ((<span class="number">3</span> * <span class="number">4</span>) % <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>结果没有改变，但结构更明确化，但怎么得到预期结构？根据运算顺序的权重图可以推演出下图：</p>
<p><img src="https://static.yuanziwen.cn/blog/eval/5.png_plain" alt><br>把它当做一个俯视圆锥体这么看不是很明确，换种方式表达可能更清晰</p>
<p><img src="https://static.yuanziwen.cn/blog/eval/6.png_plain" alt><br>与函数调用栈行为相同，秉承先进后出的原则。每层级运算符作为一个函数，每个函数也作为一个状态。把运算符优先级当做栈，权重越大的运算符越后加载。</p>
<h4 id="梳理简化后的状态"><a href="#梳理简化后的状态" class="headerlink" title="梳理简化后的状态"></a>梳理简化后的状态</h4><p>例如<code>(0 || undefined) &amp;&amp; !false</code>换成伪代码表示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标识集</span></span><br><span class="line"><span class="keyword">const</span> TOKEN_STRING = <span class="string">"TOKEN_STRING"</span>;</span><br><span class="line"><span class="keyword">const</span> TOKEN_NUMBER = <span class="string">"TOKEN_NUMBER"</span>;</span><br><span class="line"><span class="keyword">const</span> TOKEN_NAME = <span class="string">"TOKEN_NUMBER"</span>; <span class="comment">// 变量名称</span></span><br><span class="line"><span class="keyword">const</span> TOKEN_PAREN = <span class="string">"TOKEN_PAREN"</span>; <span class="comment">// 表达式分组括号</span></span><br><span class="line"><span class="keyword">const</span> TOKEN_OPERATOR = <span class="string">"TOKEN_OPERATOR"</span>; <span class="comment">// 运算符</span></span><br><span class="line"><span class="comment">// 指令集</span></span><br><span class="line"><span class="keyword">const</span> INSTR_STRING = <span class="string">"INSTR_STRING"</span>;</span><br><span class="line"><span class="keyword">const</span> INSTR_NUMBER = <span class="string">"INSTR_NUMBER"</span>;</span><br><span class="line"><span class="keyword">const</span> INSTR_NAME = <span class="string">"INSTR_NAME"</span>;</span><br><span class="line"><span class="keyword">const</span> INSTR_EXPRE = <span class="string">"INSTR_EXPR"</span>; <span class="comment">// 表达式，某些情况表达式是懒执行的 比如 false ? b() : c</span></span><br><span class="line"><span class="keyword">const</span> INSTR_OPERATOR1 = <span class="string">"INSTR_OPERATOR1"</span>; <span class="comment">// 一元运算符</span></span><br><span class="line"><span class="keyword">const</span> INSTR_OPERATOR2 = <span class="string">"INSTR_OPERATOR2"</span>; <span class="comment">// 二元运算符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Token &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="keyword">type</span>: <span class="built_in">string</span>, <span class="keyword">public</span> value: <span class="built_in">any</span>, <span class="keyword">public</span> index: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Instruction &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="keyword">type</span>: <span class="built_in">string</span>, <span class="keyword">public</span> value: <span class="built_in">any</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Parser &#123;</span><br><span class="line">  current: Token = <span class="literal">null</span>; <span class="comment">// 当前Token</span></span><br><span class="line">  nextToken: Token = <span class="literal">null</span>; <span class="comment">// 下个Token</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> exporession: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exporession !== <span class="string">"string"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Expected string but actual is"</span> + <span class="keyword">typeof</span> exporession);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getNextToken = (): <span class="function"><span class="params">Token</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* 获取下一个 Token */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  next = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.current = <span class="keyword">this</span>.nextToken;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.nextToken = <span class="keyword">this</span>.getNextToken());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  accpet = (<span class="keyword">type</span>: <span class="built_in">string</span>, value?: <span class="built_in">string</span> | <span class="built_in">number</span>, next = <span class="literal">true</span>): <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语义解析命中预期，准备收集指令并下一步 Token 的收集</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="keyword">this</span>.nextToken &amp;&amp;</span><br><span class="line">      <span class="keyword">this</span>.nextToken.type === <span class="keyword">type</span> &amp;&amp;</span><br><span class="line">      (value ? <span class="keyword">this</span>.nextToken.value === value : <span class="literal">true</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> next &amp;&amp; <span class="keyword">this</span>.next(), <span class="literal">true</span>; <span class="comment">// next表示只需要检查</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  assert = <span class="function">(<span class="params"><span class="keyword">type</span>: <span class="built_in">string</span>, value: <span class="built_in">string</span> | <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 断言</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.accpet(<span class="keyword">type</span>, value)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"parse Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  parseExpression = <span class="function">(<span class="params">instr: <span class="built_in">Array</span>&lt;Instruction&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 解析表达式</span></span><br><span class="line">    <span class="keyword">const</span> exprInstr = [];</span><br><span class="line">    <span class="keyword">this</span>.parseOrExpression(exprInstr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = exprInstr.length; i &lt; len; i++) &#123;</span><br><span class="line">      instr.push(exprInstr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instr;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  parseOrExpression = <span class="function">(<span class="params">instr: <span class="built_in">Array</span>&lt;Instruction&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 解析 ||</span></span><br><span class="line">    <span class="keyword">this</span>.parseAndExpression(instr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.accpet(TOKEN_OPERATOR, <span class="string">"||"</span>)) &#123;</span><br><span class="line">      <span class="keyword">var</span> falseBranch = [];</span><br><span class="line">      <span class="keyword">this</span>.parseAndExpression(falseBranch);</span><br><span class="line">      instr.push(<span class="keyword">new</span> Instruction(INSTR_EXPRE, falseBranch));</span><br><span class="line">      instr.push(<span class="keyword">new</span> Instruction(INSTR_OPERATOR2, <span class="string">"||"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  parseAndExpression = <span class="function">(<span class="params">instr: <span class="built_in">Array</span>&lt;Instruction&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 解析 &amp;&amp;</span></span><br><span class="line">    <span class="keyword">this</span>.parseField(instr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.accpet(TOKEN_OPERATOR, <span class="string">"&amp;&amp;"</span>)) &#123;</span><br><span class="line">      <span class="keyword">var</span> trueBranch: <span class="built_in">Array</span>&lt;Instruction&gt; = [];</span><br><span class="line">      <span class="keyword">this</span>.parseField(trueBranch);</span><br><span class="line">      instr.push(<span class="keyword">new</span> Instruction(INSTR_EXPRE, trueBranch));</span><br><span class="line">      instr.push(<span class="keyword">new</span> Instruction(INSTR_OPERATOR2, <span class="string">"&amp;&amp;"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  parseUnaryExpression = <span class="function">(<span class="params">instr: <span class="built_in">Array</span>&lt;Instruction&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ... 暂存当前指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_OPERATOR, isUnaryOpeator)) &#123;</span><br><span class="line">      <span class="comment">// 内置函数调用</span></span><br><span class="line">      <span class="keyword">if</span> (unarySymbolMapReg.test(<span class="keyword">this</span>.current.value)) &#123;</span><br><span class="line">        <span class="comment">// +, ++, +, -, !, ~,</span></span><br><span class="line">        <span class="keyword">const</span> op = <span class="keyword">this</span>.current;</span><br><span class="line">        <span class="keyword">this</span>.parseUnaryExpression(exprInstr); <span class="comment">// ++-1</span></span><br><span class="line">        exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_OPERATOR1, op.value));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 回溯, 还原指针</span></span><br><span class="line">        <span class="keyword">this</span>.parseField(instr);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseField(instr); <span class="comment">// 外置函数 || 内声明函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  parseField = <span class="function">(<span class="params">instr: <span class="built_in">Array</span>&lt;Instruction&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 解析 字段</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.accpet(TOKEN_NAME)) &#123;</span><br><span class="line">      instr.push(<span class="keyword">new</span> Instruction(INSTR_NAME, <span class="keyword">this</span>.current.value));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.accpet(TOKEN_NUMBER)) &#123;</span><br><span class="line">      instr.push(<span class="keyword">new</span> Instruction(INSTR_NUMBER, <span class="keyword">this</span>.current.value));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.accpet(TOKEN_STRING)) &#123;</span><br><span class="line">      instr.push(<span class="keyword">new</span> Instruction(INSTR_STRING, <span class="keyword">this</span>.current.value));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.accpet(TOKEN_PAREN, <span class="string">"("</span>)) &#123;</span><br><span class="line">      <span class="comment">// (a=1)</span></span><br><span class="line">      <span class="keyword">this</span>.parseExpression(instr);</span><br><span class="line">      <span class="keyword">this</span>.assert(TOKEN_PAREN, <span class="string">")"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"unexpected "</span> + <span class="keyword">this</span>.nextToken);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instr = [];</span><br><span class="line"><span class="keyword">const</span> parseInstance = <span class="keyword">new</span> Parser(<span class="string">"(0 || undefined) &amp;&amp; !false"</span>);</span><br><span class="line">parseInstance.parseExpression(instr);</span><br></pre></td></tr></table></figure>

<p>注意上例在一元运算符语义分析时进行了回溯处理，比如 <code>typeof</code> 和 <code>return</code> 它可能是<code>typeof (xxx)</code> 调用,也可能是 <code>typeof xxx</code>方式调用。这种情况预判<code>nextToken</code> 不够用，需要根据其之后两三个的情况处理，其他场景诸如<code>function fn(){xxx}</code> 和 <code>const fn = function () {}</code>同理。通过梳理，可以得到以下 tokenize 和 Instruction</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">token = [</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"TOKEN_PAREN"</span>, <span class="attr">value</span>: <span class="string">"("</span>, <span class="attr">index</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"TOKEN_NUMBER"</span>, <span class="attr">value</span>: <span class="number">0</span>, <span class="attr">index</span>: <span class="number">3</span>&#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"TOKEN_OPERATOR"</span>, <span class="attr">value</span>: <span class="string">"||"</span>, <span class="attr">index</span>: <span class="number">6</span>&#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"TOKEN_NAME"</span>, <span class="attr">value</span>: <span class="string">"undefined"</span>, <span class="attr">index</span>: <span class="number">16</span>&#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"TOKEN_PAREN"</span>, <span class="attr">value</span>: <span class="string">")"</span>, <span class="attr">index</span>: <span class="number">17</span>&#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"TOKEN_PAREN"</span>, <span class="attr">value</span>: <span class="string">")"</span>, <span class="attr">index</span>: <span class="number">17</span>&#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"TOKEN_OPERATOR"</span>, <span class="attr">value</span>: <span class="string">"&amp;&amp;"</span>, <span class="attr">index</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"TOKEN_OPERATOR"</span>, <span class="attr">value</span>: <span class="string">"!"</span>, <span class="attr">index</span>: <span class="number">22</span>&#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"TOKEN_NAME"</span>, <span class="attr">value</span>: <span class="string">"false"</span>, <span class="attr">index</span>: <span class="number">27</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Instruction = [</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">"INSTR_NUMBER"</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">"INSTR_EXPRE"</span>, <span class="attr">value</span>: <span class="built_in">Array</span>(<span class="number">1</span>) &#125;</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">"INSTR_OPERATOR2"</span>, <span class="attr">value</span>: <span class="string">"||"</span> &#125;</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">"INSTR_EXPRE"</span>, <span class="attr">value</span>: <span class="built_in">Array</span>(<span class="number">2</span>) &#125;</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">"INSTR_OPERATOR2"</span>, <span class="attr">value</span>: <span class="string">"&amp;&amp;"</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="利于运算"><a href="#利于运算" class="headerlink" title="利于运算"></a>利于运算</h4><p>循序渐进，以下是简单场景下 <code>1 + 1</code> 的运算逻辑</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instr = [</span><br><span class="line"> &#123;<span class="keyword">type</span>: <span class="string">"INSTR_NUMBER"</span>, value: <span class="string">"1"</span>&#125;,</span><br><span class="line"> &#123;<span class="keyword">type</span>: <span class="string">"INSTR_NUMBER"</span>, value: <span class="string">"1"</span>&#125;,</span><br><span class="line"> &#123;<span class="keyword">type</span>: <span class="string">"INSTR_OPERATOR2"</span>, value: <span class="string">"+"</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> len = instr.length;</span><br><span class="line"><span class="keyword">let</span> n1, n2</span><br><span class="line"><span class="keyword">let</span> stack = []; <span class="comment">// 作为运算数据池，其作用类似于原生JS的作用域结构。目的是解决递归计算。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;value, <span class="keyword">type</span>&#125; = instr[i].value</span><br><span class="line">  <span class="keyword">switch</span>(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> INSTR_NUMBER: &#123;</span><br><span class="line">      stack.push(value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> INSTR_OPERATOR: &#123;</span><br><span class="line">      n1 = stack.pop();</span><br><span class="line">      n2 = stack.pop();</span><br><span class="line">      <span class="keyword">const</span> f = binaryMap[value];</span><br><span class="line">      stack.push(f(n1,n2));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微复杂一点的场景 <code>(0 || undefined) &amp;&amp; !false</code> 的运算逻辑。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> binaryMap = &#123;</span><br><span class="line">    <span class="string">'||'</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a || b,</span><br><span class="line">    <span class="string">'&amp;&amp;'</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> n1 ? n1 : n2,</span><br><span class="line">    <span class="string">'-'</span>: <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> unaryMap = &#123;</span><br><span class="line">    <span class="string">'!'</span>: <span class="function">(<span class="params">n</span>) =&gt;</span> !n</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">instr, values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = instr.length;</span><br><span class="line">    <span class="keyword">let</span> n1, n2</span><br><span class="line">    <span class="keyword">let</span> stack = []; <span class="comment">// 作为运算数据池，其作用类似于原生JS的作用域结构。目的是解决递归计算。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;<span class="keyword">type</span>, value&#125; = instr[i];</span><br><span class="line">      <span class="keyword">switch</span>(<span class="keyword">type</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> INSTR_NUMBER: &#123;</span><br><span class="line">          stack.push(value);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TOKEN_OPERATOR2: &#123; <span class="comment">// 抽象描述，待细化，N元操作符 需要N个操作数</span></span><br><span class="line">          [n1, n2] = stack.splice(<span class="number">-2</span>, <span class="number">2</span>);</span><br><span class="line">          <span class="keyword">const</span> f = binaryMap[value];</span><br><span class="line">          <span class="keyword">if</span>(value === <span class="string">'&amp;&amp;'</span>) &#123; <span class="comment">// false &amp;&amp; fn() fn不会执行</span></span><br><span class="line">            stack.push(f(n1, calc([n2], values)));</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(f(n1,n2));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> INSTR_OPERATOR1: &#123; <span class="comment">// 一元操作符</span></span><br><span class="line">          n1 = stack.pop();</span><br><span class="line">          stack.push(unaryMap[value](n1));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> INSTR_NAME: &#123;</span><br><span class="line">          stack.push(values[value]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> INSTR_VAR: &#123; <span class="comment">// values属于全局上下文，let const的赋值加到当前scope里，下面说</span></span><br><span class="line">          <span class="keyword">const</span> v = stack.pop()</span><br><span class="line">          values[value] = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经得出最终结果符合预期，其他的运算符根据先后顺序可以推算出来这里就不做赘述。</p>
<h3 id="复杂数据声明"><a href="#复杂数据声明" class="headerlink" title="复杂数据声明"></a>复杂数据声明</h3><p>声明<code>var foo = { bar: 1 }</code> 对于目前的就是一个解析格式与解析时读取的问题。首先从 tokenize 阶段，添加相应的标识符<code>{</code> <code>}</code> <code>:</code> <code>,</code> <code>[</code> <code>]</code> ，数组同理。</p>
<ul>
<li>token-stream 语法分析，生成 token 的处理逻辑；</li>
<li>parser 进行语义分析</li>
<li>calc 解释执行</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// token-stream.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> TokenStream &#123;</span><br><span class="line">  pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前解析character</span></span><br><span class="line">  current: <span class="literal">null</span> | TypeToken = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> expression: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//....other</span></span><br><span class="line"></span><br><span class="line">  getSomeCode = (len = <span class="number">1</span>, offset = <span class="number">0</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> start = offset + <span class="keyword">this</span>.pos;</span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = <span class="keyword">this</span>.expression;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.expression.substr(</span><br><span class="line">      start,</span><br><span class="line">      start + len &gt; length ? length - start : len</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断是否操作符</span></span><br><span class="line"><span class="comment">   * @desc 操作符 + - * / || % ^ ? : . &gt; &lt; = &gt;= &lt;= | == === != !== in</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  isOperator = (): <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> str = <span class="keyword">this</span>.getSomeCode(<span class="literal">Infinity</span>);</span><br><span class="line">    <span class="keyword">let</span> result: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">if</span> (operatorReg.test(str)) &#123;</span><br><span class="line">      result = execFactoryReg(operatorReg, str); <span class="comment">// 匹配标识符 不匹配typeof return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unaryMapReg.test(str)) &#123;</span><br><span class="line">      result = execFactoryReg(unaryMapReg, str); <span class="comment">// 匹配typeof return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    result = result.replace(<span class="regexp">/\s/g</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">this</span>.pos += result.length;</span><br><span class="line">    <span class="keyword">this</span>.current = <span class="keyword">this</span>.newToken(TOKEN_OPERATOR, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 圆、方括号</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  isParenthesis = (): <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> first = <span class="keyword">this</span>.getSomeCode();</span><br><span class="line">    <span class="keyword">if</span> (contains([<span class="string">"("</span>, <span class="string">")"</span>], first)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.current = <span class="keyword">this</span>.newToken(TOKEN_PAREN, first);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contains([<span class="string">"["</span>, <span class="string">"]"</span>], first)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.current = <span class="keyword">this</span>.newToken(TOKEN_SQUARE, first);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contains([<span class="string">"&#123;"</span>, <span class="string">"&#125;"</span>], first)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.current = <span class="keyword">this</span>.newToken(TOKEN_CURLY, first);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.pos++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  isComma = (): <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> first = <span class="keyword">this</span>.getSomeCode();</span><br><span class="line">    <span class="keyword">if</span> (first === <span class="string">","</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.current = <span class="keyword">this</span>.newToken(TOKEN_COMMA, <span class="string">","</span>);</span><br><span class="line">      <span class="keyword">this</span>.pos++;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 parser 解析器里添加相应的语义分析逻辑</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parser.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Parser &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解析表达式整个句柄</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  parseExpression = (instr: TypeInstruction[]): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> exprInstr: TypeInstruction[] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseMultipleEvaluation(exprInstr)</span><br><span class="line">    exprInstr.forEach(<span class="function"><span class="params">exp</span> =&gt;</span> (instr.push(exp)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解析连续求值 例如 数组字面量 [1, 2, [3, 4, 5]]  (1, 2, 3)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  parseMultipleEvaluation = (exprInstr: TypeInstruction[]): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.parseAssignmentExpression(exprInstr)</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.accept(TOKEN_COMMA, <span class="string">','</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseConditionalExpression(exprInstr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...other</span></span><br><span class="line"></span><br><span class="line">  parseField = (exprInstr: TypeInstruction[]): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_OPERATOR, isUnaryOpeator)) &#123;</span><br><span class="line">      <span class="comment">// 内置一元运算符</span></span><br><span class="line">      exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_OPERA1, <span class="keyword">this</span>.current.value));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_NUMBER)) &#123;</span><br><span class="line">      <span class="comment">// 数字类型</span></span><br><span class="line">      exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_NUMBER, <span class="keyword">this</span>.current.value));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_STRING)) &#123;</span><br><span class="line">      <span class="comment">// 字符串类型 \"name\"</span></span><br><span class="line">      exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_PLAIN, <span class="keyword">this</span>.current.value));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_PAREN, <span class="string">'('</span>)) &#123;</span><br><span class="line">      <span class="comment">// 圆括号，调用 或 表达式(a=1)</span></span><br><span class="line">      <span class="keyword">this</span>.parseExpression(exprInstr);</span><br><span class="line">      <span class="keyword">this</span>.assert(TOKEN_PAREN, <span class="string">')'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_SQUARE, <span class="string">'['</span>)) &#123;</span><br><span class="line">      <span class="comment">//  数组字面量</span></span><br><span class="line">      <span class="keyword">this</span>.parseArrayLiteralDeclaration(exprInstr)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_CURLY, <span class="string">'&#123;'</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">      <span class="comment">// Object字面量声明</span></span><br><span class="line">      <span class="keyword">this</span>.parseObjectLiteralDeclaration(exprInstr)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_VAR, [<span class="string">'const'</span>, <span class="string">'var'</span>, <span class="string">'let'</span>])) &#123;</span><br><span class="line">      <span class="comment">// 赋值表达式 收集 ident,避免 variableName 识别成 Name 引发error</span></span><br><span class="line">      <span class="keyword">const</span> identifier = <span class="keyword">this</span>.current</span><br><span class="line">      <span class="keyword">this</span>.assert(TOKEN_NAME)</span><br><span class="line">      exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_VARNAME, <span class="keyword">this</span>.current.value));</span><br><span class="line">      exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_VAR, identifier.value))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unexpected '</span> + <span class="keyword">this</span>.nextToken);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解析对象字面量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  parseArrayLiteralDeclaration = <span class="function">(<span class="params">exprInstr: TypeInstruction[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Array字面量声明 <span class="doctag">TODO:</span> 需要和 obj['a'] 做区分</span></span><br><span class="line">    <span class="keyword">const</span> instr = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_SQUARE, <span class="string">']'</span>)) &#123; <span class="comment">// []</span></span><br><span class="line">      exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_ARRAY, instr))</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.parseExpression(instr)</span><br><span class="line">    <span class="keyword">this</span>.assert(TOKEN_SQUARE, <span class="string">']'</span>)</span><br><span class="line">    exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_ARRAY, instr))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解析对象字面量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  parseObjectLiteralDeclaration = <span class="function">(<span class="params">exprInstr: TypeInstruction[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.accept(TOKEN_CURLY, <span class="string">'&#123;'</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> instr = &#123;&#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_CURLY, <span class="string">'&#125;'</span>)) &#123; <span class="comment">// &#123;&#125;</span></span><br><span class="line">        exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_OBJECT, instr))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">this</span>.accept(TOKEN_NAME) || <span class="keyword">this</span>.accept(TOKEN_NUMBER) || <span class="keyword">this</span>.accept(TOKEN_STRING)) &#123; <span class="comment">// key</span></span><br><span class="line">        <span class="keyword">const</span> key = <span class="keyword">this</span>.current.value</span><br><span class="line">        <span class="keyword">this</span>.assert(TOKEN_OPERATOR, <span class="string">':'</span>);</span><br><span class="line">        instr[key] = []; <span class="comment">// 以表达式作为每个key的value递归处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_CURLY, <span class="string">'&#123;'</span>, <span class="literal">false</span>)) &#123; <span class="comment">//</span></span><br><span class="line">          <span class="keyword">this</span>.parseObjectLiteralDeclaration(instr[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.parseExpression(instr[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.accept(TOKEN_COMMA, <span class="string">','</span>); <span class="comment">//&#123; a: 1,&#125; 可能是有的，但不可以用assert</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.assert(TOKEN_CURLY, <span class="string">'&#125;'</span>); <span class="comment">// 断言结尾</span></span><br><span class="line">      exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_OBJECT, instr))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>var foo = { bar: { arr: [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]}};</code> 的指令集解析如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"INSTR_VARNAME"</span>,</span><br><span class="line">        <span class="string">"value"</span>: <span class="string">"foo"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"INSTR_EXPRE"</span>,</span><br><span class="line">        <span class="string">"value"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"type"</span>: <span class="string">"INSTR_OBJECT"</span>,</span><br><span class="line">                <span class="string">"value"</span>: &#123;</span><br><span class="line">                    <span class="string">"bar"</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"type"</span>: <span class="string">"INSTR_OBJECT"</span>,</span><br><span class="line">                            <span class="string">"value"</span>: &#123;</span><br><span class="line">                                <span class="string">"arr"</span>: [</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        <span class="string">"type"</span>: <span class="string">"INSTR_ARRAY"</span>,</span><br><span class="line">                                        <span class="string">"value"</span>: [</span><br><span class="line">                                            &#123;<span class="string">"type"</span>: <span class="string">"INSTR_PLAIN"</span>, <span class="string">"value"</span>: <span class="string">"a"</span> &#125;,</span><br><span class="line">                                            &#123;<span class="string">"type"</span>: <span class="string">"INSTR_PLAIN"</span>, <span class="string">"value"</span>: <span class="string">"b"</span> &#125;,</span><br><span class="line">                                            &#123;<span class="string">"type"</span>: <span class="string">"INSTR_PLAIN"</span>, <span class="string">"value"</span>: <span class="string">"c"</span> &#125;</span><br><span class="line">                                        ]</span><br><span class="line">                                    &#125;</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"INSTR_VAR"</span>,</span><br><span class="line">        <span class="string">"value"</span>: <span class="string">"var"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// calc.ts</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">instr, value, statis = <span class="literal">false</span></span>) </span>&#123; <span class="comment">// 默认return stack[0], statis = true 表示全量return</span></span><br><span class="line">  <span class="comment">// ...other</span></span><br><span class="line">	<span class="keyword">case</span> INSTR_ARRAY: &#123; <span class="comment">// 数组字面量</span></span><br><span class="line">    stack.push(calc(value, values, <span class="literal">true</span>))</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> INSTR_OBJECT: &#123; <span class="comment">// 对象字面量</span></span><br><span class="line">    <span class="keyword">const</span> instr = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">Object</span>.keys(value).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      instr[key] = calc(value[key], values, statis)</span><br><span class="line">    &#125;)</span><br><span class="line">    stack.push(instr)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>ES6 之前，正常情况下(抛开 catch/with)只有 function 才能创建新的作用域 —— function Scope，而 ES6 引入了 Block Scope，后者不在需求内就不做说明了，照葫芦画瓢。</p>
<p>所以实现作用域也顺带把内置 function 也做了，<code>function abs(a,b){ return(a-b || b-a)}</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// token-stream.ts</span></span><br><span class="line">  isFunctionDefined = (): <span class="function"><span class="params">boolean</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> word = <span class="keyword">this</span>.expression.substr(<span class="keyword">this</span>.pos).match(<span class="regexp">/\b\w*\b/</span>);</span><br><span class="line">    <span class="keyword">if</span>(word === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.current = <span class="keyword">this</span>.newToken(TOKEN_FUNC, <span class="literal">undefined</span>);</span><br><span class="line">      <span class="keyword">this</span>.pos += word.length</span><br><span class="line">      <span class="keyword">const</span> nextToken = <span class="keyword">this</span>.checkNextAccessGrammar(); <span class="comment">// 语法检查下个token 是否符合 FunctionName 约束声明规则</span></span><br><span class="line">      <span class="keyword">if</span>(nextToken.type !== TOKEN_NAME) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parseError(<span class="string">'function definition should have function name'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parser.ts</span></span><br><span class="line">	parseField = (exprInstr: TypeInstruction[]): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_FUNC, <span class="literal">undefined</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseFunctionDefinedDeclaration(exprInstr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解析函数声明</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  parseFunctionDefinedDeclaration = <span class="function">(<span class="params">expreInstr: TypeInstruction[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.accept(TOKEN_FUNC)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.assert(TOKEN_NAME)) &#123; <span class="comment">// function fn()&#123;&#125;</span></span><br><span class="line">        <span class="keyword">const</span> funcName = <span class="keyword">this</span>.current.value;</span><br><span class="line">        <span class="keyword">const</span> instr = []; <span class="comment">// 参数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_PAREN, <span class="string">'('</span>) &amp;&amp; !<span class="keyword">this</span>.accept(TOKEN_PAREN, <span class="string">')'</span>)) &#123; <span class="comment">// fn()</span></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parseField(instr); <span class="comment">// 收集参数</span></span><br><span class="line">          &#125; <span class="keyword">while</span> (<span class="keyword">this</span>.accept(TOKEN_COMMA))</span><br><span class="line">          <span class="keyword">this</span>.assert(TOKEN_PAREN, <span class="string">')'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.parseFunctionBodyExpression(instr) <span class="comment">// 收集完参数只剩下 &#123; 函数体 &#125;;</span></span><br><span class="line">        expreInstr.push(<span class="keyword">new</span> Instruction(INSTR_FUNCDEF, instr))</span><br><span class="line">        expreInstr.push(<span class="keyword">new</span> Instruction(INSTR_FUNCDEF, funcName))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解析函数体</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  parseFunctionBodyExpression = <span class="function">(<span class="params">exprInstr: TypeInstruction[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_CURLY, <span class="string">'&#123;'</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> instr = [];</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.parseExpression(instr)</span><br><span class="line">      &#125; <span class="keyword">while</span> (<span class="keyword">this</span>.accept(TOKEN_SEMICOLON, <span class="string">';'</span>) &amp;&amp; !<span class="keyword">this</span>.accept(TOKEN_CURLY, <span class="string">'&#125;'</span>, <span class="literal">false</span>)) <span class="comment">// 每行必须是;结尾</span></span><br><span class="line">      <span class="keyword">this</span>.assert(TOKEN_CURLY, <span class="string">'&#125;'</span>)</span><br><span class="line">      <span class="keyword">this</span>.accept(TOKEN_SEMICOLON, <span class="string">';'</span>)</span><br><span class="line">      exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_EXPRE, instr))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>作用域的形态与作用域链几乎一致，每个函数体除要有一个作用域之外，还需要具有更新其词法作用域的能力，创建 <code>CustomFunc</code> 类，<code>_scope</code> 为当前作用域，当发生更新作用域时，通过传入的属性，把形参赋值实参，达到更新作用域的目的。另外一方面，使用<code>let</code> <code>const</code> 新声明的变量都会挂载到该级作用域<code>_scope</code> 上面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// calc.ts</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tokens: Instruction&lt;any&gt;[],</span></span></span><br><span class="line"><span class="function"><span class="params">  values = Object.create(null</span>),</span></span><br><span class="line"><span class="function">  <span class="title">statis</span> = <span class="title">false</span>,</span></span><br><span class="line"><span class="function">  <span class="title">scope</span> = <span class="title">Object</span>.<span class="title">create</span>(<span class="params">null</span>) // 当前作用域</span></span><br><span class="line"><span class="function">) </span>&#123;</span><br><span class="line">  <span class="comment">// ... other</span></span><br><span class="line">  <span class="keyword">case</span> INSTR_FUNCDEF: &#123; <span class="comment">// 函数定义</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'string'</span>) &#123;</span><br><span class="line">      stack.push(value); <span class="comment">// 函数体</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.length === <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> _scope = <span class="built_in">Object</span>.setPrototypeOf(<span class="built_in">Object</span>.create(<span class="literal">null</span>), scope); <span class="comment">// 创建一个新的作用域，并将</span></span><br><span class="line">    _scope[value] = <span class="keyword">new</span> Instruction&lt;CustomFunc&gt;(INSTR_EXECUTBODY, <span class="keyword">new</span> CustomFunc(stack.pop(), values, _scope, ceval))</span><br><span class="line">    <span class="comment">// Object.assign(scope, _scope)</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内声明函数体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomFunc</span> </span>&#123;</span><br><span class="line">  args: string[];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(public func: Instruction&lt;any&gt;[], public values: Record&lt;string, any&gt;, public _scope: Record&lt;string, any&gt;, public ceval: Ceval) &#123;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="keyword">this</span>.func.splice(<span class="number">0</span>, func.length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">this</span>.args = calc(args, mapToObject(args, (k) =&gt; k), <span class="literal">true</span>); <span class="comment">//mapToObject: Array to Object e.g. ['a', 'b'] =&gt; &#123; a: undefined, b: undefined &#125;</span></span><br><span class="line">    <span class="keyword">this</span>._scope = merge(mapToObject(args), _scope);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(<span class="keyword">this</span>, <span class="keyword">new</span>.target.prototype); <span class="comment">// restore</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateScope = <span class="function">(<span class="params">scope: any[]</span>) =&gt;</span> &#123; <span class="comment">// 更新作用域，假设 Object attribute 是不保证顺序的。</span></span><br><span class="line">    <span class="keyword">this</span>.args.forEach(<span class="function">(<span class="params">key, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(hasAttribute(<span class="keyword">this</span>._scope, key)) &#123;</span><br><span class="line">        <span class="keyword">this</span>._scope[key] = scope[index]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  invokeBody = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> calc(<span class="keyword">this</span>.func, <span class="keyword">this</span>.values, <span class="literal">false</span>, <span class="keyword">this</span>._scope)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数的解析较为简单</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// token-stream.ts</span></span><br><span class="line">  <span class="comment">// 解析外置函数调用</span></span><br><span class="line">  parseOuterFunctionCallExpression = <span class="function">(<span class="params">exprInstr: TypeInstruction[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.parseMemberAccessExpression(exprInstr) <span class="comment">// 成员访问, 后面引用说</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.current.type === TOKEN_NAME &amp;&amp; <span class="keyword">this</span>.accept(TOKEN_PAREN, <span class="string">'('</span>, <span class="literal">false</span>)) &#123;<span class="comment">// fn( 形态</span></span><br><span class="line">      <span class="keyword">this</span>.parseArguments(exprInstr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析参数</span></span><br><span class="line">  parseArguments = (exprInstr: TypeInstruction[]): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.accept(TOKEN_PAREN, <span class="string">'('</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.accept(TOKEN_PAREN, <span class="string">')'</span>)) &#123;</span><br><span class="line">        <span class="comment">// 立即调用</span></span><br><span class="line">        exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_FUNCALL, <span class="number">0</span>)) <span class="comment">// 参数长度</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.accept(TOKEN_PAREN, <span class="string">')'</span>)) &#123;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parseConditionalExpression(exprInstr); <span class="comment">// 兼容 fn(false ? 1 : 2, 3)</span></span><br><span class="line">            count++;</span><br><span class="line">          &#125; <span class="keyword">while</span> (<span class="keyword">this</span>.accept(TOKEN_COMMA))</span><br><span class="line">        &#125;</span><br><span class="line">        exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_FUNCALL, count))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> INSTR_FUNCALL: &#123; <span class="comment">// 内声明函数调用，也可以添加外部函数</span></span><br><span class="line">  <span class="keyword">const</span> args = stack.splice(-value, value); <span class="comment">// INSTR_FUNCALL的value表示传入参数长度</span></span><br><span class="line">  fn = stack.pop();</span><br><span class="line">  <span class="keyword">if</span>(fn.value <span class="keyword">instanceof</span> CustomFunc) &#123;</span><br><span class="line">    fn.value.updateScope(args) <span class="comment">// 先更新作用域</span></span><br><span class="line">    stack.push(fn.value.invokeBody()) <span class="comment">// 再执行函数体</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123; <span class="comment">// 外置函数，即在consts内声明的</span></span><br><span class="line">    stack.push(fn.apply(<span class="literal">null</span>, args))</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就兼容了自定义函数，也方便后续添加其他规则。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>内置函数是不允许解析到 this 的，this 并不属于动态语言的一部分，由于运行时产生 AO 的缘故让它的行为比较像动态语言，其次这个特性个人觉得也不太需要。<code>fn.apply(null, args)</code>是暂时方案实现，只需要以一些判断依据处理，由于不是重点就暂搁一边。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>Object、Array 的修改是根据引用来写入的。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123; bar: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;;</span><br><span class="line"><span class="keyword">var</span> b = foo.bar;</span><br></pre></td></tr></table></figure>

<p>在实现中是以读取上下文中的属性拿到值，再逐个拿到</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//parser.ts</span></span><br><span class="line">parseMemberAccessExpression = (exprInstr: TypeInstruction[]): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.parseField(exprInstr);</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">this</span>.accept(TOKEN_OPERATOR, <span class="string">"."</span>) || <span class="keyword">this</span>.accept(TOKEN_SQUARE, <span class="string">"["</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.current.value === <span class="string">"."</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.assert(TOKEN_NAME); <span class="comment">// a.1×</span></span><br><span class="line">      exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_MEMBER, <span class="keyword">this</span>.current.value));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.current.value === <span class="string">"["</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseExpression(exprInstr);</span><br><span class="line">      <span class="keyword">this</span>.assert(TOKEN_SQUARE, <span class="string">"]"</span>);</span><br><span class="line">      exprInstr.push(<span class="keyword">new</span> Instruction(INSTR_MEMBER));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">instr = [</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="string">"INSTR_VARNAME"</span>, value: <span class="string">"b"</span>&#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="string">"INSTR_EXPRE"</span>,</span><br><span class="line">    value: [</span><br><span class="line">     &#123; <span class="keyword">type</span>: <span class="string">"INSTR_MEMBER"</span>, value: <span class="string">"bar"</span> &#125;,</span><br><span class="line">     &#123; <span class="keyword">type</span>: <span class="string">"INSTR_NAME"</span>, value: <span class="string">"foo"</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="keyword">type</span>: <span class="string">"INSTR_VAR"</span>, value: <span class="string">"var"</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// calc.ts</span></span><br><span class="line">   <span class="keyword">case</span> INSTR_MEMBER: &#123; <span class="comment">// 成员访问</span></span><br><span class="line">    <span class="keyword">if</span> (!value) &#123; <span class="comment">// a["b"]</span></span><br><span class="line">      [n1, n2] = stack.splice(<span class="number">-2</span>, <span class="number">2</span>);</span><br><span class="line">      stack.push(n1[n2]);</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    n1 = stack.pop(); <span class="comment">// a.b</span></span><br><span class="line">    stack.push(n1[value])</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>读是没有问题的，问题出在写，LeftHandSide 的左侧只能是一个引用。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">obj.arr[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment">// 会被转化成</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>正常情况在原生拿不到引用地址，换个思路转成以下写法</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">[Reference, <span class="string">"bar"</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上代码</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// calc.ts</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> INSTR_OPERA2: &#123; <span class="comment">// 二元运算</span></span><br><span class="line">        [n1, n2] = stack.splice(<span class="number">-2</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (value === <span class="string">'='</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n1 <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">              n1.setValue(n2);</span><br><span class="line">              n1.destory();</span><br><span class="line">              n1 = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              fn(n1, n2, hasAttribute(scope, n1) ? scope : values)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> INSTR_MEMBER: &#123; <span class="comment">// 成员访问</span></span><br><span class="line">        <span class="keyword">const</span> nextItem = tokens[i+<span class="number">2</span>]; <span class="comment">// 解析顺序 [INSTR_MEMBER] =&gt; [INSTR_EXPRE] =&gt; [INSTR_OP2 =]</span></span><br><span class="line">        <span class="keyword">const</span> keys = calc(value, values, <span class="literal">true</span>, scope); <span class="comment">// ['foo', bar']</span></span><br><span class="line">        <span class="keyword">const</span> ref = getReference(keys, scope, values) <span class="comment">// 创建引用实例</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(nextItem &amp;&amp; nextItem.type === INSTR_OPERA2 &amp;&amp; nextItem.value === <span class="string">'='</span>) &#123; <span class="comment">// 下一个指令是赋值操作</span></span><br><span class="line">          stack.push(ref);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          stack.push(ref.getValue())</span><br><span class="line">          ref.destory();</span><br><span class="line">          ref = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据paths尝试获取引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getReference</span>(<span class="params">keyQueue: <span class="built_in">string</span>[], scope: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;, values: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;</span>): <span class="title">Reference</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> path</span><br><span class="line">  <span class="keyword">let</span> target = hasAttribute(scope, path) ? scope : values;</span><br><span class="line">  <span class="keyword">const</span> lastKey = keyQueue.pop();</span><br><span class="line">  <span class="keyword">while</span> (path = keyQueue.shift()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasAttribute(target, path)) &#123;</span><br><span class="line">      target = target[path];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!target) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`Uncaught TypeError: Cannot read property '<span class="subst">$&#123;path&#125;</span>' of <span class="subst">$&#123;target&#125;</span>`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Reference(target, lastKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Reference &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> target: <span class="built_in">any</span>, <span class="keyword">public</span> path: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`<span class="subst">$&#123;path&#125;</span>:<span class="subst">$&#123;<span class="built_in">String</span>(target)&#125;</span> Invalid parent reference`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setValue = <span class="function">(<span class="params">value</span>) =&gt;</span> (<span class="keyword">this</span>.target[<span class="keyword">this</span>.path] = value)</span><br><span class="line">  getValue = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.target[<span class="keyword">this</span>.path]</span><br><span class="line">  destory = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.target = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后要接入<a href="https://github.com/tc39/test262/tree/master/test/language" target="_blank" rel="noopener">TC39/test262</a>的 testcase。目前<a href="https://www.npmjs.com/package/ceval" target="_blank" rel="noopener">Ceval</a>已经完成部分测试用例，压缩后20+k。</p>
<p>移步<a href="https://github.com/yzw7489757/ceval" target="_blank" rel="noopener">Repo</a>获得更好的阅读体验.</p>
<p>参考文献：<br><a href="https://www.jianshu.com/p/5eb45c64f3e3" target="_blank" rel="noopener">深入浅出理解有限状态机/云峰小罗</a>;</p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="blog.yuanziwen.cn">Seven</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="blog.yuanziwen.cn/2020/06/30/实现简版eval/">blog.yuanziwen.cn/2020/06/30/实现简版eval/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/JavaScript/">JavaScript</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2021/01/06/Lighthouse-流程/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Lighthouse 流程架构</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2019/12/18/微前端时代落地前的思考/">
        <span class="next-text nav-default">微前端时代思考与实践</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'cxeaTV5BFDCxPmxoCcG9QPxf-gzGzoHsz',
        appKey: 's577OrPG5sB4Szom6mvHuI1X',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info: guest,
        pageSize:'10' || 10,
    });
  </script>

<footer id="footer" class="footer"><div class="social-links"><a href="mailto:yuanziwen7489757@gmail.com" class="iconfont icon-email" title="email"></a>
          <a href="https://juejin.im/user/59aa31a06fb9a02485103ddf" class="iconfont juejin" title="掘金"><div class="img"></div></a>
        <a href="https://github.com/yzw7489757" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <!--<span class="division">|</span>
  <span class="theme-info">
    footer.theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>-->
  <span class="power-by">
   <a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备18011257号-1</a>
  </span>
  <span class="copyright-year">&copy;2017 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Seven</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
<script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js?t=1624262701310')
    .then(function () {console.log('ServiceWorker Register Successfully.')})
    .catch(function (e) {console.error(e)});
}
</script></body>
</html>
