<!DOCTYPE html>
<html lang="zh-Hans">
  <head><meta name="generator" content="Hexo 3.9.0"><link rel="manifest" href="/manifest.json"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="使用React构建多端容器"><meta name="keywords" content="Seven YuanZiWen"><link rel="alternate" href="/atom.xml" title="Seven Blog"><link rel="shortcut icon" type="image/x-icon" href="https://static.yuanziwen.cn/blog/favicon.ico?v=2.11.0">
<link rel="canonical" href="blog.yuanziwen.cn/2021/06/01/使用React构建多端容器/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1e4ffaffd9b2bc832b39e2b866a92c7b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>使用React构建多端容器 - Seven Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Seven Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Record
          </li>
      </a><a href="/logs/">
        <li class="mobile-menu-item">Log
          </li>
      </a><a href="/music/">
        <li class="mobile-menu-item">Music
          </li>
      </a><a href="/photo/">
        <li class="mobile-menu-item">Album
          </li>
      </a><a href="/book/">
        <li class="mobile-menu-item">Book
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Seven Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Record
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/logs/">
            Log
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/music/">
            Music
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/photo/">
            Album
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/book/">
            Book
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">使用React构建多端容器
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-06-01
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#序言"><span class="toc-text">序言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#目标"><span class="toc-text">目标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#容器能力"><span class="toc-text">容器能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用方式"><span class="toc-text">使用方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计分层"><span class="toc-text">设计分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api-约定"><span class="toc-text">api 约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口定义"><span class="toc-text">接口定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic"><span class="toc-text">Basic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Schema"><span class="toc-text">Schema</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Suspense-amp-ErrorBoundary"><span class="toc-text">Suspense &amp; ErrorBoundary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Navigator"><span class="toc-text">Navigator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器侧配置"><span class="toc-text">容器侧配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mock实现"><span class="toc-text">Mock实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-implement"><span class="toc-text">Web-implement</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化上下文"><span class="toc-text">初始化上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-1"><span class="toc-text">Basic</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工具层"><span class="toc-text">工具层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#服务网关层"><span class="toc-text">服务网关层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#协议层-组件-模块加载器"><span class="toc-text">协议层(组件/模块加载器)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#协议规范"><span class="toc-text">协议规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#协议解析"><span class="toc-text">协议解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#协议加载"><span class="toc-text">协议加载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Navigator-1"><span class="toc-text">Navigator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ErrorBoundary"><span class="toc-text">ErrorBoundary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Suspense"><span class="toc-text">Suspense</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.2.1/css/hint.min.css"><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>本文就如何设计多端容器做出实现方案。本文指的多端并非是跨端，多端容器泛指容器提供统一能力，以供下游应用在多种环境下的容器加载并正常运行。各端容器提供的能力可能不同，下游也无需关心上层实现及依赖，只依赖于抽象接口，遵循依赖反转原则。</p>
<p>小伙伴应该接触过以下这种需求场景：应用既可以在web browser运行，也可以以Hybrid的方式内嵌 webview、三方应用(alipay,wx,微应用等)浏览器。可能有些同学会问：“同是 Browser Environment，提供的上下文能力不都一样吗”，但实际上，会有一些容器对加载内容的能力做一些限制和添加特色功能，端容器需要做的就是将它们对齐。当处于可以访问DOM的环境调用社区的动画库，处于原生应用中时调用JSBridge使用原生应用的交互能力，处于其他端例如小程序时使用三方生态提供的能力 —— 当无法最优解时，可以自动降级到兜底方案。</p>
<a id="more"></a>
<p>又比如wxH5和dingding微应用，会有默认的导航栏，部分应用会开放应用导航栏的定制能力，而当环境处于Web Browser 时自带导航栏应该展现出来。这只是部分差异，当维护的应用涉及多个环境时，问题被放大也就棘手了起来。</p>
<p>总之，多端容器解决的问题是：</p>
<ul>
<li>提供多端统一API，抽象api约定，下游无感。</li>
<li>多端逻辑隔离，利于维护管理。</li>
<li>依赖反转，解耦提高可替代性。</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><h3 id="容器能力"><a href="#容器能力" class="headerlink" title="容器能力"></a>容器能力</h3><ol>
<li>常用指令API(toast/alert/confirm)和常用工具类(剪切板/本地存储/预览图片/环境区分)。</li>
<li>Services，服务网关(根据环境调用对应API调整参数) e.g. fetch/jsonp/自定义注入网关。</li>
<li>ComponentLoader，组件加载器，具备预加载功能。</li>
<li>NavgationAPI，导航及路由缓存。</li>
<li>ErrorBoundary，可定制错误兜底视图自动上报。</li>
<li>Suspense，定制 React.lazy、componentLoader 加载过渡动画。</li>
</ol>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; containerContext, Container &#125; <span class="keyword">from</span> <span class="string">'@iron-man/container-api'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Container &#123;...options&#125;&gt;</span><br><span class="line">        &lt;AnyChild /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Container&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function AnyChild() &#123;</span></span><br><span class="line"><span class="regexp">    const containerAPI = useContext(containerContext);</span></span><br><span class="line"><span class="regexp">    useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ use container ability</span></span><br><span class="line"><span class="regexp">    &#125;, [])</span></span><br><span class="line"><span class="regexp">    return /</span><span class="regexp">/...</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可能有些人会有疑问，为什么要使用Context？经常在某些文章里看到性能和组件间可预测的数据复杂性两方面问题，首先它是跨组件共享数据的首选方式，定义后属性的不可重写代表也不会让跨组件层级之间组件关系变得复杂且不可预测，还有一些文章指出它的诟病是容易造成性能损耗，例如不拆分 Context 充当 Redux 构建单一数据树使用，使组件强行脱离 bailout 逻辑, 然而 React 性能优化的一大关键在于减少不必要的render，这一点可以通过 memo 规避掉。</p>
<h2 id="设计分层"><a href="#设计分层" class="headerlink" title="设计分层"></a>设计分层</h2><p>整块分为基础容器层、路由层、ErrorBoundary层、Suspense层。所有“层”说白了都是容器，大体来说两意思相近。</p>
<p>其他层依赖于基础容器提供的基础能力，除基础容器外，每种功能无耦合可组合拆分不影响其他能力，还有像埋点容器、Profiler容器、动画过渡容器等自由发挥。</p>
<p><img src="https://static.yuanziwen.cn/blog/container/1.png_plain" alt="image.png"></p>
<ul>
<li>基础容器层<ul>
<li>1.2.3 偏向于容器api，没有其他依赖，适合放在基础容器层内或为下游层提供能力。<ul>
<li>通用API提供上下文常用的指令工具方法。</li>
<li>服务网关提供服务调用能力。</li>
<li>ComponentLoader 过渡动画依赖 Suspense, 容错依赖 ErrorBoundary，这里并不是直接依赖容器层的 ErrorBoundary，而是复用基础组件，它只作为一个基础组件为加载器单独提供功能。</li>
</ul>
</li>
</ul>
</li>
<li>路由层<ul>
<li>依赖基础容器的 ComponentLoader,  导航路由在上篇文章里已经介绍了实现 <a href="https://juejin.cn/post/6959086599841939486" target="_blank" rel="noopener">传送门</a>，本章不重复介绍。</li>
</ul>
</li>
<li>ErrorBoundary 层<ul>
<li>复用 ErrorBoundary 组件，目的是将 ComponentLoader 加载发生的错误和运行时的错误隔离区别展示。</li>
</ul>
</li>
<li>Suspense 层<ul>
<li>与 ErrorBoundary 相同，也是为了将 ComponentLoader 加载时的过渡动画和 React.lazy 触发的区分开来。</li>
</ul>
</li>
</ul>
<h2 id="api-约定"><a href="#api-约定" class="headerlink" title="api 约定"></a>api 约定</h2><p>为了保证多端实现的API统一，需要定义一个抽象接口中心，把抽象API接口暴露出来，由各端容器的真正实现引入作为核心规范约束。<br><img src="https://static.yuanziwen.cn/blog/container/2.jpg_plain" alt="image.alt"></p>
<p>最终应用入口根据判断环境通过DI (Dependency Injection) 方式注入到下游应用，完成对下游应用的多端兼容。</p>
<p>和钢铁侠很像，他能够根据敌人的特性去装载适合对战的机甲，也能够适应各种环境，故取名<code>@iron-man/container-api</code>，各端实现则为 <code>@iron-man/container-${platform}-impl</code>。 然后小程序限制太大，即便有好的跨端框架，方案也并非完全适用，主要体现在路由和脚本加载方面。</p>
<p>产物最终将提供两种方式接入，两种方式的差别不大，取决于平台的架构模式。</p>
<ol>
<li>DI，类 requirejs，各端统一引入<code>@iron-man/container-api</code> ，平台容器根据环境判断自动注入对应平台的依赖文件。</li>
<li>二方包，类 npm 模块，各端直接引入对应端环境的包。</li>
</ol>
<p>为了避免在npm上发布测试包，本文章容器抽象&amp;web-impl部分使用 Learn 管理，demo 使用 webpack external + requirejs 完成对各端业务mock实现。</p>
<h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><p>根据设计分层可以得到以下结构，基础容器层细分归纳为 Layer，而其他层分类到 Wrapper。</p>
<ul>
<li>Layers<ul>
<li>Basic // 基础层</li>
<li>Scheme // 协议层 </li>
<li>Service // 网关层</li>
</ul>
</li>
<li>Wrappers<ul>
<li>Navigation // 路由层</li>
<li>ErrorBoundary // 容错层</li>
<li>Suspense //  加载层</li>
</ul>
</li>
</ul>
<h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h3><p>一些常用的工具方法</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> TipUtils &#123;</span><br><span class="line">  alert: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  confirm: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  toast: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StorageApi &#123;</span><br><span class="line">  <span class="keyword">get</span>: <span class="function">(<span class="params">key: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">Promise</span>&lt;<span class="built_in">string</span> | <span class="literal">null</span>&gt;;</span><br><span class="line">  <span class="keyword">set</span>: <span class="function">(<span class="params">key: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt;;</span><br><span class="line">  del: <span class="function">(<span class="params">key: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt;;</span><br><span class="line">  getJSON: &lt;T = unknown&gt;<span class="function">(<span class="params">key: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">Promise</span>&lt;T | <span class="literal">null</span>&gt;;</span><br><span class="line">  setJSON: &lt;T = unknown&gt;<span class="function">(<span class="params">key: <span class="built_in">string</span>, value: T</span>) =&gt;</span> <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> PracticalUtils &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 预览图片</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  previewImage: <span class="function">(<span class="params">text: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 复制到剪切板</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  copyToClipboard: <span class="function">(<span class="params">text: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">Promise</span>&lt;<span class="built_in">void</span>&gt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> BasicLayerAbility <span class="keyword">extends</span> TipUtils &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>协议层，主要通过 componentURI 解析生成实际组件/脚本引用地址提供组件渲染和预加载功能。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ComponentType &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; SuspenseAbility &#125; <span class="keyword">from</span> <span class="string">'../wrapper/suspense'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ComponentLoaderProps <span class="keyword">extends</span> SuspenseAbility &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组件协议URI</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  componentURI: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组件 inner Props</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  props?: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> SchemaLayerAbility = &#123;</span><br><span class="line">  ComponentLoader: ComponentType&lt;ComponentLoaderProps&gt;;</span><br><span class="line">  preLoadComponent: <span class="function">(<span class="params">componentName: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Suspense-amp-ErrorBoundary"><a href="#Suspense-amp-ErrorBoundary" class="headerlink" title="Suspense &amp; ErrorBoundary"></a>Suspense &amp; ErrorBoundary</h3><p>提供自定义加装方法和自定义错误边界，两者共有 onError、renderError 方法，由容器侧传入以支持动态配置。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ErrorBoundaryAbility = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出错的事件（包括加载出错和渲染出错）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onError?: <span class="function">(<span class="params">error: <span class="built_in">any</span>, <span class="keyword">type</span>: 'load' | 'render'</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 自定义失败页面</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  renderError?: <span class="function">(<span class="params">error: <span class="built_in">any</span>, <span class="keyword">type</span>: 'load' | 'render'</span>) =&gt;</span> React.ReactNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Suspense</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SuspenseAbility <span class="keyword">extends</span> ErrorBoundaryAbility &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 自定义加载界面</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   renderLoading?: <span class="function"><span class="params">()</span> =&gt;</span> ReactElement;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 加载成功的事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   onLoad?: <span class="function">(<span class="params">componentClass: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h3><p>运行时的实现思路是使用 history API 模拟一个页面栈，所有导航方法的操作都是基于 PageStack，搭配 popstate event 响应返回事件，路由导航能力基于 ComponentLoader。并在其基础上添加了单路由match多副本和路由回调功能，这块内容上篇文章叙述过了，<a href="https://juejin.cn/post/6959086599841939486" target="_blank" rel="noopener">传送门</a>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> NavigationAbility &#123;</span><br><span class="line">  navAPI: &#123;</span><br><span class="line">    navigateTo(page: <span class="built_in">string</span>, params?: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;): <span class="built_in">void</span>;</span><br><span class="line">    back(): <span class="built_in">void</span>;</span><br><span class="line">  </span><br><span class="line">    navigateAndWaitBack(page: <span class="built_in">string</span>, params?: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">    backWithResponse(data: <span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line">  </span><br><span class="line">    replace(page: <span class="built_in">string</span>, params?: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;): <span class="built_in">void</span>;</span><br><span class="line">  </span><br><span class="line">    open(page: <span class="built_in">string</span>, params?: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;): <span class="built_in">void</span>;</span><br><span class="line">    reload(): <span class="built_in">void</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="容器侧配置"><a href="#容器侧配置" class="headerlink" title="容器侧配置"></a>容器侧配置</h3><p>部分配置,  具体配置请查看 <a href="https://github.com/yzw7489757/container-api/blob/master/packages/container-api/src/ContainerProps.ts#L33" target="_blank" rel="noopener">container-api</a>。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ContainerProps &#123;</span><br><span class="line">  children?: ReactNode;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 环境注入</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  envType?: EnvTypeEnum;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 单路由多副本缓存规则</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cacheOptions?: <span class="built_in">Array</span>&lt;<span class="built_in">RegExp</span>&gt;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 自定义解析</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  customResolveModuleRule?: <span class="function">(<span class="params">componentURI: <span class="built_in">string</span></span>) =&gt;</span> ModuleType | <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 预置组件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  modules?: &#123;</span><br><span class="line">    readonly [moduleURI: <span class="built_in">string</span>]: RemoteModule | LazyModule | LocalModule;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 自定义加装动画</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  readonly withSuspense?: <span class="built_in">boolean</span> | React.ComponentType&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 自定义错误边界</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  readonly withErrorBoundary?: <span class="built_in">boolean</span> | React.ComponentType&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mock实现"><a href="#Mock实现" class="headerlink" title="Mock实现"></a>Mock实现</h3><p>除了要定义接口，还需要对部分功能做初步实现，这样就可以直接打 container-api 的包，在 demo 里引入该声明文件。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> * <span class="keyword">as</span> ContainerAPI <span class="keyword">from</span> <span class="string">'../../context/index'</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '@iron-man/container-api' &#123;</span><br><span class="line">  <span class="keyword">export</span> = ContainerAPI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Web-implement"><a href="#Web-implement" class="headerlink" title="Web-implement"></a>Web-implement</h2><h3 id="初始化上下文"><a href="#初始化上下文" class="headerlink" title="初始化上下文"></a>初始化上下文</h3><p>web端实现，可以使用各种开放能力，但在实现之前，首先需要初始化Context对各API提供初步的mock实现。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BasicLayerAbility, ServiceLayerAbility, SchemaLayerAbility, NavigationAbility, ContainerAbility &#125; <span class="keyword">from</span> <span class="string">'@iron-man/container-api'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; unimplementedAsyncFunction, unimplementedFunction, unimplementedComponent &#125; <span class="keyword">from</span> <span class="string">'./utils/initialFunction'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultBasicAbility = &#123;</span><br><span class="line">  alert: unimplementedFunction,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> defaultSchema = &#123;</span><br><span class="line">  componentLoader: unimplementedComponent,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// other ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> containerContext: Context&lt;ContainerAbility&gt; = createContext(&#123;</span><br><span class="line">  ...defaultBasicAbility,</span><br><span class="line">  ...defaultSchema,</span><br><span class="line">  ...defaultService,</span><br><span class="line">  ...defaultNavigation</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Basic-1"><a href="#Basic-1" class="headerlink" title="Basic"></a>Basic</h3><p>下一步是初始化基础容器, <code>createContainer</code> 负责整合基础容器层内的layer，提供迭代方法初始化。</p>
<h4 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// layers</span></span><br><span class="line"><span class="keyword">import</span> &#123; ContainerOptions, ContainerAbility &#125; <span class="keyword">from</span> <span class="string">'@iron-man/container-api'</span>;</span><br><span class="line"><span class="keyword">import</span> BasicLayer <span class="keyword">from</span> <span class="string">'./basic'</span>;</span><br><span class="line"><span class="keyword">import</span> SchemaLayer <span class="keyword">from</span> <span class="string">'./schema/index'</span>;</span><br><span class="line"><span class="keyword">import</span> ServiceLayer <span class="keyword">from</span> <span class="string">'./service/index'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LayerIteration &#125; <span class="keyword">from</span> <span class="string">'./interface'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> layers: LayerIteration[] = [BasicLayer, SchemaLayer, ServiceLayer];</span><br><span class="line"><span class="comment">// 初始化基础上下文</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createContainer</span>(<span class="params">originContainer: ContainerAbility, options: ContainerOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> layers.reduce(<span class="function">(<span class="params">preContainer, layer</span>) =&gt;</span> layer(preContainer, options), originContainer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ContainerProps &#125; <span class="keyword">from</span> <span class="string">'@iron-man/container-api'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; containerContext <span class="keyword">as</span> ContainerContext &#125; <span class="keyword">from</span> <span class="string">'@/containerContext'</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基础容器层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">BasicContainer</span>(<span class="params">props: ContainerProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; children, ...restProps &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> propsRef = useSafeTrackingRef(restProps);</span><br><span class="line">  <span class="keyword">const</span> originContext = useContext(ContainerContext);</span><br><span class="line">  <span class="keyword">const</span> value = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> createContainer(originContext, propsRef.current), []);</span><br><span class="line">  <span class="keyword">return</span> &lt;ContainerContext.Provider value=&#123;value&#125;&gt;&#123;children&#125;&lt;<span class="regexp">/ContainerContext.Provider&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BasicLayer</span>(<span class="params">origin: ContainerAbility, options: ContainerOptions</span>): <span class="title">ContainerAbility</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> basic = createBasicLayer(origin, options)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...origin,</span><br><span class="line">    ...basic</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBasicLayer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; alert: AM.alert, toast: AM.toast, ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目需求里无线端 antd-mobile 用的比较多，这里就提供它的实现了。需要注意的是适配接口参数类型。再照猫画虎定义好其他工具API，基础容器层工具部分就实现完了。</p>
<h4 id="服务网关层"><a href="#服务网关层" class="headerlink" title="服务网关层"></a>服务网关层</h4><p>主要包含服务调用和服务注入，服务调用包含基本的request/jsonp，每个公司都可能有自己的一套网关，也可以根据 <a href="https://www.npmjs.com/package/natty-fetch" target="_blank" rel="noopener">natty-fetch</a> 去定制团队协同规范，注入服务提供自定义服务，但必须固化参数。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ServiceLayer</span>(<span class="params">origin: ContainerAbility, options: ContainerOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...origin,</span><br><span class="line">    service: &#123;</span><br><span class="line">      ...createServicePortal(origin, options), <span class="comment">// 注册服务调用</span></span><br><span class="line">      ...createCustomServicePortal(origin, options), <span class="comment">// 提供注册自定义服务</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上下文注入的domain&amp;判断环境加载服务，这里request就用fetch做简单实现。<code>createCustomServicePortal</code> 包装自定义服务。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createServicePortal</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  origin: ContainerAbility,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ContainerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Pick</span>&lt;<span class="title">ServiceLayerAbility</span>['<span class="title">service</span>'], '<span class="title">jsonp</span>' | '<span class="title">request</span>' | '<span class="title">getService</span>'&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Request = createRequestService(options.envType || <span class="string">'online'</span>); <span class="comment">// 创建request服务</span></span><br><span class="line">  <span class="keyword">const</span> Jsonp = createJsonpService(options.envType || <span class="string">'online'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> presetServices = &#123;</span><br><span class="line">    request: Request,</span><br><span class="line">    jsonp: Jsonp,</span><br><span class="line">  &#125;;</span><br><span class="line">	<span class="comment">// 提供统一获取服务的入口</span></span><br><span class="line">  <span class="keyword">const</span> getService = (name: <span class="built_in">string</span>): TypeRequest | CustomFetcher | <span class="function"><span class="params">null</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(presetServices, name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> presetServices[name <span class="keyword">as</span> keyof <span class="keyword">typeof</span> presetServices];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> origin.service.getCustomService(name)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...presetServices,</span><br><span class="line">    getService,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="协议层-组件-模块加载器"><a href="#协议层-组件-模块加载器" class="headerlink" title="协议层(组件/模块加载器)"></a>协议层(组件/模块加载器)</h4><p>比较麻烦的是协议层，它支持三种模块引入，远程模块、本地模块、懒加载模块，本地模块很容器理解，懒加载模块大致上和远程模块类似，不同点是额外提供懒加载能力，远程模块可以引入AMD、CMD、UMD、<del>ESM</del>模块。</p>
<p>除此之外，还需要考虑几个问题</p>
<ul>
<li>协议解析，如何根据协议解析判断你到底是想要哪种模块，并且可以自定义解析模块<ul>
<li>远程模块 =&gt; URL</li>
<li>本地模块 =&gt; 内置/预置组件</li>
</ul>
</li>
<li>协议缓存与组件预加载。</li>
<li>自定义加装动画和错误边界</li>
</ul>
<h5 id="协议规范"><a href="#协议规范" class="headerlink" title="协议规范"></a>协议规范</h5><p>无论是任何类型的组件，都会有其自身的“身份信息”，这些信息在加载过程中仅提供给加载器使用，除此之外，对外有统一的加装方法供调用。加载和渲染区分开来，预加载实际意义上即是只调用了加载方法。</p>
<p>如何生成组件的“身份信息”，<code>componentLoader</code> 接受一个 componentURI 参数，该参数根据协议解析中的协议头、协议体、协议参数，默认协议支持如下三种格式。流程如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="string">"group://chat.list#default"</span> <span class="comment">// 团队仓库模块</span></span><br><span class="line"><span class="string">"internal://Loading"</span> <span class="comment">// 本地/内置模块</span></span><br><span class="line"><span class="string">"https://xxx.com/group/repo_name/version/index.js#Home"</span> <span class="comment">// 远程协议模块</span></span><br></pre></td></tr></table></figure>

<p><img src="https://static.yuanziwen.cn/blog/container/3.jpg_plain" alt="image"></p>
<p>通过解析协议拿到模块的地址，这个地址可能是外链也可能是本地，也有可能是本地+外链资源的混合 —— lazyModule，拿到组件身份信息后，根据模块类型加载脚本，加装动画和错误边界后渲染出来，过程中还需要考虑缓存和避免重复加载的问题。预加载的区别只是没有最后Render那一步。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createComponentLoader = (origin: ContainerAbility, options: ContainerOptions): Pick&lt;ContainerAbility, <span class="string">'ComponentLoader'</span> | <span class="string">'preLoadComponent'</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; getComponentInfo &#125; = createComponentRegister(options, INTERNAL_MODULES);</span><br><span class="line">  <span class="comment">// 加载组件</span></span><br><span class="line">	<span class="keyword">const</span> componentLoader = <span class="function">(<span class="params">loaderProps: ComponentLoaderProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &lt;ComponentRender componentURI=&#123;componentURI&#125; innerProps=&#123;innerProps&#125; /&gt;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 渲染组件</span></span><br><span class="line">	<span class="keyword">const</span> ComponentRender: React.FC&lt;ComponentRenderProps&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; componentURI, innerProps = &#123;&#125; &#125; = props;</span><br><span class="line">    <span class="comment">// 获取组件身份信息</span></span><br><span class="line">    <span class="keyword">const</span> componentInfo = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> getComponentInfo(componentURI), [componentURI]);</span><br><span class="line">    <span class="keyword">if</span> (!componentInfo) &#123;</span><br><span class="line">      <span class="comment">// 踢出不符合协议格式的消息数据</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`unknown componentURI <span class="subst">$&#123;componentURI&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fragment规避掉ts报错</span></span><br><span class="line">    <span class="keyword">return</span> &lt;&gt;&#123;componentInfo.render(innerProps)&#125;&lt;<span class="regexp">/&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    componentLoader,</span></span><br><span class="line"><span class="regexp">    preLoadComponent: (componentURI: string) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      const componentInfo = getComponentInfo(componentURI);</span></span><br><span class="line"><span class="regexp">      if (!componentInfo) &#123;</span></span><br><span class="line"><span class="regexp">        throw new CantGetModuleInfo(componentURI);</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">			/</span><span class="regexp">/ 仅调用 load 方法</span></span><br><span class="line"><span class="regexp">      return componentInfo.load();</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>getComponentInfo(componentURI)</code> 主要做三件事情</p>
<ol>
<li>解析协议，提供对外加载的API。</li>
<li>提供协议解析与组件的缓存。</li>
<li>提供自定义协议解析流程。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createComponentRegister = <span class="function">(<span class="params">options: ContainerOptions, internalModule: ContainerOptions['modules']</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> registerMap = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> Map(), []);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getComponentInfo</span>(<span class="params">componentURI: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存</span></span><br><span class="line">    <span class="keyword">if</span>(registerMap.has(componentURI)) &#123;</span><br><span class="line">      <span class="keyword">return</span> registerMap.get(componentURI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自解析协议 &gt; 内置模块 &gt; 协议解析</span></span><br><span class="line">    <span class="keyword">const</span> info: ModuleType = options.customResolveModuleRule?.call(<span class="literal">null</span>, componentURI) || </span><br><span class="line">      internalModule &amp;&amp; internalModule[componentURI] ||</span><br><span class="line">      resolveModule(componentURI, options);</span><br><span class="line">      <span class="keyword">if</span>(!info) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CantGetModuleInfo(componentURI);</span><br><span class="line">      &#125;</span><br><span class="line">    	</span><br><span class="line">      <span class="keyword">return</span> registerComponentFromModuleInfo(componentURI, info);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    registerMap,</span><br><span class="line">    getComponentInfo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="协议解析"><a href="#协议解析" class="headerlink" title="协议解析"></a>协议解析</h5><p>协议解析就比较好处理了，只可能存在三种类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> RemoteModule = &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'remote'</span>;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">  format?: <span class="string">'AMD'</span> | <span class="string">'UMD'</span> | <span class="string">'CMD'</span>;</span><br><span class="line">  <span class="comment">/** 组件的导出名 */</span></span><br><span class="line">  exportName?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> LocalModule = &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'local'</span>;</span><br><span class="line">  <span class="keyword">module</span>: unknown;</span><br><span class="line">&#125;;</span><br><span class="line">export type LazyModule = &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'lazy'</span>;</span><br><span class="line">  <span class="keyword">module</span>: () =&gt; Promise&lt;unknown&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">export type ModuleType = LocalModule | RemoteModule | LazyModule;</span><br></pre></td></tr></table></figure>

<p>然后通过<code>parseURI</code> 解析协议URI，得到以下几种字段</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> moduleURIInfo = &#123;</span><br><span class="line">  protocol: <span class="built_in">string</span>; <span class="comment">// 协议</span></span><br><span class="line">  path: <span class="built_in">string</span>; <span class="comment">// 文件路径</span></span><br><span class="line">  subPath: <span class="built_in">string</span>; <span class="comment">// 模块路径</span></span><br><span class="line">  <span class="comment">// cacheId: string; // 缓存, 路由层需要用到，可先忽略</span></span><br><span class="line">  componentURI: <span class="built_in">string</span>; <span class="comment">// 完整路径</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据 protocol 字段命中对应的协议体解析逻辑</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> ProtocolEnum &#123;</span><br><span class="line">  http = <span class="string">'http'</span>,</span><br><span class="line">  https = <span class="string">'https'</span>,</span><br><span class="line">  group = <span class="string">'group'</span>,</span><br><span class="line">  internal = <span class="string">'internal'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveModule</span>(<span class="params">componentURI: <span class="built_in">string</span>, options: ContainerOptions</span>): <span class="title">ModuleType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> uriInfo = parseURI(componentURI, options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (uriInfo.protocol) &#123;</span><br><span class="line">    <span class="keyword">case</span> ProtocolEnum.http:</span><br><span class="line">    <span class="keyword">case</span> ProtocolEnum.https: &#123; <span class="comment">// 远程协议模块</span></span><br><span class="line">      <span class="keyword">return</span> parseRemoteModule(uriInfo, options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ProtocolEnum.group: &#123; <span class="comment">// 团队仓库模块</span></span><br><span class="line">      <span class="keyword">return</span> parseGroupModule(uriInfo, options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ProtocolEnum.internal: &#123; <span class="comment">// 内置模块</span></span><br><span class="line">      <span class="keyword">return</span> Reflect.get(options.modules || &#123;&#125;, uriInfo.path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> InvalidComponentURIProtocol(uriInfo.protocol);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseGroupModule</span>(<span class="params">uriInfo: moduleURIInfo, options: ContainerOptions</span>): <span class="title">ModuleType</span> </span>&#123;</span><br><span class="line">  <span class="comment">// custom rule for group ...</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="string">'remote'</span>,</span><br><span class="line">    url: <span class="string">`//xxx.com/<span class="subst">$&#123;uriInfo.protocol&#125;</span>/<span class="subst">$&#123;uriInfo.path&#125;</span>.js`</span>,</span><br><span class="line">    exportName: uriInfo.subPath,</span><br><span class="line">    format: <span class="string">'UMD'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他命中逻辑类似，此处还应该细化组件的版本信息和协议头控制，例如在模板内注入全局组件版本映射表，以及更为灵动的协议头match规则，group =&gt; hotline-group。。。</p>
<h5 id="协议加载"><a href="#协议加载" class="headerlink" title="协议加载"></a>协议加载</h5><p>接下来就是加载过程，可自行注入全局的事件钩子，e.g. registed、beforeLoad 、loaded。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerComponentFromModuleInfo</span>(<span class="params">componentURI: <span class="built_in">string</span>, info: ModuleType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _component: <span class="built_in">any</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 包装器，等待注入加载请求逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createComponentInfo</span>(<span class="params">fetchComponent: Fetcher&lt;<span class="built_in">any</span>&gt;</span>): <span class="title">ComponentInfo</span> </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> load = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> Component = fetchComponent();</span><br><span class="line">        <span class="keyword">if</span> (!Component) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InvalidComponentError(componentURI, getModuleName(info));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _component = Component;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        id: componentURI,</span><br><span class="line">        render: <span class="function">(<span class="params">props: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> Component = load();</span><br><span class="line">          <span class="keyword">return</span> React.createElement(Component, props);</span><br><span class="line">        &#125;,</span><br><span class="line">        load,</span><br><span class="line">        <span class="keyword">get</span> component() &#123;</span><br><span class="line">          <span class="keyword">return</span> _component;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(info.type === <span class="string">'local'</span>) &#123; <span class="comment">// 本地模块</span></span><br><span class="line">      <span class="keyword">return</span> register(componentURI, createComponentInfo(<span class="function"><span class="params">()</span> =&gt;</span> info.<span class="keyword">module</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(info.type === 'lazy') &#123; <span class="comment">// 懒加载模块</span></span><br><span class="line">      <span class="keyword">return</span> register(componentURI, createComponentInfo(createFetcher(info.<span class="keyword">module</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(info.type === 'remote') &#123;</span><br><span class="line">      <span class="keyword">const</span> fetcher = createFetcher(<span class="keyword">async</span> () =&gt; loadModule(&#123;</span><br><span class="line">          name: info.name,</span><br><span class="line">          url: info.url,</span><br><span class="line">          exportName: info.exportName || <span class="string">''</span>,</span><br><span class="line">          format: info.format || <span class="string">'UMD'</span></span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> register(componentURI, createComponentInfo(fetcher));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidModuleURIError(componentURI);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>都知道除了 hooks 之外的函数在函数组件里都会执行多次，为了组件只加载一次，需要利用闭包函数。<code>loadModule</code> 是脚本加载函数，屏蔽了部分细节，例如处理可能存在的沙盒、requirejs、环节限制不能注入脚本(fetch内容eval掉，注意跨域)，web直接使用了<a href="https://www.npmjs.com/package/umd-package-loader" target="_blank" rel="noopener"> url-package-loader </a>，这个包内置了AMD兼容方案。如果环境不支持 amd，需要额外配置 libraryName 降低到 UMD。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadModule</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params">config: LoadModuleOptions</span>): <span class="title">Promise</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; url, name, format = <span class="string">'UMD'</span>, exportName &#125; = config;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">module</span>;</span><br><span class="line">	// PackageLoader 内置了 amd 判断，暂时先写成一样的</span><br><span class="line">  if (format === 'UMD' || format === 'AMD') &#123;</span><br><span class="line">    <span class="keyword">module</span> = await new PackageLoader(&#123; name, url &#125;).loadScript();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">module</span> &amp;&amp; exportName) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">get</span>(<span class="keyword">module</span>, exportName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (<span class="keyword">module</span> &amp;&amp; <span class="keyword">module</span>.__esModule &amp;&amp; !exportName) &#123; <span class="comment">// es module</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.<span class="keyword">default</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">module</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，基础容器就可以跑起来了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const App: FC&lt;ContainerProps&gt; = (props) =&gt; &#123;</span><br><span class="line">  &lt;BasicContainer &#123;...props&#125;&gt;</span><br><span class="line">    &lt;Demo /&gt;</span><br><span class="line">  &lt;/BasicContainer&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Demo = () =&gt; &#123;</span><br><span class="line">  const container = useContext(containerContext);</span><br><span class="line">  const &#123; ComponentLoader &#125; = container;</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // container.toast(&apos;xxx&apos;)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">    	&lt;ComponentLoader</span><br><span class="line">        componentURI=&quot;https://0.0.0.0:8082/todoList&quot;</span><br><span class="line">        props=&#123;&#123;</span><br><span class="line">          title: &apos;蔬菜&apos;,</span><br><span class="line">          itemList: [&apos;🥒&apos;, &apos;🥔&apos;, &apos;🎃&apos;],</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;ComponentLoader</span><br><span class="line">        componentURI=&quot;group://todoList#default&quot;</span><br><span class="line">        props=&#123;&#123;</span><br><span class="line">          title: &apos;水果&apos;,</span><br><span class="line">          itemList: [&apos;🍌&apos;, &apos;🍊&apos;, &apos;🍐&apos;, &apos;🍉&apos;],</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://static.yuanziwen.cn/blog/container/4.png_plain" alt="img.png"></p>
<h3 id="Navigator-1"><a href="#Navigator-1" class="headerlink" title="Navigator"></a>Navigator</h3><p>虽然之前文章已经详细介绍过，还是要唠叨一嘴，路由层解决的问题是</p>
<ol>
<li>无刷新切换路由，与上层路由不耦合、不冲突，可并用。</li>
<li>路由多副本缓存，例如多个聊天界面。</li>
<li>静默路由不更新。</li>
<li>提供路由钩子和路由回调。</li>
</ol>
<p><a href="https://juejin.cn/post/6959086599841939486" target="_blank" rel="noopener">数据管控路由实现状态持久化</a></p>
<h3 id="ErrorBoundary"><a href="#ErrorBoundary" class="headerlink" title="ErrorBoundary"></a>ErrorBoundary</h3><p>本质是控制错误的边界，不至于让整个应用崩溃，同时也提供兜底视图，除了提升用户体感外还可以附加其他功能，比如“点击重试”、“错误展示/上报”等，在此基础上，提供了自定义边界的接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ErrorBoundaryContainer: React.FC&lt;ContainerProps&gt; = props =&gt; &#123;</span><br><span class="line">  const &#123; children, withErrorBoundary &#125; = props;</span><br><span class="line">  if (withErrorBoundary === true || withErrorBoundary === undefined) &#123;</span><br><span class="line">    return &lt;ErrorBoundaryWrapper&gt;&#123;children&#125;&lt;/ErrorBoundaryWrapper&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof withErrorBoundary === &apos;function&apos;) &#123;</span><br><span class="line">    return createElement(withErrorBoundary, &#123;&#125;, children);</span><br><span class="line">  &#125;</span><br><span class="line">  return children as ReactElement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><p>它的原理是通过捕捉子组件抛出的 Promise 状态来判断完成加载渲染，配合 React.lazy + dynamic import 可以达到 code-splitting 的效果，与 ErrorBoundary 同样要为其提供自定义 Suspense 的接口。注意某些不支持Suspense的情况，e.g. 没有 动态import，自定义Suspense 需要借助 ErrorBoundaryWrapper  来完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const MockSuspense = () =&gt; &#123;</span><br><span class="line">  // ...other</span><br><span class="line">    const handleError = useCallback((boundaryError: any) =&gt; &#123;</span><br><span class="line">        // Error or not Promise, continue throw</span><br><span class="line">        if (boundaryError instanceof Error || !isPromiseAlike(boundaryError)) &#123;</span><br><span class="line">          throw boundaryError;</span><br><span class="line">        &#125;</span><br><span class="line">        const thePromise = boundaryError;</span><br><span class="line">        promiseIdRef.current = Date.now() + Math.random();</span><br><span class="line">        const thePromiseId = promiseIdRef.current;</span><br><span class="line"></span><br><span class="line">        // promise only</span><br><span class="line">        thePromise.then(() =&gt; &#123;</span><br><span class="line">            // success </span><br><span class="line">          &#125;,</span><br><span class="line">          (err: any) =&gt; &#123;</span><br><span class="line">            if (thePromiseId === promiseIdRef.current) &#123;</span><br><span class="line">              // fail</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">  &#125;, []);</span><br><span class="line">  return (</span><br><span class="line">    &lt;ErrorBoundaryWrapper onError=&#123;handleError&#125; renderError=&#123;renderFallback&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/ErrorBoundaryWrapper&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SuspenseContainer.tsx</span><br><span class="line">const SuspenseContainer: React.FC&lt;ContainerProps&gt; = (props: ContainerProps) =&gt; &#123;</span><br><span class="line">  const &#123; children, withSuspense &#125; = props;</span><br><span class="line"></span><br><span class="line">  if (withSuspense === true || withSuspense === undefined) &#123;</span><br><span class="line">    return &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;&#123;children&#125;&lt;/Suspense&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (typeof withSuspense === &apos;function&apos;) &#123;</span><br><span class="line">    return createElement(withSuspense, &#123; fallback: &lt;Loading /&gt; &#125;, children);</span><br><span class="line">  &#125;</span><br><span class="line">  return children as ReactElement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至此，完成了web-impl，使用起来非常简单，因为是使用 Context API，只需要在应用最外层包裹即可，像 react-route 一样，提供了 <code>withContext</code> 的注入方式和 Context 自带的 Hooks API。</p>
<blockquote>
<p><a href="https://webpack.js.org/configuration/externals/#externals" target="_blank" rel="noopener">https://webpack.js.org/configuration/externals/#externals</a></p>
<p>搭配 requirejs<code>requirejs.config({ paths: { &quot;@iron-man/container-web-api&quot;: &quot;//0.0.0.0:7105/index&quot; } })</code> </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Container: FC&lt;ContainerProps&gt; = (&#123; children, ...props &#125;) =&gt; (</span><br><span class="line">  &lt;BasicContainer &#123;...props&#125;&gt;</span><br><span class="line">    &lt;NavigatorContainer &#123;...props&#125;&gt;</span><br><span class="line">      &lt;ErrorBoundaryContainer &#123;...props&#125;&gt;</span><br><span class="line">        &lt;SuspenseContainer &#123;...props&#125;&gt;&#123;children&#125;&lt;/SuspenseContainer&gt;</span><br><span class="line">      &lt;/ErrorBoundaryContainer&gt;</span><br><span class="line">    &lt;/NavigatorContainer&gt;</span><br><span class="line">  &lt;/BasicContainer&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const App = () =&gt; (</span><br><span class="line">  &lt;Container &#123;...options&#125;&gt;</span><br><span class="line">  	&lt;Demo /&gt;</span><br><span class="line">  &lt;/Container&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const Demo = () =&gt; &#123;</span><br><span class="line">  const container = useContext(containerContext);</span><br><span class="line">&#125;</span><br><span class="line">// or</span><br><span class="line">const Demo = withContext&lt;DemoProps&gt;((props) =&gt; &#123;</span><br><span class="line">  const &#123; navAPI &#125; = props;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://static.yuanziwen.cn/blog/container/5.gif" alt="1620281708889.gif"></p>
<p>其他端容器大部分实现相似，只需要对不同业务体系和端环境区别实现即可。</p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="blog.yuanziwen.cn">Seven</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="blog.yuanziwen.cn/2021/06/01/使用React构建多端容器/">blog.yuanziwen.cn/2021/06/01/使用React构建多端容器/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        
        <nav class="post-nav"><a class="next" href="/2021/05/06/数据管控路由实现状态持久化/">
        <span class="next-text nav-default">数据管控路由实现状态持久化</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'cxeaTV5BFDCxPmxoCcG9QPxf-gzGzoHsz',
        appKey: 's577OrPG5sB4Szom6mvHuI1X',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info: guest,
        pageSize:'10' || 10,
    });
  </script>

<footer id="footer" class="footer"><div class="social-links"><a href="mailto:yuanziwen7489757@gmail.com" class="iconfont icon-email" title="email"></a>
          <a href="https://juejin.im/user/59aa31a06fb9a02485103ddf" class="iconfont juejin" title="掘金"><div class="img"></div></a>
        <a href="https://github.com/yzw7489757" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <!--<span class="division">|</span>
  <span class="theme-info">
    footer.theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>-->
  <span class="power-by">
   <a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备18011257号-1</a>
  </span>
  <span class="copyright-year">&copy;2017 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Seven</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
<script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js?t=1624262701310')
    .then(function () {console.log('ServiceWorker Register Successfully.')})
    .catch(function (e) {console.error(e)});
}
</script></body>
</html>
